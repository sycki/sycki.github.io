<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>橡果笔记</title>
    <link>http://localhost:1313/index.html</link>
    <description>Recent content on 橡果笔记</description>
    <generator>Hugo</generator>
    <language>en</language>
    <atom:link href="http://localhost:1313/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title></title>
      <link>http://localhost:1313/algorithm/algorithm-collaborative-filtering.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/algorithm/algorithm-collaborative-filtering.html</guid>
      <description>&lt;h1 id=&#34;推荐算法---协同过滤&#34;&gt;推荐算法 - 协同过滤&lt;a class=&#34;anchor&#34; href=&#34;#%e6%8e%a8%e8%8d%90%e7%ae%97%e6%b3%95---%e5%8d%8f%e5%90%8c%e8%bf%87%e6%bb%a4&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;p&gt;协同过滤是一种推荐算法，它是一种解决特定问题的思路，而非一种固定算法，所以它可以有多种实现，各种实现略有差异，本文将用通俗的方式帮助你了解它的原理，并给出一个应用的实例。&lt;/p&gt;&#xA;&lt;h2 id=&#34;理解协同过滤&#34;&gt;理解协同过滤&lt;a class=&#34;anchor&#34; href=&#34;#%e7%90%86%e8%a7%a3%e5%8d%8f%e5%90%8c%e8%bf%87%e6%bb%a4&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;假如我有一个跟我品味相似的朋友，大多数时候，我喜欢听的歌他也喜欢，这时就可以把那些我喜欢的而他没有听过的歌，推荐给他，反之，他也可以推荐给我。 这里有两个关键指标，一个是需要知道我对每首歌的喜欢程度，还有就是哪些人与我品味相似。 图解一下：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;img/algorithm-collaborative-filtering/algorithm-collaborative-filtering_table.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;&#xA;&lt;p&gt;上表有ABC三人，与XYZ三首歌，数字表示用户给歌曲的评分（满分为10），也表示用户对歌曲的喜欢程度，例如：用户A对歌曲X的喜欢程度为9。而用户A与用户B可以认为是品味相似，因为用户AB同时喜欢歌曲X，且同时不太喜欢歌曲Y。这时就可以将用户A喜欢的歌曲Z推荐给用户B。&lt;/p&gt;&#xA;&lt;h2 id=&#34;计算用户相关性&#34;&gt;计算用户相关性&lt;a class=&#34;anchor&#34; href=&#34;#%e8%ae%a1%e7%ae%97%e7%94%a8%e6%88%b7%e7%9b%b8%e5%85%b3%e6%80%a7&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;关于这个问题，网上大多都提到了“欧几里得距离”以及“皮尔逊相关系数”这两个方法，相信这两种方法的相应实现，网上也能找到一大把，不过我想以另一种方法来说明一下，还是以上面的表为例，我们以每首歌为单为，求出所有用户对每首歌的评价的相似性，如下：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;所有用户对歌曲X评价的相似性：&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;img src=&#34;img/algorithm-collaborative-filtering/algorithm-collaborative-filtering_tablex.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;&#xA;&lt;p&gt;计算规则：用户A对X的评分为9，用户B对X的评分为8，求出它们的差的绝对值，也就是1，值越小相关性越强。依此类推求出剩下人的相关性。灰色部分的值是重覆的，因此略过。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;所有用户对歌曲Y评价的相似性：&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;img src=&#34;img/algorithm-collaborative-filtering/algorithm-collaborative-filtering_tabley.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;将上面两张表合并，也就是将他们的值合并起来：&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;img src=&#34;img/algorithm-collaborative-filtering/algorithm-collaborative-filtering_table-sum.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;&#xA;&lt;p&gt;这张表上的值表示：A与B的相关性最强，B与C其次，A与C相关性则最差。 当然，我们可以将上表中的结果提取出来做个排序，这样当A有了喜欢的新歌时，根据每个用户与A的相关性排序，应优先推荐给B，其次是C。而当C有了喜欢的新歌时，优先推荐给B，其次才是A。&lt;/p&gt;&#xA;&lt;h2 id=&#34;使用spark-mllib中的als算法&#34;&gt;使用Spark MLLib中的ALS算法&lt;a class=&#34;anchor&#34; href=&#34;#%e4%bd%bf%e7%94%a8spark-mllib%e4%b8%ad%e7%9a%84als%e7%ae%97%e6%b3%95&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;上面只是帮助你理解协同过滤的核心思想，而实际的实现有多种，而且也比较复杂，不过在Spark的机器学习库中已经有相应的实现，也就是ALS算法，我们只需提供数据集，可以很容易的使用，下面就来演示一下它的用法。&lt;/p&gt;&#xA;&lt;h3 id=&#34;生成测试数据&#34;&gt;生成测试数据&lt;a class=&#34;anchor&#34; href=&#34;#%e7%94%9f%e6%88%90%e6%b5%8b%e8%af%95%e6%95%b0%e6%8d%ae&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package com.algorithm.matrix&#xA; &#xA;import scala.util.Random&#xA;import java.io.PrintWriter&#xA; &#xA;/**&#xA; * 此类用来生成一些测试数据并写入到指定的文件中&#xA; */&#xA;object GenFile {&#xA;   &#xA;  //模拟歌手列表&#xA;  val artists = Array(&amp;#34;李健&amp;#34;,&amp;#34;吉克隽逸&amp;#34;,&amp;#34;吴莫愁&amp;#34;,&amp;#34;杨坤&amp;#34;,&amp;#34;宋祖英&amp;#34;,&amp;#34;罗大佑&amp;#34;,&amp;#34;龙梅子&amp;#34;,&#xA;    &amp;#34;水木年华&amp;#34;,&amp;#34;小沈阳&amp;#34;,&amp;#34;谭晶&amp;#34;,&amp;#34;蔡健雅&amp;#34;,&amp;#34;刘佳&amp;#34;,&amp;#34;王蓉&amp;#34;,&amp;#34;黄龄&amp;#34;,&amp;#34;庞麦郎&amp;#34;,&amp;#34;钟汉良&amp;#34;)&#xA;   &#xA;  //模拟用户列表&#xA;  val user = Array(&amp;#34;q&amp;#34;,&amp;#34;w&amp;#34;,&amp;#34;e&amp;#34;,&amp;#34;r&amp;#34;,&amp;#34;t&amp;#34;,&amp;#34;y&amp;#34;,&amp;#34;u&amp;#34;,&amp;#34;i&amp;#34;,&amp;#34;o&amp;#34;,&amp;#34;p&amp;#34;,&amp;#34;a&amp;#34;,&amp;#34;s&amp;#34;)&#xA;   &#xA;  //创建一个随机对象&#xA;  val random = Random&#xA;   &#xA;  /**&#xA;   * 定义一个函数，用随机的的方式模拟出某用户听了某歌手的歌，并给出评分&#xA;   * 生成数据格式为：用户ID，歌手ID，评分&#xA;   */&#xA;  def genLine() = {&#xA;    val ad = artists(random.nextInt(artists.length)).hashCode()&#xA;    val ud = user(random.nextInt(user.length)).hashCode()&#xA;    val count = random.nextInt(30) + 1&#xA;    s&amp;#34;$ud,$ad,$count&amp;#34;&#xA;  }&#xA;   &#xA;  def main(args: Array[String]): Unit = {&#xA;     &#xA;    //创建文件对象&#xA;    val file = new PrintWriter(&amp;#34;D:/Downloads/user_artists.log&amp;#34;)&#xA;     &#xA;    //生成1000条评价，每条为一行，写入文件中&#xA;    for(i &amp;lt;- 0 to 1000){&#xA;      val str = genLine&#xA;      file.println(str)&#xA;    }&#xA;     &#xA;    file.close()&#xA;     &#xA;  }&#xA;   &#xA;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面代码用来生成一些模拟数据，这个不是必须的，可以用自己的方法得到数据，生成完以后就可以上传到HDFS中，比如： &lt;code&gt;hdfs:///test/user_artists.log&lt;/code&gt; 这个位置。当然只是测试的话也可以放在本地，然后以本地模式启动Spark来运行。&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/algorithm/algorithm-naive-bayes.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/algorithm/algorithm-naive-bayes.html</guid>
      <description>&lt;h1 id=&#34;分类算法---朴素贝叶斯&#34;&gt;分类算法 - 朴素贝叶斯&lt;a class=&#34;anchor&#34; href=&#34;#%e5%88%86%e7%b1%bb%e7%ae%97%e6%b3%95---%e6%9c%b4%e7%b4%a0%e8%b4%9d%e5%8f%b6%e6%96%af&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;p&gt;朴素贝叶斯是种简单而有效的分类算法，被应用在很多二元分类器中，那什么叫二元分类？也就是非A即B，假设我现在用朴素贝叶斯算法写一个分类器，然后输入一封邮件，它可以根据特征库来判断这封邮件是不是垃圾邮件。当然，它还可以用来处理多元分类的问题，比如：文章分类、拼写纠正等等。&lt;/p&gt;&#xA;&lt;h2 id=&#34;基本原理&#34;&gt;基本原理&lt;a class=&#34;anchor&#34; href=&#34;#%e5%9f%ba%e6%9c%ac%e5%8e%9f%e7%90%86&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;在网上已经有很多关于朴素贝叶斯的介绍了，其中不乏一些讲得深刻而又通俗易懂的文章，本文不准备长篇大论探讨它的数学原理及深层含义，不过基本原理还是得讲一下，先说一下条件概率模型，以下摘抄自wiki：&lt;/p&gt;&#xA;&lt;blockquote class=&#39;book-hint &#39;&gt;&#xA;&lt;p&gt;公式：p(C|F1,&amp;hellip;,Fn)&#xA;解释：独立的类别变量C有若干类别，条件依赖于若干特征变量。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;意思是说，在F1,F2,F3&amp;hellip;这些特征发生的情况下，类别C的发生概率，很容易理解。 那么，如果我事先知道类别C发生的情况下，F1,F2,F3&amp;hellip;出现的概率，也就是p(F1,&amp;hellip;,Fn|C)，那么也可以反过来求出p(C|F1,&amp;hellip;,Fn)，这其实就是它基本原理了，以下是贝叶斯公式：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;p(类别1|特征1,特征2,特征3...) = p(特征1,特征2,特征3...|类别1) * p(类别1) / p(特征1,特征2,特征3...)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;解释： p(类别1|特征1,特征2,特征3&amp;hellip;) 表示在特征1、特征2、特征3&amp;hellip;发生的情况下，类别1发生的概率。 p(特征1,特征2,特征3&amp;hellip;|类别1) 表示在类别1发生的情况下，特征1、特征2、特征3&amp;hellip;发生的概率。 p(类别1) 表示类别1在所有类别中出的概率 p(特征1,特征2,特征3&amp;hellip;) 表示特征1,特征2,特征3&amp;hellip;在特征库中出现的概率 重复使用链式法则后，最终可以将公式转换为这样：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;p(类别1|特征1,特征2,特征3...) = p(特征1|类别1) * p(特征2|类别1) * p(特征3|类别1) ...&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这就是朴素贝叶斯公式了。&lt;/p&gt;&#xA;&lt;h2 id=&#34;实现邮件分类器&#34;&gt;实现邮件分类器&lt;a class=&#34;anchor&#34; href=&#34;#%e5%ae%9e%e7%8e%b0%e9%82%ae%e4%bb%b6%e5%88%86%e7%b1%bb%e5%99%a8&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;之前在研究Spark的MLLib时第一次接触到朴素贝叶斯算法（实际上已经是2016年的事了），并动手实现了一个简单的垃圾邮件识别程序，今天重新整理一下，我会在代码中一步一步讲明原理，先说一下实现邮件分类器的步骤：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;收集数据，准备一些正常的邮件和垃圾邮件，将它们放在两个不同的目录中&lt;/li&gt;&#xA;&lt;li&gt;特征提取，要让程序判断一封邮件是不是垃圾邮件，就需要告诉程序，什么是正常邮件，什么是垃圾邮件，这一步叫特征提取，也可以叫做训练集，提取的方法很简单，就是分别计算出正常邮件中与垃圾邮件中所有单词出现的数次及概率，这样我们就有了两个训练集&lt;/li&gt;&#xA;&lt;li&gt;识别邮件，这时需要写一个函数用来接收并识别给定的邮件，其原理也很简单，先将指定的邮件中的所有单词提取出来，然后计算这些单词在两个训练集出现的概率之积即可，这样就得到两个数字，从哪个训练集中计算出的数字大，那这封邮件就属于哪种类型。&lt;/li&gt;&#xA;&lt;li&gt;参数调整，当程序基本实现后，需要对各步骤中的参数进行调整，比如在特征提取时，我去掉了只出现一次或两次的单词，又比如，在识别新邮件时，如果这封邮件中出现了训练集中没有的单词时，应该给定它一个默认的概率值&#xA;下面给出一个实际的例子，在本例中我大概用了三千封历史邮件，分别放在了两个目录中，例子中的数据实在是想不起来在哪下载的，所以请同学们自行收集吧。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;首先是准备数据：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package com.algorithm.bayes&#xA; &#xA;import org.apache.spark.SparkConf&#xA;import org.apache.spark.SparkContext&#xA;import scala.io.Source&#xA;import java.io.File&#xA;import scala.sys.process.ProcessBuilder.Source&#xA;import scala.collection.mutable.ArrayBuffer&#xA;import scala.collection.mutable.HashMap&#xA; &#xA;/**&#xA; * 利用贝叶斯实现的邮件分类器，提交给Spark执行&#xA; */&#xA;object Classification {&#xA;   &#xA;  def main(args: Array[String]): Unit = {&#xA;     &#xA;    //初始化Spark&#xA;    val conf = new SparkConf().setAppName(this.getClass.getName)&#xA;    val sc = new SparkContext(conf)&#xA;     &#xA;    //该目录内均为正常邮件&#xA;    var easy = &amp;#34;/home/kxdmmr/src/ml-data/Email-data/easy_ham&amp;#34;&#xA;     &#xA;    //该目录内均为垃圾邮件&#xA;    var spam = &amp;#34;/home/kxdmmr/src/ml-data/Email-data/spam&amp;#34;&#xA;     &#xA;...&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后就是创建两个特征库，这个是重中之重：&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/algorithm/algorithm-quick-sort.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/algorithm/algorithm-quick-sort.html</guid>
      <description>&lt;h1 id=&#34;排序算法---快速排序&#34;&gt;排序算法 - 快速排序&lt;a class=&#34;anchor&#34; href=&#34;#%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95---%e5%bf%ab%e9%80%9f%e6%8e%92%e5%ba%8f&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;p&gt;作为排序之王的快速排序法，要理解它很容易，但实现起来又是另外一回事，主要是因为快速排序在实现上是很苛刻的，差之毫厘，谬以千里，如果不是专业研究算法的话，突然哪天要用到还真不一定写的出来，主要是平时用的很少。。&lt;/p&gt;&#xA;&lt;h2 id=&#34;基本原理&#34;&gt;基本原理&lt;a class=&#34;anchor&#34; href=&#34;#%e5%9f%ba%e6%9c%ac%e5%8e%9f%e7%90%86&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;给定一个数据集，先从中选出一个元素作为枢钮元，选取枢钮元有多种策略，它对算法的性能影响颇大，目前效果最好的应该是三数中值分割法，三数指的是数组中第一个元素，最后一个元素，和中间那个元素，然后从这三个元素中找出中位数并作为枢钮元&lt;/li&gt;&#xA;&lt;li&gt;将大于枢钮元的元素移动到枢钮元的左边，将小于枢钮元的元素移动到枢钮元的右边&lt;/li&gt;&#xA;&lt;li&gt;这时在枢钮元两边可以看作是两个子数据集，然后对这两个数据集分别进行快速排序，直到子数据集长度为1&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;时间复杂度&#34;&gt;时间复杂度&lt;a class=&#34;anchor&#34; href=&#34;#%e6%97%b6%e9%97%b4%e5%a4%8d%e6%9d%82%e5%ba%a6&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;平均时间为O(N log N)&lt;/li&gt;&#xA;&lt;li&gt;最坏情况为O(N^2)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;实例&#34;&gt;实例&lt;a class=&#34;anchor&#34; href=&#34;#%e5%ae%9e%e4%be%8b&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;static void swap(int [] a,int i,int j){&#xA;    int temp = a[i];&#xA;    a[i] = a[j];&#xA;    a[j] = temp;&#xA;}&#xA;static int partition(int a[],int start,int end){&#xA;    int m = start+(end-start)/2;&#xA;    if(a[start] &amp;gt; a[end])&#xA;        swap(a,start,end);&#xA;    if(a[start] &amp;gt; a[m])&#xA;        swap(a,start,m);&#xA;    if(a[m] &amp;lt; a[end])&#xA;        swap(a,m,end);&#xA; &#xA;    return a[end];&#xA;}&#xA;static void quickSort(int a[],int start,int end){&#xA; &#xA;    if(!(start&amp;lt;end))&#xA;        return;&#xA; &#xA;    int temp = partition(a,start,end);&#xA; &#xA;    int i = start, j = end;&#xA;    while(i &amp;lt; j){&#xA;        while(i &amp;lt; j &amp;amp;&amp;amp; a[i] &amp;lt;= temp)i++;&#xA;        a[j] = a[i];&#xA;        while(i &amp;lt; j &amp;amp;&amp;amp; a[j] &amp;gt;= temp)j--;&#xA;        a[i] = a[j];&#xA;    }&#xA;    a[j] = temp;&#xA; &#xA;    quickSort(a,start,j-1);&#xA;    quickSort(a,j+1,end);&#xA; &#xA;}&#xA; &#xA;public static void quickSort(int[] arr){&#xA;    quickSort(arr, 0, arr.length - 1);&#xA;}&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/architecture/cloud-plateform-loadbalancer.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/architecture/cloud-plateform-loadbalancer.html</guid>
      <description>&lt;h1 id=&#34;云平台---负载均衡器&#34;&gt;云平台 - 负载均衡器&lt;a class=&#34;anchor&#34; href=&#34;#%e4%ba%91%e5%b9%b3%e5%8f%b0---%e8%b4%9f%e8%bd%bd%e5%9d%87%e8%a1%a1%e5%99%a8&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;p&gt;负载均衡是云平台的重要组成部分，本文介绍开源项目&lt;a href=&#34;https://github.com/goodrain/rainbond&#34;&gt;好雨云帮平台&lt;/a&gt;(以下简称云帮)中负载均衡模块的具体实现，以及它出于什么样的考虑，希望能给有需要的同学带来一些参考和思路。&lt;/p&gt;&#xA;&lt;h2 id=&#34;为什么需要负载均衡&#34;&gt;为什么需要负载均衡&lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%ba%e4%bb%80%e4%b9%88%e9%9c%80%e8%a6%81%e8%b4%9f%e8%bd%bd%e5%9d%87%e8%a1%a1&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;首先，云帮平台的内部网络划分是支持多租户的，每个租户有一个私有的IP段，不同租户的网络是相互不可见的，当我们把一个容器化的应用部署到云帮后，云帮平台会为这个容器分配一个内部IP，用于同一租户中的不同应用在集群内部通信，而从集群外部是不能直接访问的。所以我们需要有一个集群入口控制器让用户能方便地访问这些应用。&lt;/p&gt;&#xA;&lt;p&gt;其次，云帮中部署的每个应用都可以有多个实例，假设我们为一个WEB应用部署了三个实例，然后每个实例分担一部分流量，这时我每就需要在它们前面加一个负载均衡器来分发流量给三个实例。&lt;/p&gt;&#xA;&lt;p&gt;除了上述的基本功能以外，我们的负载均衡器还必须支持更多的功能，比如：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;入口控制器能够根据数据包信息（如协议、端口号、主机名等）将请求转发给指定的应用。&lt;/li&gt;&#xA;&lt;li&gt;实时地发现集群中应用的变化（如添加自定义域名、添加证书、添加端口等）并动态更自身的转发规则。&lt;/li&gt;&#xA;&lt;li&gt;要同时支持HTTP、TLS、TCP和UDP协议，因为有时不只WEB应用需要向外提供服条，像RPC、MySQL等也需要对外开放。&lt;/li&gt;&#xA;&lt;li&gt;最后一点也很重要，那就是支持高可用。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;综上所述，我们需要一个同时支持L4、L7的负载均衡器集群，还必须能够自动发现集群中的应用变化以更新自己的转发规则。&lt;/p&gt;&#xA;&lt;h2 id=&#34;云帮中的负载均衡&#34;&gt;云帮中的负载均衡&lt;a class=&#34;anchor&#34; href=&#34;#%e4%ba%91%e5%b8%ae%e4%b8%ad%e7%9a%84%e8%b4%9f%e8%bd%bd%e5%9d%87%e8%a1%a1&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;整体架构&#34;&gt;整体架构&lt;a class=&#34;anchor&#34; href=&#34;#%e6%95%b4%e4%bd%93%e6%9e%b6%e6%9e%84&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;p&gt;以下是云帮负载均衡模块的架构示意图：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;cloud-plateform-loadbalancer/loadbalancer-architecture.png&#34; alt=&#34;loadbalancer-architecture&#34; /&gt;&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;code&gt;web&lt;/code&gt;：表示云帮中的一个应用，并且有三个实例。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;api-server&lt;/code&gt;：表示kubeneters的kube-apiserver组件。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;entrance&lt;/code&gt;：表示云帮的负载均衡器通用接口，支持多种负载均衡器插件。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;entrance实现&#34;&gt;Entrance实现&lt;a class=&#34;anchor&#34; href=&#34;#entrance%e5%ae%9e%e7%8e%b0&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;p&gt;云帮中的负载均衡是面向应用的，不同的应用可以使用不同的负载均衡，所以我们设计了Entrance组件，它可以集成多种负载均衡插件，OpenResty就是其中之一，这意味着云帮不仅支持OpenResty，还可以方支持其它负载均衡插件。&lt;/p&gt;&#xA;&lt;p&gt;它的主要工作是从kube-apiserver中通过Restful API监听应用容器的IP、端口，service和endpoint等的资源变化，然后把这些资源抽象为通用的负载均衡资源并缓存在ETCD中，这些通用资源有：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;Pool&lt;/code&gt;：表示一个负载均衡池，其中包括多个节点，对应上图中的三个WEB实例。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;Node&lt;/code&gt;：表示Pool中的一个节点，对应上图中的其中一个WEB实例。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;Domain&lt;/code&gt;：表示一个域名，负载均衡器可以识别一个数据包中的域名信息然后将数据转发给对应的Pool。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;VirtualService&lt;/code&gt;：表示监听了某个端口的虚拟主机，还指明了端口的协议名称，主要用来处理L4入口控制和负载均衡。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;Rule&lt;/code&gt;：表示一条转发规则，用来描述域名跟Pool的对应关系，还指明了端口的协议名称与证书信息，主要用来处理L7入口控制和负载均衡。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;当有资源发生变化时，Entrance会将通用资源转化为相应插件的资源并调用该插件的Restful API。&lt;/p&gt;&#xA;&lt;p&gt;从上图中可以看到，有两个Entrance和两个OpenResty实例，它们的关系是：每个Entrance中持有所有OpenResty的地址，当有信息需要更新时，Entrance会将信息更新到所有的OpenResty。那两个Entrance之间怎么协调呢？这里我们利用ETCD本身的特性做了分布式锁，保证只有一个Entrance有权限向OpenResty更新信息，这样就实现了高可用。&lt;/p&gt;&#xA;&lt;h3 id=&#34;openresty件插&#34;&gt;OpenResty件插&lt;a class=&#34;anchor&#34; href=&#34;#openresty%e4%bb%b6%e6%8f%92&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;p&gt;OpenResty是一个可以用Lua脚本来处理请求和业条逻辑的WEB应用，并且内置了众多Lua相关的指定和函数供开发者使用，很合适开发Restful API服务器，我们将OpenResty作为Entrance的插件之一原因如下：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;它是基于Nginx开发，所以稳定性和性能方面不用太担心。&lt;/li&gt;&#xA;&lt;li&gt;比较接近我们的目标，OpenResty已经帮我们把Lua模块编译进去，我们可以很方便地用Lua脚本丰富负载均衡器的功能，可以让我们省去一些工作量。&lt;/li&gt;&#xA;&lt;li&gt;同时支持L7和L4的负载均衡。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;我们在OpenResty端嵌入了一个Rest API服务器，这些API是用Lua写的，前面说过OpenResty集成了Lua脚本功能，我们可以直接用Lua来处理请求，下面是Nginx配置文件的其中一部分：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# custom api of upstream and server&#xA;server {&#xA;    listen 10002;&#xA;&#xA;    location ~ /v1/upstreams/([-_0-9a-zA-Z.@]+) {&#xA;        set $src_name $1;&#xA;        content_by_lua_file lua/upstream.lua;&#xA;    }&#xA;&#xA;    location ~ /v1/servers/([-_0-9a-zA-Z.@]+) {&#xA;        set $src_name $1;&#xA;        content_by_lua_file lua/server.lua;&#xA;    }&#xA;&#xA;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当我们调用下面的API时：&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/atlas-case/11111.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/atlas-case/11111.html</guid>
      <description>&lt;h1 id=&#34;11111&#34;&gt;11111&lt;a class=&#34;anchor&#34; href=&#34;#11111&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;患者信息&#34;&gt;患者信息&lt;a class=&#34;anchor&#34; href=&#34;#%e6%82%a3%e8%80%85%e4%bf%a1%e6%81%af&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;记录日期：2024.11.26&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;出生年份：1992&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;性别：男&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;省份：四川&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;症状：无症状&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;诊断日期：2024.06.04&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;诊断：寰枢椎脱位、颅底凹陷、小脑下疝、脊髓空洞&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;影像：&lt;/p&gt;&#xA;  &lt;img src=&#34;img/11111/20240604_01.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11111/20240605_01.jpg&#34; height=&#34;100&#34; /&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;手术&#34;&gt;手术&lt;a class=&#34;anchor&#34; href=&#34;#%e6%89%8b%e6%9c%af&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;日期：2024.06&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;医院：宜宾二医院&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;主刀：黄思庆徒弟&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;费用：自费1.6w&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;术后状况：&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;术后影像：&lt;/p&gt;&#xA;  &lt;img src=&#34;img/11111/20240623_01.jpg&#34; height=&#34;100&#34; /&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;康复记录：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;10多天下床，术后10多天感觉症状还在。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;2024.10.30，在宜宾二医院复查，螺钉脱离。类似喝醉的头晕，走路不稳，左手力量和灵活度下降，影像如下：&lt;/p&gt;&#xA;  &lt;img src=&#34;img/11111/20241030_01.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11111/20241030_02.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11111/20241030_03.jpg&#34; height=&#34;100&#34; /&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;二次手术&#34;&gt;二次手术&lt;a class=&#34;anchor&#34; href=&#34;#%e4%ba%8c%e6%ac%a1%e6%89%8b%e6%9c%af&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;日期：2024.11.23&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;医院：湘雅三&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;主刀：李劲松&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;费用：自费1.6w&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;术后影像：&lt;/p&gt;&#xA;  &lt;img src=&#34;img/11111/202411_01.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11111/202411_02.jpg&#34; height=&#34;100&#34; /&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;康复记录：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;第二天下床，术后15天，头不晕了，走路稳了，左手力量和灵活度稍有好转。&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/atlas-case/11112.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/atlas-case/11112.html</guid>
      <description>&lt;h1 id=&#34;11112&#34;&gt;11112&lt;a class=&#34;anchor&#34; href=&#34;#11112&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;患者信息&#34;&gt;患者信息&lt;a class=&#34;anchor&#34; href=&#34;#%e6%82%a3%e8%80%85%e4%bf%a1%e6%81%af&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;记录日期：2024.12.07&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;出生年份：1993&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;性别：女&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;省份：新疆&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;症状：腿不舒服，影响走路了，下楼腿抖，跑步跑不起来，高抬腿抬不起来&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;诊断日期：2024.07.31&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;诊断：颅底凹陷&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;影像：&lt;/p&gt;&#xA;  &lt;img src=&#34;img/11112/694a4cd3f52fed9c4a72c6fde24bc0cb.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11112/bd035160e9a5f79656d4c0f458a432f3.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11112/0650e9d737347a95e63386c5885c96c7.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11112/6391393064cbd2568959c9a09a578c59.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11112/91aa900d02cf217ab4f72540c0cb8202.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11112/dbf2897f327c2636c003917c3e154868.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11112/e189edc8b0649700c4a97ef2d081b262.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11112/930eea28593db43d5a3486980b53b007.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11112/84ed10fa93e7f5680c2ce8c145656709.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11112/9006bf99684b661cf4684da6efba2083.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11112/e0caba09141010db8513ca9bb79db843.jpg&#34; height=&#34;100&#34; /&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;手术&#34;&gt;手术&lt;a class=&#34;anchor&#34; href=&#34;#%e6%89%8b%e6%9c%af&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;日期：2024.08.30&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;医院：新疆维吾尔自治区人民医院&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;主刀：范涛&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;费用：&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;术后状况：术后颈后有积液&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;术后影像：&lt;/p&gt;&#xA;  &lt;img src=&#34;img/11112/a7c3f86c72076cfda11166b68b158286.jpg&#34; height=&#34;100&#34; /&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;康复记录：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;2024.10.06，积液范围略小。&lt;/p&gt;&#xA;  &lt;img src=&#34;img/11112/c870964110675bc85d2d93ca31e25a2c.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11112/ac9272181bc1b6b82a3a9e05e68a7704.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11112/305e4b661df373c548d0d9876c893cb9.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11112/c53a6bfddacf7791ac23233b0e2c67a0.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11112/a56a5b62b8602efa1c09232c70bec07d.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11112/470ec7a155717e719c22f9a43c980537.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11112/7dff5c567aa641538826a1ea4bec088a.jpg&#34; height=&#34;100&#34; /&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;2024.12.12，术前症状都没了，术后多了一个症状，右胳膊发凉，现在偶尔还会。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/atlas-case/11113.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/atlas-case/11113.html</guid>
      <description>&lt;h1 id=&#34;11113&#34;&gt;11113&lt;a class=&#34;anchor&#34; href=&#34;#11113&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;患者信息&#34;&gt;患者信息&lt;a class=&#34;anchor&#34; href=&#34;#%e6%82%a3%e8%80%85%e4%bf%a1%e6%81%af&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;记录日期：2024.12.09&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;出生年份：&amp;lt;1980&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;性别：女&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;省份：&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;症状：30岁时摔了一跤，当时短暂瘫痪，后面又慢慢恢复。多年后出现手麻脚麻&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;诊断日期：2023.11&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;诊断：30岁时齿状突骨折&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;影像：&lt;/p&gt;&#xA;  &lt;img src=&#34;img/11113/e1537e5c866c31763cc32f22e60f7771.jpg&#34; height=&#34;100&#34; /&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;手术&#34;&gt;手术&lt;a class=&#34;anchor&#34; href=&#34;#%e6%89%8b%e6%9c%af&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;日期：2023.11.16&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;医院：北三医院&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;主刀：王超&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;费用：&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;术后状况：&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;术后影像：&lt;/p&gt;&#xA;  &lt;img src=&#34;img/11113/a799131527369d7073d30ddb89a391ff.jpg&#34; height=&#34;100&#34; /&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;康复记录：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;2024.12.09，术后感觉良好，手麻脚麻症状已经没有了。&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/atlas-case/11114.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/atlas-case/11114.html</guid>
      <description>&lt;h1 id=&#34;11114&#34;&gt;11114&lt;a class=&#34;anchor&#34; href=&#34;#11114&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;患者信息&#34;&gt;患者信息&lt;a class=&#34;anchor&#34; href=&#34;#%e6%82%a3%e8%80%85%e4%bf%a1%e6%81%af&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;记录日期：2024.12.08&lt;/li&gt;&#xA;&lt;li&gt;出生年份：&lt;/li&gt;&#xA;&lt;li&gt;性别：女&lt;/li&gt;&#xA;&lt;li&gt;省份：&lt;/li&gt;&#xA;&lt;li&gt;症状：&lt;/li&gt;&#xA;&lt;li&gt;诊断日期：&lt;/li&gt;&#xA;&lt;li&gt;诊断：寰枢椎脱位&lt;/li&gt;&#xA;&lt;li&gt;影像：&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;手术&#34;&gt;手术&lt;a class=&#34;anchor&#34; href=&#34;#%e6%89%8b%e6%9c%af&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;日期：2024.01&lt;/li&gt;&#xA;&lt;li&gt;医院：北三医院&lt;/li&gt;&#xA;&lt;li&gt;主刀：王超&lt;/li&gt;&#xA;&lt;li&gt;费用：&lt;/li&gt;&#xA;&lt;li&gt;术后状况：&lt;/li&gt;&#xA;&lt;li&gt;术后影像：&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;康复记录：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;2024.11，去人民医院复查。&lt;/p&gt;&#xA;  &lt;img src=&#34;img/11114/8abc88a7c6cb23fb3273d644ec549ce4.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11114/839165e2df254877dc175676d6f54cd7.jpg&#34; height=&#34;100&#34; /&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/atlas-case/11115.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/atlas-case/11115.html</guid>
      <description>&lt;h1 id=&#34;11115&#34;&gt;11115&lt;a class=&#34;anchor&#34; href=&#34;#11115&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;患者信息&#34;&gt;患者信息&lt;a class=&#34;anchor&#34; href=&#34;#%e6%82%a3%e8%80%85%e4%bf%a1%e6%81%af&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;记录日期：2024.12.11&lt;/li&gt;&#xA;&lt;li&gt;出生年份：&lt;/li&gt;&#xA;&lt;li&gt;性别：女&lt;/li&gt;&#xA;&lt;li&gt;省份：&lt;/li&gt;&#xA;&lt;li&gt;症状：&lt;/li&gt;&#xA;&lt;li&gt;诊断日期：&lt;/li&gt;&#xA;&lt;li&gt;诊断：寰枢椎脱位&lt;/li&gt;&#xA;&lt;li&gt;影像：&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;手术&#34;&gt;手术&lt;a class=&#34;anchor&#34; href=&#34;#%e6%89%8b%e6%9c%af&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;日期：2024.06&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;医院：上海某医院&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;主刀：不详&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;费用：&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;术后状况：&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;术后影像：&lt;/p&gt;&#xA;  &lt;img src=&#34;img/11115/41ea6c01c60f9fbb3c57dca3321cd990.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11115/d0bd99a9bd7668751bf6d51262320002.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11115/81bd5c802b591902663bdefb8da76190.jpg&#34; height=&#34;100&#34; /&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;康复记录：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;2024.10，复查，恢复良好。&lt;/p&gt;&#xA;  &lt;img src=&#34;img/11115/51d5b584478cad280932a39887c5e1b8.jpg&#34; height=&#34;100&#34; /&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/atlas-case/11116.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/atlas-case/11116.html</guid>
      <description>&lt;h1 id=&#34;11116&#34;&gt;11116&lt;a class=&#34;anchor&#34; href=&#34;#11116&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;患者信息&#34;&gt;患者信息&lt;a class=&#34;anchor&#34; href=&#34;#%e6%82%a3%e8%80%85%e4%bf%a1%e6%81%af&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;记录日期：2024.12.11&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;出生年份：&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;性别：&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;省份：&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;症状：&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;诊断日期：&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;诊断：寰枢椎脱位&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;影像：&lt;/p&gt;&#xA;  &lt;img src=&#34;img/11116/微信图片_20241212142345_168.jpg&#34; height=&#34;100&#34; /&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;手术&#34;&gt;手术&lt;a class=&#34;anchor&#34; href=&#34;#%e6%89%8b%e6%9c%af&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;日期：2024.11.03&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;医院：&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;主刀：李维新&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;费用：&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;术后状况：&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;术后影像：&lt;/p&gt;&#xA;  &lt;img src=&#34;img/11116/微信图片_20241212142345_169.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11116/微信图片_20241212142345_169.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11116/微信图片_20241212142345_170.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11116/微信图片_20241212142345_171.jpg&#34; height=&#34;100&#34; /&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;康复记录：&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/atlas-case/11117.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/atlas-case/11117.html</guid>
      <description>&lt;h1 id=&#34;11117&#34;&gt;11117&lt;a class=&#34;anchor&#34; href=&#34;#11117&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;患者信息&#34;&gt;患者信息&lt;a class=&#34;anchor&#34; href=&#34;#%e6%82%a3%e8%80%85%e4%bf%a1%e6%81%af&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;记录日期：2024.12.11&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;出生年份：&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;性别：男&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;省份：&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;症状：&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;诊断日期：&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;诊断：寰枢椎脱位&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;影像：&lt;/p&gt;&#xA;  &lt;img src=&#34;img/11117/微信图片_20241211205510_153.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11117/微信图片_20241211205510_154.jpg&#34; height=&#34;100&#34; /&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;手术&#34;&gt;手术&lt;a class=&#34;anchor&#34; href=&#34;#%e6%89%8b%e6%9c%af&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;日期：2023.10.26&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;医院：&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;主刀：王建华&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;费用：&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;术后状况：&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;术后影像：&lt;/p&gt;&#xA;  &lt;img src=&#34;img/11117/微信图片_20241211192520_28.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11117/微信图片_20241211192520_29.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11117/微信图片_20241211192520_30.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11117/微信图片_20241211192520_31.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11117/微信图片_20241211192520_32.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11117/微信图片_20241211192520_33.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11117/微信图片_20241211192520_34.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11117/微信图片_20241211192520_35.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11117/微信图片_20241211192520_36.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11117/微信图片_20241211192520_37.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11117/微信图片_20241211192520_38.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11117/微信图片_20241211192520_39.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11117/微信图片_20241211192520_40.jpg&#34; height=&#34;100&#34; /&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;康复记录：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;2024.04，半年复查。&lt;/p&gt;&#xA;  &lt;img src=&#34;img/11117/微信图片_20241211192032_15.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11117/微信图片_20241211192032_16.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11117/微信图片_20241211192032_17.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11117/微信图片_20241211192032_18.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11117/微信图片_20241211192032_19.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11117/微信图片_20241211192032_20.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11117/微信图片_20241211192032_21.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11117/微信图片_20241211192032_22.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11117/微信图片_20241211192032_23.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11117/微信图片_20241211192032_24.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11117/微信图片_20241211192032_25.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11117/微信图片_20241211192032_26.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11117/微信图片_20241211192032_27.jpg&#34; height=&#34;100&#34; /&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/atlas-case/11118.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/atlas-case/11118.html</guid>
      <description>&lt;h1 id=&#34;11118&#34;&gt;11118&lt;a class=&#34;anchor&#34; href=&#34;#11118&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;患者信息&#34;&gt;患者信息&lt;a class=&#34;anchor&#34; href=&#34;#%e6%82%a3%e8%80%85%e4%bf%a1%e6%81%af&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;记录日期：2024.12.12&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;出生年份：&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;性别：女&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;省份：&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;症状：左手冷的时候，会容易麻木&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;诊断日期：&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;诊断：寰枢椎脱位，颅底凹陷&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;影像：&lt;/p&gt;&#xA;  &lt;img src=&#34;img/11118/微信图片_20241212164451_5.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11118/微信图片_20241212164451_13.jpg&#34; height=&#34;100&#34; /&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;手术&#34;&gt;手术&lt;a class=&#34;anchor&#34; href=&#34;#%e6%89%8b%e6%9c%af&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;日期：2023.09.01&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;医院：&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;主刀：王超&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;费用：&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;术后状况：&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;术后影像：&lt;/p&gt;&#xA;  &lt;img src=&#34;img/11118/微信图片_20241212164451_6.jpg&#34; height=&#34;100&#34; /&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/atlas-case/11119.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/atlas-case/11119.html</guid>
      <description>&lt;h1 id=&#34;11119&#34;&gt;11119&lt;a class=&#34;anchor&#34; href=&#34;#11119&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;患者信息&#34;&gt;患者信息&lt;a class=&#34;anchor&#34; href=&#34;#%e6%82%a3%e8%80%85%e4%bf%a1%e6%81%af&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;记录日期：2024.12.13&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;出生年份：1970&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;性别：女&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;省份：&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;症状：颈重，肩重，肩甲骨经常火辣辣的，头前伸寰枢椎那会嘎嘎响&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;诊断日期：&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;诊断：寰枢椎脱位，颅底凹陷&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;影像：&lt;/p&gt;&#xA;  &lt;img src=&#34;img/11119/微信图片_20241214093127_29.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11119/微信图片_20241214093127_30.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11119/微信图片_20241214093127_31.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11119/微信图片_20241214093127_32.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11119/微信图片_20241214093127_33.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11119/微信图片_20241214093127_34.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11119/微信图片_20241214100837_15.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11119/微信图片_20241214100837_16.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11119/微信图片_20241214100837_17.jpg&#34; height=&#34;100&#34; /&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;手术&#34;&gt;手术&lt;a class=&#34;anchor&#34; href=&#34;#%e6%89%8b%e6%9c%af&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;日期：2023.09&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;医院：北三医院&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;主刀：王超&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;费用：&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;术后状况：偶尔会肩甲骨酸，坐下就不酸&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;术后影像：&lt;/p&gt;&#xA;  &lt;img src=&#34;img/11119/微信图片_20241214093405_36.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11119/微信图片_20241214093405_37.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11119/微信图片_20241214093405_38.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11119/微信图片_20241214093405_39.jpg&#34; height=&#34;100&#34; /&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;康复记录：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;2024.02.27，复查，对位良好，偶尔会肩甲骨酸，坐下就不酸。&lt;/p&gt;&#xA;  &lt;img src=&#34;img/11119/微信图片_20241214102027_42.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11119/微信图片_20241214102027_43.jpg&#34; height=&#34;100&#34; /&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;2024.10.20，复查，对位良好，偶尔会肩甲骨酸，坐下就不酸。&lt;/p&gt;&#xA;  &lt;img src=&#34;img/11119/微信图片_20241214094122_47.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11119/微信图片_20241214094122_48.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11119/微信图片_20241214094122_49.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11119/微信图片_20241214094122_50.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11119/微信图片_20241214094447_66.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11119/微信图片_20241214094447_67.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11119/微信图片_20241214094447_68.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11119/微信图片_20241214100312_75.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11119/微信图片_20241214100312_76.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11119/微信图片_20241214100312_77.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11119/微信图片_20241214100312_78.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11119/微信图片_20241214100312_79.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11119/微信图片_20241214100312_80.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11119/微信图片_20241214100312_81.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11119/微信图片_20241214100312_82.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11119/微信图片_20241214100312_83.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11119/微信图片_20241214100312_84.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11119/微信图片_20241214100312_85.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11119/微信图片_20241214100312_86.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11119/微信图片_20241214100312_87.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11119/微信图片_20241214100312_88.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11119/微信图片_20241214100312_89.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11119/微信图片_20241214100312_90.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11119/微信图片_20241214100312_91.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11119/微信图片_20241214100312_92.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11119/微信图片_20241214100312_93.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11119/微信图片_20241214100312_94.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11119/微信图片_20241214100312_95.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11119/微信图片_20241214100312_96.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11119/微信图片_20241214100312_97.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11119/微信图片_20241214100312_98.jpg&#34; height=&#34;100&#34; /&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/atlas-case/11120.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/atlas-case/11120.html</guid>
      <description>&lt;h1 id=&#34;11120&#34;&gt;11120&lt;a class=&#34;anchor&#34; href=&#34;#11120&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;患者信息&#34;&gt;患者信息&lt;a class=&#34;anchor&#34; href=&#34;#%e6%82%a3%e8%80%85%e4%bf%a1%e6%81%af&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;记录日期：2024.12.15&lt;/li&gt;&#xA;&lt;li&gt;出生年份：1961&lt;/li&gt;&#xA;&lt;li&gt;性别：男&lt;/li&gt;&#xA;&lt;li&gt;省份：&lt;/li&gt;&#xA;&lt;li&gt;症状：&lt;/li&gt;&#xA;&lt;li&gt;诊断日期：&lt;/li&gt;&#xA;&lt;li&gt;诊断：寰枢椎脱位，颅底凹陷&lt;/li&gt;&#xA;&lt;li&gt;影像：&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;手术&#34;&gt;手术&lt;a class=&#34;anchor&#34; href=&#34;#%e6%89%8b%e6%9c%af&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;日期：2013&lt;/li&gt;&#xA;&lt;li&gt;医院：上海长征医院&lt;/li&gt;&#xA;&lt;li&gt;主刀：史建刚&lt;/li&gt;&#xA;&lt;li&gt;费用：&lt;/li&gt;&#xA;&lt;li&gt;术后状况：&lt;/li&gt;&#xA;&lt;li&gt;术后影像：&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;二次手术&#34;&gt;二次手术&lt;a class=&#34;anchor&#34; href=&#34;#%e4%ba%8c%e6%ac%a1%e6%89%8b%e6%9c%af&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;日期：2021&lt;/li&gt;&#xA;&lt;li&gt;医院：上海长征医院&lt;/li&gt;&#xA;&lt;li&gt;主刀：史建刚&lt;/li&gt;&#xA;&lt;li&gt;费用：&lt;/li&gt;&#xA;&lt;li&gt;术后状况：&lt;/li&gt;&#xA;&lt;li&gt;术后影像：&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;康复记录：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;2023.09.01，复查，压迫脊髓。&lt;/p&gt;&#xA;  &lt;img src=&#34;img/11120/20230901/微信图片_20241215125137_36.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11120/20230901/微信图片_20241215125137_37.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11120/20230901/微信图片_20241215125137_38.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11120/20230901/微信图片_20241215125137_39.jpg&#34; height=&#34;100&#34; /&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;三次手术&#34;&gt;三次手术&lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%89%e6%ac%a1%e6%89%8b%e6%9c%af&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;日期：2023.11&lt;/li&gt;&#xA;&lt;li&gt;医院：北三医院&lt;/li&gt;&#xA;&lt;li&gt;主刀：王超&lt;/li&gt;&#xA;&lt;li&gt;费用：&lt;/li&gt;&#xA;&lt;li&gt;术后状况：&lt;/li&gt;&#xA;&lt;li&gt;术后影像：&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;康复记录：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;2024.03.09，复查，对位良好，但术前症状难以恢复。&lt;/p&gt;&#xA;  &lt;img src=&#34;img/11120/20240309/微信图片_20241215125054_18.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11120/20240309/微信图片_20241215125054_19.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11120/20240309/微信图片_20241215125054_20.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11120/20240309/微信图片_20241215125054_21.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11120/20240309/微信图片_20241215125054_22.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11120/20240309/微信图片_20241215125054_23.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11120/20240309/微信图片_20241215125054_24.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11120/20240309/微信图片_20241215125054_25.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11120/20240309/微信图片_20241215125054_26.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11120/20240309/微信图片_20241215125054_27.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11120/20240309/微信图片_20241215125054_28.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11120/20240309/微信图片_20241215125054_29.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11120/20240309/微信图片_20241215125054_30.jpg&#34; height=&#34;100&#34; /&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/atlas-case/11121.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/atlas-case/11121.html</guid>
      <description>&lt;h1 id=&#34;11121&#34;&gt;11121&lt;a class=&#34;anchor&#34; href=&#34;#11121&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;患者信息&#34;&gt;患者信息&lt;a class=&#34;anchor&#34; href=&#34;#%e6%82%a3%e8%80%85%e4%bf%a1%e6%81%af&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;记录日期：2024.12.15&lt;/li&gt;&#xA;&lt;li&gt;出生年份：1979&lt;/li&gt;&#xA;&lt;li&gt;性别：女&lt;/li&gt;&#xA;&lt;li&gt;省份：&lt;/li&gt;&#xA;&lt;li&gt;症状：&lt;/li&gt;&#xA;&lt;li&gt;诊断日期：&lt;/li&gt;&#xA;&lt;li&gt;诊断：寰枢椎脱位&lt;/li&gt;&#xA;&lt;li&gt;影像：&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;手术&#34;&gt;手术&lt;a class=&#34;anchor&#34; href=&#34;#%e6%89%8b%e6%9c%af&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;日期：2023.10&lt;/li&gt;&#xA;&lt;li&gt;医院：北京301医院&lt;/li&gt;&#xA;&lt;li&gt;主刀：彭宝淦&lt;/li&gt;&#xA;&lt;li&gt;费用：&lt;/li&gt;&#xA;&lt;li&gt;术后状况：手术方式是用肽缆把寰枢椎缠上，手术手脚麻木，医生让观察一段时间，一个月后手脚无力，背部僵硬。&lt;/li&gt;&#xA;&lt;li&gt;术后影像：&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;康复记录：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;2024.02.18，复查，症状还在。&lt;/p&gt;&#xA;  &lt;img src=&#34;img/11121/20240218/微信图片_20241215154819_20.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11121/20240218/微信图片_20241215154819_21.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11121/20240218/微信图片_20241215154819_22.jpg&#34; height=&#34;100&#34; /&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;2024.05，复查，症状还在。&lt;/p&gt;&#xA;  &lt;img src=&#34;img/11121/202405/微信图片_20241215154819_15.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11121/202405/微信图片_20241215154819_16.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11121/202405/微信图片_20241215154819_17.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11121/202405/微信图片_20241215154819_18.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11121/202405/微信图片_20241215154819_19.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11121/202405/微信图片_20241215154819_23.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11121/202405/微信图片_20241215154819_24.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11121/202405/微信图片_20241215154819_25.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11121/202405/微信图片_20241215154819_26.jpg&#34; height=&#34;100&#34; /&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;二次手术&#34;&gt;二次手术&lt;a class=&#34;anchor&#34; href=&#34;#%e4%ba%8c%e6%ac%a1%e6%89%8b%e6%9c%af&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;日期：2024.06.14&lt;/li&gt;&#xA;&lt;li&gt;医院：北三医院&lt;/li&gt;&#xA;&lt;li&gt;主刀：王超&lt;/li&gt;&#xA;&lt;li&gt;费用：&lt;/li&gt;&#xA;&lt;li&gt;术后状况：手脚无力的症状消失，低头时间久了脖子手术的地方酸痛。&lt;/li&gt;&#xA;&lt;li&gt;术后影像：&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;康复记录：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;2024.11.07，复查，对位良好。&lt;/p&gt;&#xA;  &lt;img src=&#34;img/11121/20241107/微信图片_20241215155150_30.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11121/20241107/微信图片_20241215155150_31.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11121/20241107/微信图片_20241215155150_32.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11121/20241107/微信图片_20241215155150_33.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11121/20241107/微信图片_20241215155150_34.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11121/20241107/微信图片_20241215155150_35.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11121/20241107/微信图片_20241215155150_36.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11121/20241107/微信图片_20241215155150_37.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11121/20241107/微信图片_20241215155150_38.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11121/20241107/微信图片_20241215155150_39.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11121/20241107/微信图片_20241215155150_30.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11121/20241107/微信图片_20241215155150_41.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11121/20241107/微信图片_20241215155150_42.jpg&#34; height=&#34;100&#34; /&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/atlas-case/11122.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/atlas-case/11122.html</guid>
      <description>&lt;h1 id=&#34;11122&#34;&gt;11122&lt;a class=&#34;anchor&#34; href=&#34;#11122&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;患者信息&#34;&gt;患者信息&lt;a class=&#34;anchor&#34; href=&#34;#%e6%82%a3%e8%80%85%e4%bf%a1%e6%81%af&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;记录日期：2024.12.15&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;出生年份：1993&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;性别：男&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;省份：山西&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;症状：自2020年开始，每天到下午5点以后头晕，主要发生在走路转身的时候，会有一瞬间头晕，类似恍惚的感觉，下次转身又会晕一下。刚开始每天头晕一两次，随后头晕频率慢慢变高，到2023年，上午也会出现头晕症状。还有就算握拳时有无力感。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;诊断日期：2024.08&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;诊断：寰枢椎脱位、颅底凹陷&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;影像：&lt;/p&gt;&#xA;  &lt;img src=&#34;img/11122/术前/IMG_3529.JPG&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11122/术前/IMG_3530.JPG&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11122/术前/IMG_3531.JPG&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11122/术前/IMG_3535.JPG&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11122/术前/IMG_3536.JPG&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11122/术前/IMG_3537.JPG&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11122/术前/IMG_3539.JPG&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11122/术前/IMG_3540.JPG&#34; height=&#34;100&#34; /&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;手术&#34;&gt;手术&lt;a class=&#34;anchor&#34; href=&#34;#%e6%89%8b%e6%9c%af&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;日期：2024.09.19&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;医院：宣武医院&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;主刀：段宛如、陈赞&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;费用：自费1.6w&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;术后状况：头晕症状还在，但握拳有劲了，第二天看ct片子，寰齿间隙还是大于3mm，颅底凹陷没有任何改善。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;术后影像：&lt;/p&gt;&#xA;  &lt;img src=&#34;img/11122/术后/IMG_3541.JPG&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11122/术后/IMG_3542.JPG&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11122/术后/IMG_3543.JPG&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11122/术后/IMG_3544.JPG&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11122/术后/IMG_3545.JPG&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11122/术后/IMG_3546.JPG&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11122/术后/IMG_3547.JPG&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11122/术后/IMG_3548.JPG&#34; height=&#34;100&#34; /&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;康复记录：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;术后颈后愈合良好，髂骨刀口拆线时有血水流出，然后本地医生一直给引流，两个月后北京化验积液，发现没有感染，遂取消引流，伤口3天愈合，愈合前一直头晕，比术前频繁且明显，愈合后头晕减轻。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;2024.12.04，头晕症状加重，双手开始出现无力感。并出现新的症状，胸闷、心慌、气短，休息时身体总想抽搐，听到大点的声音也会抽动一下，听到大的声音脑袋里面会嗡一下，像惊厥一样。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;2024.12.13，去北京拍片，当天走路有点多，感觉脑袋里面疼。影像报告脱位和颅底凹陷都还在，影像如下：&lt;/p&gt;&#xA;  &lt;img src=&#34;img/11122/术后三月/IMG_3564.JPG&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11122/术后三月/IMG_3565.JPG&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11122/术后三月/IMG_3566.JPG&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11122/术后三月/IMG_3567.JPG&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11122/术后三月/IMG_3569.JPG&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11122/术后三月/IMG_3570.JPG&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11122/术后三月/IMG_3571.JPG&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11122/术后三月/IMG_3577.JPG&#34; height=&#34;100&#34; /&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/atlas-case/11123.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/atlas-case/11123.html</guid>
      <description>&lt;h1 id=&#34;11123&#34;&gt;11123&lt;a class=&#34;anchor&#34; href=&#34;#11123&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;患者信息&#34;&gt;患者信息&lt;a class=&#34;anchor&#34; href=&#34;#%e6%82%a3%e8%80%85%e4%bf%a1%e6%81%af&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;记录日期：2025.01.18&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;出生年份：&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;性别：&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;省份：&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;症状：腿无力，开车踩离合时腿打颤，不由自主&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;诊断日期：&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;诊断：寰枢椎脱位、颅底凹陷&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;影像：&lt;/p&gt;&#xA;  &lt;img src=&#34;img/11123/微信图片_20250118095701_9349.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11123/微信图片_20250118100337_24.jpg&#34; height=&#34;100&#34; /&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;手术&#34;&gt;手术&lt;a class=&#34;anchor&#34; href=&#34;#%e6%89%8b%e6%9c%af&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;日期：2024.11.02&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;医院：兰州某医院&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;主刀：王景&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;费用：&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;术后状况：属于难复位型的，采取后路松解，且用了融合器&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;术后影像：&lt;/p&gt;&#xA;  &lt;img src=&#34;img/11123/微信图片_20250118100456_17.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11123/微信图片_20250118095701_9347.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11123/微信图片_20250118095701_9354.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11123/微信图片_20250118100353_20.jpg&#34; height=&#34;100&#34; /&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;康复记录：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;术后两个月，腿有力了&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/atlas-case/11124.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/atlas-case/11124.html</guid>
      <description>&lt;h1 id=&#34;11124&#34;&gt;11124&lt;a class=&#34;anchor&#34; href=&#34;#11124&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;患者信息&#34;&gt;患者信息&lt;a class=&#34;anchor&#34; href=&#34;#%e6%82%a3%e8%80%85%e4%bf%a1%e6%81%af&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;记录日期：2025.01.18&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;出生年份：&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;性别：男&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;省份：河北&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;症状：&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;诊断日期：&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;诊断：寰枢椎脱位&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;影像：&lt;/p&gt;&#xA;  &lt;img src=&#34;img/11124/微信图片_20250418163524_119.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11124/微信图片_20250418163525_120.jpg&#34; height=&#34;100&#34; /&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;手术&#34;&gt;手术&lt;a class=&#34;anchor&#34; href=&#34;#%e6%89%8b%e6%9c%af&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;日期：2024.10.11&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;医院：宣武医院&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;主刀：关键&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;费用：&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;术后状况：术前患者同意不放融合器，术中切了后宫，术后复位还不错&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;术后影像：&lt;/p&gt;&#xA;  &lt;img src=&#34;img/11124/微信图片_20250118105546_85.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11124/微信图片_20250418163524_121.png&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11124/微信图片_20250418163524_122.png&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11124/微信图片_20250418163524_123.png&#34; height=&#34;100&#34; /&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;康复记录：&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/atlas-case/11125.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/atlas-case/11125.html</guid>
      <description>&lt;h1 id=&#34;11125&#34;&gt;11125&lt;a class=&#34;anchor&#34; href=&#34;#11125&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;患者信息&#34;&gt;患者信息&lt;a class=&#34;anchor&#34; href=&#34;#%e6%82%a3%e8%80%85%e4%bf%a1%e6%81%af&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;记录日期：2025.01.18&lt;/li&gt;&#xA;&lt;li&gt;出生年份：1959&lt;/li&gt;&#xA;&lt;li&gt;性别：&lt;/li&gt;&#xA;&lt;li&gt;省份：&lt;/li&gt;&#xA;&lt;li&gt;症状：&lt;/li&gt;&#xA;&lt;li&gt;诊断日期：&lt;/li&gt;&#xA;&lt;li&gt;诊断：寰枢椎脱位&lt;/li&gt;&#xA;&lt;li&gt;影像：&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;手术&#34;&gt;手术&lt;a class=&#34;anchor&#34; href=&#34;#%e6%89%8b%e6%9c%af&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;日期：2024.08.11&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;医院：宣武医院&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;主刀：陈赞&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;费用：&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;术后状况：术后症状加重，不能下床&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;术后影像：&lt;/p&gt;&#xA;  &lt;img src=&#34;img/11125/微信图片_20250118120856_627.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11125/微信图片_20250118120856_628.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11125/微信图片_20250118120856_629.jpg&#34; height=&#34;100&#34; /&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;康复记录：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;术后4个月，在天坛拍0.23低磁场核磁&lt;/p&gt;&#xA;  &lt;img src=&#34;img/11125/微信图片_20250118120856_630.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11125/微信图片_20250118120856_631.jpg&#34; height=&#34;100&#34; /&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/atlas-case/11126.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/atlas-case/11126.html</guid>
      <description>&lt;h1 id=&#34;11126&#34;&gt;11126&lt;a class=&#34;anchor&#34; href=&#34;#11126&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;患者信息&#34;&gt;患者信息&lt;a class=&#34;anchor&#34; href=&#34;#%e6%82%a3%e8%80%85%e4%bf%a1%e6%81%af&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;记录日期：2025.01.18&lt;/li&gt;&#xA;&lt;li&gt;出生年份：1973&lt;/li&gt;&#xA;&lt;li&gt;性别：&lt;/li&gt;&#xA;&lt;li&gt;省份：湖南&lt;/li&gt;&#xA;&lt;li&gt;症状：四肢麻木一年，能正常走路，下楼梯下肢僵直，左脚底有踩着东西的感觉&lt;/li&gt;&#xA;&lt;li&gt;诊断日期：&lt;/li&gt;&#xA;&lt;li&gt;诊断：寰枢椎脱位&lt;/li&gt;&#xA;&lt;li&gt;影像：&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;手术&#34;&gt;手术&lt;a class=&#34;anchor&#34; href=&#34;#%e6%89%8b%e6%9c%af&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;日期：2024.07&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;医院：人民医院&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;主刀：王超&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;费用：&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;术后状况：可以正常走路了&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;术后影像：&lt;/p&gt;&#xA;  &lt;img src=&#34;img/11126/微信图片_20250118121840_16.jpg&#34; height=&#34;100&#34; /&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;康复记录：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;2025.01.08复查&lt;/p&gt;&#xA;  &lt;img src=&#34;img/11126/微信图片_20250118121714_45.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11126/微信图片_20250118121714_46.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11126/微信图片_20250118121714_47.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11126/微信图片_20250118121714_48.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11126/微信图片_20250118121714_49.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11126/微信图片_20250118121714_50.jpg&#34; height=&#34;100&#34; /&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/atlas-case/11127.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/atlas-case/11127.html</guid>
      <description>&lt;h1 id=&#34;11127&#34;&gt;11127&lt;a class=&#34;anchor&#34; href=&#34;#11127&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;患者信息&#34;&gt;患者信息&lt;a class=&#34;anchor&#34; href=&#34;#%e6%82%a3%e8%80%85%e4%bf%a1%e6%81%af&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;记录日期：2025.01.25&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;出生年份：1986&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;性别：女&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;省份：&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;症状：一走路头晕脑胀，迷迷糊糊，眼睛犯困&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;诊断日期：2024.04.25&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;诊断：寰枢椎脱位，颅底凹陷&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;影像：&lt;/p&gt;&#xA;  &lt;img src=&#34;img/11127/微信图片_20250125100208.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11127/微信图片_20250125100213.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11127/微信图片_20250125100216.jpg&#34; height=&#34;100&#34; /&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;手术&#34;&gt;手术&lt;a class=&#34;anchor&#34; href=&#34;#%e6%89%8b%e6%9c%af&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;日期：2025.01.09&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;医院：人民医院&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;主刀：王超&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;费用：&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;术后状况：体感上没有明显变化&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;术后影像：&lt;/p&gt;&#xA;  &lt;img src=&#34;img/11127/微信图片_20250125101304_10978.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11127/微信图片_20250125100035_8.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11127/微信图片_20250125100035_9.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11127/微信图片_20250125100035_10.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11127/微信图片_20250125100035_11.jpg&#34; height=&#34;100&#34; /&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;康复记录：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;2025.01.25，体感上和术前一样，一走路就头晕脑胀&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/atlas-case/11128.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/atlas-case/11128.html</guid>
      <description>&lt;h1 id=&#34;11128&#34;&gt;11128&lt;a class=&#34;anchor&#34; href=&#34;#11128&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;患者信息&#34;&gt;患者信息&lt;a class=&#34;anchor&#34; href=&#34;#%e6%82%a3%e8%80%85%e4%bf%a1%e6%81%af&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;记录日期：2025.01.25&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;出生年份：1980&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;性别：女&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;省份：&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;症状：&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;诊断日期：&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;诊断：寰枢椎脱位&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;影像：&lt;/p&gt;&#xA;  &lt;img src=&#34;img/11128/微信图片_20250125192001_80.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11128/微信图片_20250125190413_55.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11128/微信图片_20250125190413_56.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11128/微信图片_20250125190413_57.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11128/微信图片_20250125190413_58.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11128/微信图片_20250125190413_59.jpg&#34; height=&#34;100&#34; /&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;手术&#34;&gt;手术&lt;a class=&#34;anchor&#34; href=&#34;#%e6%89%8b%e6%9c%af&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;日期：2024.06&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;医院：上海长征医院&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;主刀：&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;费用：&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;术后状况：没有复位&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;术后影像：&lt;/p&gt;&#xA;  &lt;img src=&#34;img/11128/微信图片_20250125102221_11001.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11128/微信图片_20250125180533_63.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11128/微信图片_20250125180533_64.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11128/微信图片_20250125180533_65.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11128/微信图片_20250125180533_66.jpg&#34; height=&#34;100&#34; /&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;二次手术&#34;&gt;二次手术&lt;a class=&#34;anchor&#34; href=&#34;#%e4%ba%8c%e6%ac%a1%e6%89%8b%e6%9c%af&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;日期：2024.12.30&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;医院：人民医院&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;主刀：王超&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;费用：&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;术后状况：&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;术后影像：&lt;/p&gt;&#xA;  &lt;img src=&#34;img/11128/微信图片_2025-01-25_154945_662.png&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11128/微信图片_20250125102221_10992.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11128/微信图片_20250125190553_50.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11128/微信图片_20250125190553_51.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11128/微信图片_20250125190553_52.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11128/微信图片_20250125190553_53.jpg&#34; height=&#34;100&#34; /&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/atlas-case/11129.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/atlas-case/11129.html</guid>
      <description>&lt;h1 id=&#34;11129&#34;&gt;11129&lt;a class=&#34;anchor&#34; href=&#34;#11129&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;患者信息&#34;&gt;患者信息&lt;a class=&#34;anchor&#34; href=&#34;#%e6%82%a3%e8%80%85%e4%bf%a1%e6%81%af&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;记录日期：2025.02.12&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;出生年份：&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;性别：男&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;省份：&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;症状：有左手麻木，左腿膝盖有点没劲&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;诊断日期：&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;诊断：寰枢椎脱位&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;影像：&lt;/p&gt;&#xA;  &lt;img src=&#34;img/11129/微信图片_20250212175857_14.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11129/微信图片_20250212175857_15.jpg&#34; height=&#34;100&#34; /&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;手术&#34;&gt;手术&lt;a class=&#34;anchor&#34; href=&#34;#%e6%89%8b%e6%9c%af&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;日期：2024.12.21&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;医院：宣武医院&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;主刀：段婉茹主刀，陈赞一助&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;费用：&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;术后状况：复位良好，左腿膝盖有没劲缓解了，左手麻木还有&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;术后影像：&lt;/p&gt;&#xA;  &lt;img src=&#34;img/11129/微信图片_20250212175857_13.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11129/微信图片_20250212175857_16.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11129/微信图片_20250212175857_17.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11129/微信图片_20250212175920_39.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11129/微信图片_20250212175920_40.jpg&#34; height=&#34;100&#34; /&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/atlas-case/11130.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/atlas-case/11130.html</guid>
      <description>&lt;h1 id=&#34;11130&#34;&gt;11130&lt;a class=&#34;anchor&#34; href=&#34;#11130&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;患者信息&#34;&gt;患者信息&lt;a class=&#34;anchor&#34; href=&#34;#%e6%82%a3%e8%80%85%e4%bf%a1%e6%81%af&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;记录日期：2025.04.18&lt;/li&gt;&#xA;&lt;li&gt;出生年份：2002&lt;/li&gt;&#xA;&lt;li&gt;性别：男&lt;/li&gt;&#xA;&lt;li&gt;省份：&lt;/li&gt;&#xA;&lt;li&gt;症状：&lt;/li&gt;&#xA;&lt;li&gt;诊断日期：&lt;/li&gt;&#xA;&lt;li&gt;诊断：寰枢椎脱位&lt;/li&gt;&#xA;&lt;li&gt;影像：&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;手术&#34;&gt;手术&lt;a class=&#34;anchor&#34; href=&#34;#%e6%89%8b%e6%9c%af&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;日期：&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;医院：上海长征医院&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;主刀：&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;费用：&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;术后状况：术中放了融合器&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;术后影像：&lt;/p&gt;&#xA;  &lt;img src=&#34;img/11130/微信图片_20250418164945.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11130/微信图片_20250418164754.jpg&#34; height=&#34;100&#34; /&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;康复记录：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;清楚多久之后复位丢失。陈赞说是松解不到位导致的复位丢失。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;二次手术&#34;&gt;二次手术&lt;a class=&#34;anchor&#34; href=&#34;#%e4%ba%8c%e6%ac%a1%e6%89%8b%e6%9c%af&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;日期：2024.12.31&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;医院：宣武医院&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;主刀：陈赞，段婉茹一助&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;费用：&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;术后状况：切除齿状突，效果良好&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;术后影像：&lt;/p&gt;&#xA;  &lt;img src=&#34;img/11130/微信图片_20250418165107.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11130/微信图片_20250418164852.jpg&#34; height=&#34;100&#34; /&gt;&#xA;  &lt;img src=&#34;img/11130/微信图片_20250418164934.jpg&#34; height=&#34;100&#34; /&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;康复记录：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;2025.03.03 感觉症状缓解的不多。&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/bigdata/ambari-quick-build-bigdata-platform.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/bigdata/ambari-quick-build-bigdata-platform.html</guid>
      <description>&lt;h1 id=&#34;ambari---三条命令创建集群&#34;&gt;Ambari - 三条命令创建集群&lt;a class=&#34;anchor&#34; href=&#34;#ambari---%e4%b8%89%e6%9d%a1%e5%91%bd%e4%bb%a4%e5%88%9b%e5%bb%ba%e9%9b%86%e7%be%a4&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;什么是-ambari&#34;&gt;什么是 Ambari&lt;a class=&#34;anchor&#34; href=&#34;#%e4%bb%80%e4%b9%88%e6%98%af-ambari&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;Ambari 是大数据生态圈中的一员，但它不是一个大数据计算引擎，而是一个管理工具，用来管理其它大数据工具，如：Hadoop、Spark、Hive 等，当你用 Ambari 作为你的管理工具时，它可以帮你监视你的集群状态、每个组件状态、节点状态等，如下图（这个不是 apache 官方版，所以请原谅我打点马赛克）：&#xA;&lt;img src=&#34;img/ambari-quick-build-bigdata-platform/ambari-quick-build-bigdata-platform_blue-introduce-1024x487.png&#34; alt=&#34;&#34; /&gt;&#xA;它还可以为你的集群增加或删除一个组件，比如，你的集群没有 Storm，而现在你可以通过 Ambari 来添加它，只需动一动鼠标即可完成。&lt;/p&gt;&#xA;&lt;h2 id=&#34;原理简介&#34;&gt;原理简介&lt;a class=&#34;anchor&#34; href=&#34;#%e5%8e%9f%e7%90%86%e7%ae%80%e4%bb%8b&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;它是一个经典的主从架构的分布式的软件，主要由 Ambari-Server 与 Ambari-Agent 两部分组成，架构图如下：&#xA;&lt;img src=&#34;img/ambari-quick-build-bigdata-platform/ambari-quick-build-bigdata-platform_arch.png&#34; alt=&#34;&#34; /&gt; 以上是用户为集群添加一个组件（Hbase）的过程，用户在前端进行的所有操作都是通过 REST API 调用后台 Ambari 的，我们可以用浏览器抓包看一下：&#xA;&lt;img src=&#34;img/ambari-quick-build-bigdata-platform/ambari-quick-build-bigdata-platform_blue-api-1024x481.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;ambari-bleprint-作用&#34;&gt;Ambari Bleprint 作用&lt;a class=&#34;anchor&#34; href=&#34;#ambari-bleprint-%e4%bd%9c%e7%94%a8&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;我们先来看一下用 Ambari 创建一个集群的步骤，当在一台机器上安装好 Ambari 后，进入它的 WEB UI，这时出现一个集群创建向导，如下：&#xA;&lt;img src=&#34;img/ambari-quick-build-bigdata-platform/ambari-quick-build-bigdata-platform_guide.png&#34; alt=&#34;&#34; /&gt;&#xA;这个向导还是很方便的，其中有添加主机，选择要安装的组件等功能。 而 Ambari Bleprint 可以看作是 Ambari 本身提供的一个功能，它的作用是：可以让用户免去 Ambari 的集群安装向导操作，可以让用户把安装集群的所有步骤脚本化，这是个很有用的场景，而它的基本原理就是通两个 JSON 文件来描述一个集群，如下：&#xA;&lt;img src=&#34;img/ambari-quick-build-bigdata-platform/docker-auto-test-product_json-768x456.png&#34; alt=&#34;&#34; /&gt;&#xA;图中左边是两个 JSON 文件，它们被通过 REST API 的方式发送给 Ambari-Server ，再由 Ambari-Server 创建出一个集群。&lt;/p&gt;&#xA;&lt;h2 id=&#34;ambari-bleprint-的使用&#34;&gt;Ambari Bleprint 的使用&lt;a class=&#34;anchor&#34; href=&#34;#ambari-bleprint-%e7%9a%84%e4%bd%bf%e7%94%a8&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;用 Ambari Bleprint 创建一个集群大概分为6步：&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/bigdata/bigdate-on-docker.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/bigdata/bigdate-on-docker.html</guid>
      <description>&lt;h1 id=&#34;bigdata-on-docker&#34;&gt;Bigdata on Docker&lt;a class=&#34;anchor&#34; href=&#34;#bigdata-on-docker&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;p&gt;最近我们在把自己的大数据平台迁移到 Docker 上面来，最初的想法是用 Docker 技术代替我们现在的 Open Stack 平台，也就是把 Docker 容器当成虚拟来用，看到这里可能人要说了：这明显没有遵循 Docker 的佳实践啊！是的，但具我了解，很多大数据厂商都在想办法把自家的平台容器化，而且有不少厂商已经做到了，也许这就是趋势吧，尽管 Docker 的设计者并不建议这样做，到后面我们会把大数据平台中的每一个组件一个个的拆开，每一个组件都容器化。现在我们已经实践有一段时间了，并且下一步打算用 Kubernetes 来管理我们的 Docker 集群，先来整理一下在 bigdata on docker 实践中遇到的问题，这些问题都是最实际的，正所谓：真正的工作在细节之中。也希望能给读者一条捷径。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;现在我们来把一个已有的大数据集群放在 Docker 环境中，我指的是重新搭一个集群而不是完整的挪过去。。&lt;/p&gt;&#xA;&lt;h2 id=&#34;系统环境&#34;&gt;系统环境&lt;a class=&#34;anchor&#34; href=&#34;#%e7%b3%bb%e7%bb%9f%e7%8e%af%e5%a2%83&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;大数据平台在整体架构上不会有什么变化，就是把物理机换成是 Docker 容器而已，那么容器从哪来？一般情况下你需要自己构建一个出来，比如你的大数据平台是基于 CentOS6.5 的，那就要自己动手&lt;a href=&#34;http://localhost:1313/articles/docker/docker-build-centos65&#34;&gt;构建一个基础镜像&lt;/a&gt;作为系统，这个镜像中可以包含你需要的一切依赖，如 jdk 和 python 等，然后用这个镜像创建指定数据的容器，比如我打算搭建一个 5 节点的集群那就创建 5 个容器出来，关于创建容器的参数下面再讲，因为还要涉及到网络和挂载之类的问题。&lt;/p&gt;&#xA;&lt;h2 id=&#34;同步镜像&#34;&gt;同步镜像&lt;a class=&#34;anchor&#34; href=&#34;#%e5%90%8c%e6%ad%a5%e9%95%9c%e5%83%8f&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;有了基础镜像之后，我们需要把这个镜像同步到所有物理机上，如果你如有一台物理机的话，可能不需要这一步，直接用 &lt;code&gt;docker pull docker.io/...&lt;/code&gt; 这样的方式就可以了，但如果你有几十台或者更多的物理机，那么你需要&lt;a href=&#34;http://localhost:1313/articles/docker/docker-registry-deploy-manage&#34;&gt;搭建一个私有仓库&lt;/a&gt;，把你的镜像 push 进入，然后其它机器执行 &lt;code&gt;docker pull&lt;/code&gt; 即可。&lt;/p&gt;&#xA;&lt;h2 id=&#34;网络&#34;&gt;网络&lt;a class=&#34;anchor&#34; href=&#34;#%e7%bd%91%e7%bb%9c&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;解决 Docker 的跨主机通信是比较重要的一环，好在 Docker 1.9 版本中加入了 Overlay 网络，官方给出来两种方案解决跨主机的通信问题，一个是创建 Swarm 集群，创建好后它会自带一个 Overlay 网络，然后在这个集群中用 &lt;code&gt;Docker service create&lt;/code&gt; 这样的方式创建一些容器，它们相互之间就可以直接通信了，但这个网络不能用 &lt;code&gt;Docker run --network&lt;/code&gt; 的方式使用。&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/bigdata/bigdate-on-kubernetes.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/bigdata/bigdate-on-kubernetes.html</guid>
      <description>&lt;h1 id=&#34;bigdata-on-kubernetes&#34;&gt;Bigdata on Kubernetes&lt;a class=&#34;anchor&#34; href=&#34;#bigdata-on-kubernetes&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;p&gt;把大数据平台容器化，是我们的必经之路，一是因为容器化有诸多好处，比如：将每个组件标准化、易于管理、快速升级、快速部署等等，二是因为趋势，当其它人做了而你没做，就可能被客户抛弃，所以最好在所有人之前就开始做。&lt;/p&gt;&#xA;&lt;h2 id=&#34;基础镜像&#34;&gt;基础镜像&lt;a class=&#34;anchor&#34; href=&#34;#%e5%9f%ba%e7%a1%80%e9%95%9c%e5%83%8f&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;把大数据平台容器化，首先得先把平台中的组件一个个拆开，然后每个组件（Hadoop, Spark等）的运行环境都有差别，比如 Hadoop 依赖 DJK7 而 Spark 依赖 JDK8 等，这就需要将组件和相应的依赖打包成在一起，但所有组件应该共用一个基础镜像，这个基础镜像很小，可能只有几十到几百 MB ，构建基础镜像&lt;a href=&#34;http://localhost:1313/articles/docker/docker-build-centos65&#34;&gt;看这里&lt;/a&gt;，有了基础镜像之后就可以在写每个 Dockerfile 时指定的你 FROM 参数。&lt;/p&gt;&#xA;&lt;h2 id=&#34;构建组件镜像&#34;&gt;构建组件镜像&lt;a class=&#34;anchor&#34; href=&#34;#%e6%9e%84%e5%bb%ba%e7%bb%84%e4%bb%b6%e9%95%9c%e5%83%8f&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;我们先用 hadoop-yarn 来举例编写一个 Dockerfile，如果我有自己的 yum 源，那么可以直接使用 &lt;code&gt;yum install hadoop-yarn&lt;/code&gt; 这样的方式来安装，下面是一个例子：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;FROM centos6.5-base&#xA;&#xA;ADD  /jdk-7u79-linux-x64.tar.gz /opt&#xA;COPY /bigdata.repo /etc/yum.repos.d/bigdata.repo&#xA;&#xA;ENV JAVA_HOME=/opt/jdk1.7.0_79&#xA;&#xA;RUN yum install hadoop* -y &#xA;&#xA;COPY /bootstrap.sh /bootstrap.sh&#xA;&#xA;CMD /bootstrap.sh&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中 &lt;code&gt;bigdata.repo&lt;/code&gt; 是一个 yum 源文件，里面定义了 hadoop, spark, hbase 等组件的 rpm 源；&lt;code&gt;bootstrap.sh&lt;/code&gt; 是一个服务启动脚本，里面写了很重要的逻辑。&lt;/p&gt;&#xA;&lt;h2 id=&#34;镜像仓库&#34;&gt;镜像仓库&lt;a class=&#34;anchor&#34; href=&#34;#%e9%95%9c%e5%83%8f%e4%bb%93%e5%ba%93&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;有了 Yarn 镜像之后，我们需要将它放到私有仓库中，以便 Kubernetes 集群中的所有机器都能使用它，这时你需要&lt;a href=&#34;http://localhost:1313/articles/docker/docker-registry-deploy-manage&#34;&gt;搭建一个私有仓库&lt;/a&gt;，然后把所有组件的镜像 push 进去。&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/bigdata/spark-performance-optimiz.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/bigdata/spark-performance-optimiz.html</guid>
      <description>&lt;h1 id=&#34;spark-on-yarn---性能调优&#34;&gt;Spark on Yarn - 性能调优&lt;a class=&#34;anchor&#34; href=&#34;#spark-on-yarn---%e6%80%a7%e8%83%bd%e8%b0%83%e4%bc%98&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;p&gt;自从领导让我接手了 Docker 方面的工作，虽然每天还是会跟大数据接触，但主要精力已转到了 Docker 上，感觉自己离大数据越来越远了，今天写一篇关于 Spark 调优的文章，也算是复习一下。&lt;/p&gt;&#xA;&lt;h2 id=&#34;环境描述&#34;&gt;环境描述&lt;a class=&#34;anchor&#34; href=&#34;#%e7%8e%af%e5%a2%83%e6%8f%8f%e8%bf%b0&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;Spark 有多种运行模式，本次我们以 yarn-cluster 模式来运行，环境如下：&#xA;Spark 版本：2.0.0&#xA;Spark 运行模式：yarn-cluster&#xA;计算节点数：10&#xA;单节点内存大小：64g&#xA;单节点 CPU 核数：16&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;yarn配置&#34;&gt;Yarn配置&lt;a class=&#34;anchor&#34; href=&#34;#yarn%e9%85%8d%e7%bd%ae&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;即然用 Yarn 来管理资源，那么 Spark 最终运行性能也会受 Yarn 的影向，我们先来说明 Yanr 中几个关键配置参数。&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;yarn.nodemanager.resource.memory-mb = 61440&lt;/code&gt;：&#xA;这个参数指每个（假设我们所有节点配置都是一样的）物理机要供献出多少内存给 Yarn，每个节点有 64G，减去给系统预留的 2G，NodeManager 和 DataNode 各占用 1G，如果没有其它服务的话，还剩下 60G，最终得出 60 * 1024 = 61440 ， 这只是个参考，实际上在系统开机以后已经没有 64G 了，而且每个节点上还不止这两个服务，如 Hbase、impala、logstash 等等，所以还要考虑这些服务所占用的资源。&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;yarn.nodemanager.resource.cpu-vcores = 15&lt;/code&gt;：&#xA;这个值指单个节点要供献出多少CPU给Ynar来调度，同样要减去系统与其它服务所占用的核数，我们就以15为例了。 另外关于这个值还有个说法，比如物理机是12核，减去其它服务占用的2个，那么在配置里面写的时候就是15 * 1.5 = 22 或者 10 * 2 = 30，而我试过以后，觉得性能并没有明显变化。 这时，Yarn的总资源： 总内存：61440M * 10个节点 = 614400M 总核数：15核 * 10个节点 = 150核&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/bigdata/spark-performance-test.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/bigdata/spark-performance-test.html</guid>
      <description>&lt;h1 id=&#34;spark---性能测试&#34;&gt;Spark - 性能测试&lt;a class=&#34;anchor&#34; href=&#34;#spark---%e6%80%a7%e8%83%bd%e6%b5%8b%e8%af%95&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;p&gt;本文介绍一种测试 Spark 性能的方法，也可以用来测试 Spark SQL 模块对 SQL 语句的覆盖率，主要用 TPC-DS 这个工具，希望可以帮到一些同学。&lt;/p&gt;&#xA;&lt;h2 id=&#34;什么是-tpc-ds&#34;&gt;什么是 TPC-DS&lt;a class=&#34;anchor&#34; href=&#34;#%e4%bb%80%e4%b9%88%e6%98%af-tpc-ds&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;TPC-DS 是事务性能管理委员会 (TPC) 发布的大数据测试基准&lt;/li&gt;&#xA;&lt;li&gt;它可以生成 99 个测试案例，遵循 SQL&#39;99 和 SQL 2003 的语法标准，SQL 案例比较复杂&lt;/li&gt;&#xA;&lt;li&gt;分析的数据量大，并且测试案例是在回答真实的商业问题&lt;/li&gt;&#xA;&lt;li&gt;测试案例中包含各种业务模型（如分析报告型，迭代式的联机分析型，数据挖掘型等）&lt;/li&gt;&#xA;&lt;li&gt;几乎所有的测试案例都有很高的 IO 负载和 CPU 计算需求&lt;/li&gt;&#xA;&lt;li&gt;它有常用的两个功能:&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;按指定规模生成测试数据&lt;/li&gt;&#xA;&lt;li&gt;按指定的 SQL 标准生成测试用的 99 条 SQL 语句&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;基本原理&#34;&gt;基本原理&lt;a class=&#34;anchor&#34; href=&#34;#%e5%9f%ba%e6%9c%ac%e5%8e%9f%e7%90%86&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;首先用 TPC-DS 生成测试数据与 99 条 SQL 语句，然后将数据导入 Hive，配置 Spark 使其能够访问到 Hive 元数据，这时启用 Spark 自身的 spark thrift server 服务，如果没有了解过，&lt;a href=&#34;http://localhost:1313/articles/spark/spark-thrift-mode&#34;&gt;可以参考这里&lt;/a&gt;，向这个 Server 发送 SQL 语句，最后获取其执行时间并记录下来。&lt;/p&gt;&#xA;&lt;h2 id=&#34;生成数据与sql语句&#34;&gt;生成数据与sql语句&lt;a class=&#34;anchor&#34; href=&#34;#%e7%94%9f%e6%88%90%e6%95%b0%e6%8d%ae%e4%b8%8esql%e8%af%ad%e5%8f%a5&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;下载最新版 tpc-ds-tool.zip, 放在 /root/modules 目录下，官网地址：www.tpc.org&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/bigdata/spark-source-code-1.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/bigdata/spark-source-code-1.html</guid>
      <description>&lt;h1 id=&#34;spark---源码分析一&#34;&gt;Spark - 源码分析（一）&lt;a class=&#34;anchor&#34; href=&#34;#spark---%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90%e4%b8%80&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;p&gt;最近抽时间读了下 Spark 源码，最初只是想看看它是怎样跟 HDFS 交互的，每个 task 怎样在它所在的机器上找到及读取数据块的，这一看就是好几天，罢了，那就从头到尾研究一下吧，准备每周更新一篇。在这里记录的只是我所理解的东西，这样一个庞大的软件，如果没有当初的设计图纸是很难梳理清楚其全部原理的，我就看到哪写到哪吧。&lt;/p&gt;&#xA;&lt;h2 id=&#34;spark简介&#34;&gt;Spark简介&lt;a class=&#34;anchor&#34; href=&#34;#spark%e7%ae%80%e4%bb%8b&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;Spark 是一个基于内存的大数据处理框架，官方称 Spark 比M apReduce 的处理速度快 10 到 100 倍。它最初在 2009 年由加州大学伯克利分校的 AMPLab 开发，并于 2010 年成为 Apache 的开源项目之一。&lt;/p&gt;&#xA;&lt;p&gt;Spark版本：2.1.0&lt;/p&gt;&#xA;&lt;p&gt;部署模式：Spark on Yarn&lt;/p&gt;&#xA;&lt;p&gt;我们就从提交一个任开始，看看Spark都做了些什么，先写一个简单的Spark任务，如下：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package com.example&#xA; &#xA;import org.apache.spark.{SparkContext,SparkConf}&#xA; &#xA;object SparkCode {&#xA;   &#xA;  def main(args: Array[String]): Unit = {&#xA;    val spark = SparkSession&#xA;      .builder&#xA;      .appName(&amp;#34;Spark Pi&amp;#34;)&#xA;      .getOrCreate()&#xA;     &#xA;    spark.sparkContext.textFile(&amp;#34;hdfs:///spark/input/file.txt&amp;#34;, 3)&#xA;      .map { x =&amp;gt; (x, 1)}&#xA;      .reduceByKey(_ + _)&#xA;      .saveAsTextFile(&amp;#34;hdfs:///spark/output&amp;#34;)&#xA;     &#xA;    spark.stop()&#xA;  }&#xA;   &#xA;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;将上面代码打成Jar包，然后通过 spark-submit 命令提交这个任务，提交以后它在干什么？&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/bigdata/spark-source-code-2.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/bigdata/spark-source-code-2.html</guid>
      <description>&lt;h1 id=&#34;spark---源码分析二&#34;&gt;Spark - 源码分析（二）&lt;a class=&#34;anchor&#34; href=&#34;#spark---%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90%e4%ba%8c&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;h3 id=&#34;小节scala中的闭包&#34;&gt;小节：Scala中的闭包&lt;a class=&#34;anchor&#34; href=&#34;#%e5%b0%8f%e8%8a%82scala%e4%b8%ad%e7%9a%84%e9%97%ad%e5%8c%85&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;p&gt;本篇开始之前，先说一下闭包的概念，一会要用到，在 Scala 中的写一个闭包是很容易的，甚至比 js 还简单，如下：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;object Test {  &#xA;   var base = 3 &#xA;   val myFunc = (i:Int) =&amp;gt; i * base  &#xA;   def main(args: Array[String]) {  &#xA;      println(myFunc(5))  &#xA;   }  &#xA;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如上的 myFunc 函数依赖了一个外部变量 base，也就是说 base 成为了 myFunc 函数的一部分，因为 myFunc 函数被其它地方引用，所以使得 base 变量也不会被GC回收，这样就形成了一个闭包。&lt;/p&gt;&#xA;&lt;h2 id=&#34;提交job&#34;&gt;提交Job&lt;a class=&#34;anchor&#34; href=&#34;#%e6%8f%90%e4%ba%a4job&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;上篇中讲到了，假如我们在 RDD 对象上调用了产生宽依赖的算子时，那么该算子将最终会调用 SparkContext 类中的 runJob 方法，本篇中我们接着这个 runJob 方法继续往下看，先回顾下调用 runJob 的地方，以下是RDD类中的一个算子：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;...&#xA;  def foreach(f: T =&amp;gt; Unit): Unit = withScope {&#xA;    val cleanF = sc.clean(f)&#xA;    sc.runJob(this, (iter: Iterator[T]) =&amp;gt; iter.foreach(cleanF))&#xA;  }&#xA;...&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;参数列表中的 f，就是我们在调用 foreach 的时候，自己写的匿名函数，在这里它被另一个匿名函数引用，这样就形成了一个闭包，最后将这个闭包函数传递给了 runJob 方法。以下是 runJob 方法的原型：&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/bigdata/spark-source-code-3.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/bigdata/spark-source-code-3.html</guid>
      <description>&lt;h1 id=&#34;spark---源码分析三&#34;&gt;Spark - 源码分析（三）&lt;a class=&#34;anchor&#34; href=&#34;#spark---%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90%e4%b8%89&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;生成task&#34;&gt;生成Task&lt;a class=&#34;anchor&#34; href=&#34;#%e7%94%9f%e6%88%90task&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;上篇中我们讲到Spark在提交一个Stage后，DAGScheduler中的&lt;code&gt;submitStage()&lt;/code&gt;方法会以递归的方式找到该Stage依赖的最上层的父Stage，找到后会将这个最上层的Stage传给&lt;code&gt;submitMissingTasks()&lt;/code&gt;方法，该方法定义如下：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;...&#xA;  /** Called when stage&amp;#39;s parents are available and we can now do its task. */&#xA;  private def submitMissingTasks(stage: Stage, jobId: Int) {&#xA;    logDebug(&amp;#34;submitMissingTasks(&amp;#34; + stage + &amp;#34;)&amp;#34;)&#xA;    ...&#xA;    runningStages += stage&#xA;    stage match {&#xA;      case s: ShuffleMapStage =&amp;gt;&#xA;        outputCommitCoordinator.stageStart(stage = s.id, maxPartitionId = s.numPartitions - 1)&#xA;      case s: ResultStage =&amp;gt;&#xA;        outputCommitCoordinator.stageStart(&#xA;          stage = s.id, maxPartitionId = s.rdd.partitions.length - 1)&#xA;    }&#xA;    val taskIdToLocations: Map[Int, Seq[TaskLocation]] = try {&#xA;      stage match {&#xA;        case s: ShuffleMapStage =&amp;gt;&#xA;          partitionsToCompute.map { id =&amp;gt; (id, getPreferredLocs(stage.rdd, id))}.toMap&#xA;        case s: ResultStage =&amp;gt;&#xA;          partitionsToCompute.map { id =&amp;gt;&#xA;            val p = s.partitions(id)&#xA;            (id, getPreferredLocs(stage.rdd, p))&#xA;          }.toMap&#xA;      }&#xA;    ...&#xA;    taskBinary = sc.broadcast(taskBinaryBytes)&#xA;...&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面只贴出了该方法的一部分，我们刚才说的父Stage被传进来后，做了几件事情，我们分步骤说一下：&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/bigdata/spark-source-code-4.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/bigdata/spark-source-code-4.html</guid>
      <description>&lt;h1 id=&#34;spark--源码分析四&#34;&gt;Spark – 源码分析（四）&lt;a class=&#34;anchor&#34; href=&#34;#spark--%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90%e5%9b%9b&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;task-的执行&#34;&gt;Task 的执行&lt;a class=&#34;anchor&#34; href=&#34;#task-%e7%9a%84%e6%89%a7%e8%a1%8c&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;上篇讲到TaskRunner类，这个类是定义在Executor类中，实现了Java的Runnable接口，Spark运行过程中的一个Task就是一个TaskRunner实例，下面是它的 &lt;code&gt;run()&lt;/code&gt; 方法&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;  override def run(): Unit = {&#xA;    threadId = Thread.currentThread.getId&#xA;    Thread.currentThread.setName(threadName)&#xA;    val threadMXBean = ManagementFactory.getThreadMXBean&#xA;    val taskMemoryManager = new TaskMemoryManager(env.memoryManager, taskId)&#xA;    val deserializeStartTime = System.currentTimeMillis()&#xA;    val deserializeStartCpuTime = if (threadMXBean.isCurrentThreadCpuTimeSupported) {&#xA;      threadMXBean.getCurrentThreadCpuTime&#xA;    } else 0L&#xA;    Thread.currentThread.setContextClassLoader(replClassLoader)&#xA;    val ser = env.closureSerializer.newInstance()&#xA;    logInfo(s&amp;#34;Running $taskName (TID $taskId)&amp;#34;)&#xA;    execBackend.statusUpdate(taskId, TaskState.RUNNING, EMPTY_BYTE_BUFFER)&#xA;    var taskStart: Long = 0&#xA;    var taskStartCpu: Long = 0&#xA;    startGCTime = computeTotalGcTime()&#xA; &#xA;    try {&#xA;      // Must be set before updateDependencies() is called, in case fetching dependencies&#xA;      // requires access to properties contained within (e.g. for access control).&#xA;      Executor.taskDeserializationProps.set(taskDescription.properties)&#xA; &#xA;      updateDependencies(taskDescription.addedFiles, taskDescription.addedJars)&#xA;      task = ser.deserialize[Task[Any]](&#xA;        taskDescription.serializedTask, Thread.currentThread.getContextClassLoader)&#xA;      task.localProperties = taskDescription.properties&#xA;      task.setTaskMemoryManager(taskMemoryManager)&#xA;...&#xA;      // Run the actual task and measure its runtime.&#xA;      taskStart = System.currentTimeMillis()&#xA;      taskStartCpu = if (threadMXBean.isCurrentThreadCpuTimeSupported) {&#xA;        threadMXBean.getCurrentThreadCpuTime&#xA;      } else 0L&#xA;      var threwException = true&#xA;      val value = try {&#xA;        val res = task.run(&#xA;          taskAttemptId = taskId,&#xA;          attemptNumber = taskDescription.attemptNumber,&#xA;          metricsSystem = env.metricsSystem)&#xA;        threwException = false&#xA;        res&#xA;      } finally {&#xA;        val releasedLocks = env.blockManager.releaseAllLocksForTask(taskId)&#xA;        val freedMemory = taskMemoryManager.cleanUpAllAllocatedMemory()&#xA; &#xA;        if (freedMemory &amp;gt; 0 &amp;amp;&amp;amp; !threwException) {&#xA;          val errMsg = s&amp;#34;Managed memory leak detected; size = $freedMemory bytes, TID = $taskId&amp;#34;&#xA;          if (conf.getBoolean(&amp;#34;spark.unsafe.exceptionOnMemoryLeak&amp;#34;, false)) {&#xA;            throw new SparkException(errMsg)&#xA;          } else {&#xA;            logWarning(errMsg)&#xA;          }&#xA;        }&#xA;...&#xA;      val resultSer = env.serializer.newInstance()&#xA;      val beforeSerialization = System.currentTimeMillis()&#xA;      val valueBytes = resultSer.serialize(value)&#xA;      val afterSerialization = System.currentTimeMillis()&#xA;...&#xA;      execBackend.statusUpdate(taskId, TaskState.FINISHED, serializedResult)&#xA;...&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;看起来有点长，只贴出部分，在这里分步总结一下：&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/bigdata/spark-source-code-5.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/bigdata/spark-source-code-5.html</guid>
      <description>&lt;h1 id=&#34;spark---源码分析图&#34;&gt;Spark - 源码分析（图）&lt;a class=&#34;anchor&#34; href=&#34;#spark---%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90%e5%9b%be&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;p&gt;最近抽时间画了张Spark的流程图，帮助理解Spark架构，供参考，点击图片可以放大。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;img/spark-source-code-5/spark-source-code-5_flow_chart.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/bigdata/spark-thrift-mode.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/bigdata/spark-thrift-mode.html</guid>
      <description>&lt;h1 id=&#34;spark---thrift-server模式&#34;&gt;Spark - Thrift Server模式&lt;a class=&#34;anchor&#34; href=&#34;#spark---thrift-server%e6%a8%a1%e5%bc%8f&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;p&gt;Spark Thrift Server 其实是 Spark SQL 的一种运行方式，笔者前段时间用它来做测试了 Spark 的性能，以及 Spark SQL 对 SQL 语句的支持情况，用起来还是十分方便的，后来在网上一搜，除了官网很少有写 Spark Thrift Server 的文章，那么本文将让你了解并且会使用它。&lt;/p&gt;&#xA;&lt;h2 id=&#34;spark-thrift-server-运行原理&#34;&gt;Spark Thrift Server 运行原理&lt;a class=&#34;anchor&#34; href=&#34;#spark-thrift-server-%e8%bf%90%e8%a1%8c%e5%8e%9f%e7%90%86&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;即然它被称为 Server，那它就是提供某种服务的，它提供的服务就是解析 SQL 语句，然后将解析完的 SQL 转换为 Spark 任务，并提交给 Spark 集群去执行（这里要取决于 Spark 的运行方式，如：Spark on Yarn、Spark Standalone 等），最后捕获运行结果。&lt;/p&gt;&#xA;&lt;h2 id=&#34;配置一个可用的-spark-thrift-server&#34;&gt;配置一个可用的 Spark Thrift Server&lt;a class=&#34;anchor&#34; href=&#34;#%e9%85%8d%e7%bd%ae%e4%b8%80%e4%b8%aa%e5%8f%af%e7%94%a8%e7%9a%84-spark-thrift-server&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;前提准备&#34;&gt;前提准备&lt;a class=&#34;anchor&#34; href=&#34;#%e5%89%8d%e6%8f%90%e5%87%86%e5%a4%87&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;我们为以三台机器的作为示例，分别为：host1、host2、host3&lt;/li&gt;&#xA;&lt;li&gt;在三个节点上部署好 Hadoop2.7 集群，并启动 Hdfs、Yarn&lt;/li&gt;&#xA;&lt;li&gt;在 host1 上部署好 Hive1.2.1，并且可以运行&lt;/li&gt;&#xA;&lt;li&gt;在 host1 上安装 Spark2.0，先不用配置&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;修改-spark-envsh&#34;&gt;修改 spark-env.sh&lt;a class=&#34;anchor&#34; href=&#34;#%e4%bf%ae%e6%94%b9-spark-envsh&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;p&gt;要使用 Spark Thrift Server，需要用到三个配置文件，我们一个一个来配置 首先是 Spark 安装目录下的 &lt;code&gt;conf/spark-env.sh&lt;/code&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/develop-tool/git.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/develop-tool/git.html</guid>
      <description>&lt;h1 id=&#34;git常用命令&#34;&gt;GIT常用命令&lt;a class=&#34;anchor&#34; href=&#34;#git%e5%b8%b8%e7%94%a8%e5%91%bd%e4%bb%a4&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;p&gt;克隆指定分支&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;git clone -b &amp;lt;branch_name&amp;gt; --depth 1 https://github.com/containerd/containerd.git&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;克隆指定TAG&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;git clone -b &amp;lt;tag_name&amp;gt; --depth 1 https://github.com/containerd/containerd.git&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;检出分支&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;git checkout tags/&amp;lt;tag_name&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;检出TAG并创建分支&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;git checkout tags/&amp;lt;tag_name&amp;gt; -b &amp;lt;branch_name&amp;gt;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/develop-tool/jq.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/develop-tool/jq.html</guid>
      <description>&lt;h1 id=&#34;jq命令&#34;&gt;JQ命令&lt;a class=&#34;anchor&#34; href=&#34;#jq%e5%91%bd%e4%bb%a4&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;p&gt;当key中包含点时或当key以数字开头时&#xA;docker inspect $container_id | jq -r &amp;lsquo;.[-1].NetworkSettings.Networks|.[&amp;ldquo;lenovo.com&amp;rdquo;].IPAddress&lt;/p&gt;&#xA;&lt;p&gt;根据元素的值选择元素&#xA;echo &amp;lsquo;{ &amp;ldquo;data&amp;rdquo;: [ { &amp;ldquo;joinTime&amp;rdquo;: 1507521910625, &amp;ldquo;memo&amp;rdquo;: &amp;ldquo;&amp;rdquo;, &amp;ldquo;projectId&amp;rdquo;: 48, &amp;ldquo;projectName&amp;rdquo;: &amp;ldquo;jiajun2&amp;rdquo; }, { &amp;ldquo;joinTime&amp;rdquo;: 1507794370272, &amp;ldquo;memo&amp;rdquo;: &amp;ldquo;&amp;rdquo;, &amp;ldquo;projectId&amp;rdquo;: 49, &amp;ldquo;projectName&amp;rdquo;: &amp;ldquo;jiajun22&amp;rdquo; } ], &amp;ldquo;msg&amp;rdquo;: &amp;ldquo;&amp;rdquo;, &amp;ldquo;result&amp;rdquo;: 0 }&amp;rsquo; |&#xA;jq &amp;lsquo;.data[]|select(.projectName|startswith(&amp;ldquo;jiajun22&amp;rdquo;))|.projectId&amp;rsquo;&#xA;或&#xA;kubeapi /api/v1/namespaces/p48-u25-jiajun2/pods/|jq -r &amp;ndash;arg ip 172.210.130.86 &amp;lsquo;.items[]|select(.status.podIP==$ip)|.status&amp;rsquo;&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/develop-tool/vscode.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/develop-tool/vscode.html</guid>
      <description>&lt;h1 id=&#34;vscode-for-go&#34;&gt;vscode for go&lt;a class=&#34;anchor&#34; href=&#34;#vscode-for-go&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;h3 id=&#34;常用快捷键&#34;&gt;常用快捷键&lt;a class=&#34;anchor&#34; href=&#34;#%e5%b8%b8%e7%94%a8%e5%bf%ab%e6%8d%b7%e9%94%ae&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;ctrl+space&lt;/code&gt; ：手动代码提示（Trigger Suggest）&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;ctrl+k ctrl+0&lt;/code&gt;：折叠所有代码块（Fold ALL）&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;ctrl+k ctrl+j&lt;/code&gt;：折叠所有代码块（Unfold ALL）&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;alt+left&lt;/code&gt; =&amp;gt; &lt;code&gt;ctrl+-&lt;/code&gt;：回退到上一步（go back）&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;alt+right&lt;/code&gt; =&amp;gt; &lt;code&gt;ctrl++&lt;/code&gt;：下一步（go forward）&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;ctrl+f&lt;/code&gt;：在当前文件中查找（Find in file）&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;ctrl+h&lt;/code&gt;：在当前文件中替换（Replace in file）&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;ctrl+shift+f&lt;/code&gt;：在当前文件夹查找（Find in files）&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;ctrl+shift+h&lt;/code&gt;：在当前文件夹替换（Replace in files）&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;none&lt;/code&gt;：代码格式化（Format Document）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;gopls&#34;&gt;gopls&lt;a class=&#34;anchor&#34; href=&#34;#gopls&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;p&gt;之前vscode for golang需要安装十几个命令行工具，在vscode 1.30.2版本（2018年）中，vscode加入了后台进程gopls来更好的支持代码提示、转到定义等功能。&lt;code&gt;gopls for vscode&lt;/code&gt;更多用法参见 &lt;a href=&#34;https://github.com/golang/tools/blob/master/gopls/doc/vscode.md&#34;&gt;github&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;gopls安装&#34;&gt;gopls安装&lt;a class=&#34;anchor&#34; href=&#34;#gopls%e5%ae%89%e8%a3%85&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;p&gt;以 ubuntu on windows 为例，安装 vs code with gopls。&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;下载最新版本golang，并配置好环境变量&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;cd; mkdir -p program golang&#xA;curl -Lo go.tar.gz https://dl.google.com/go/go1.14.2.linux-amd64.tar.gz&#xA;tar -zxf go.tar.gz -C program/&#xA;echo export GOROOT=$PWD/program/go &amp;gt;&amp;gt; .bashrc&#xA;echo export GOPATH=$PWD/golang &amp;gt;&amp;gt; .bashrc&#xA;echo &amp;#39;PATH=$PATH:$GOROOT/bin:$GOPATH/bin&amp;#39; &amp;gt;&amp;gt; .bashrc&#xA;. .bashrc&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;安装gopls&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/golang/find-index-in-cycle-array.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/golang/find-index-in-cycle-array.html</guid>
      <description>&lt;h1 id=&#34;在循环数组中找出索引&#34;&gt;在循环数组中找出索引&lt;a class=&#34;anchor&#34; href=&#34;#%e5%9c%a8%e5%be%aa%e7%8e%af%e6%95%b0%e7%bb%84%e4%b8%ad%e6%89%be%e5%87%ba%e7%b4%a2%e5%bc%95&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;需求&#34;&gt;需求&lt;a class=&#34;anchor&#34; href=&#34;#%e9%9c%80%e6%b1%82&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;给定一个循环有序的int数组和一个int值，返回该值在数组中的位置，如果数组中没有该值则返回-1。&lt;/p&gt;&#xA;&lt;h2 id=&#34;解法概述&#34;&gt;解法概述&lt;a class=&#34;anchor&#34; href=&#34;#%e8%a7%a3%e6%b3%95%e6%a6%82%e8%bf%b0&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;先将数组分成两个小数组，这两个小数组中必定有一个是有序的，而另一个是循环有序的。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;对于有序的小数组，我们可以通过首尾值判断要找的值是否在该数组中，如果是，则用二分法处理该有序数组；如果否，我们则对另一个环循有序小数组进行第一步的处理。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;实例&#34;&gt;实例&lt;a class=&#34;anchor&#34; href=&#34;#%e5%ae%9e%e4%be%8b&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func binaryFind(arr []int, start int, end int, v int) int {&#xA;&#x9;center := (start+end)/2&#xA;&#x9;if v &amp;lt; arr[center] {&#xA;&#x9;&#x9;return binaryFind(arr, start, center-1, v)&#xA;&#x9;}else if arr[center] &amp;lt; v {&#xA;&#x9;&#x9;return binaryFind(arr, center+1, end, v)&#xA;&#x9;}else{&#xA;&#x9;&#x9;if arr[center] == v {&#xA;&#x9;&#x9;&#x9;return center&#xA;&#x9;&#x9;}else{&#xA;&#x9;&#x9;&#x9;return -1&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;}&#xA;&#xA;func getIndex(arr []int, start int, end int, v int) int {&#xA;&#x9;center := (start+end)/2&#xA;&#x9;if arr[start] &amp;lt; arr[center] {&#xA;&#x9;&#x9;if arr[start] &amp;lt;= v &amp;amp;&amp;amp; v &amp;lt;= arr[center] {&#xA;&#x9;&#x9;&#x9;return binaryFind(arr, start, center, v)&#xA;&#x9;&#x9;}else{&#xA;&#x9;&#x9;&#x9;return getIndex(arr, center+1, end, v)&#xA;&#x9;&#x9;}&#xA;&#x9;}else{&#xA;&#x9;&#x9;if arr[center] &amp;lt;= v &amp;amp;&amp;amp; v &amp;lt;= arr[end] {&#xA;&#x9;&#x9;&#x9;return binaryFind(arr, center, end, v)&#xA;&#x9;&#x9;}else{&#xA;&#x9;&#x9;&#x9;return getIndex(arr, start, center-1, v)&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;}&#xA;&#xA;func main() {&#xA;&#x9;arr := []int{5,6,7,8,9,1,2,3,4}&#xA;&#x9;index := getIndex(arr, 0, len(arr)-1, 3)&#xA;&#x9;println(index)&#xA;}&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/golang/golang-get-package-to-dir.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/golang/golang-get-package-to-dir.html</guid>
      <description>&lt;h1 id=&#34;下载包到指定目录&#34;&gt;下载包到指定目录&lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%8b%e8%bd%bd%e5%8c%85%e5%88%b0%e6%8c%87%e5%ae%9a%e7%9b%ae%e5%bd%95&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;p&gt;在一个go项目中，通常会引很多第三方包，如果想要你的源码在任何地方都能被编译，那么需要将这些包放在项目的vendor目录下，可惜的是&lt;code&gt;go get&lt;/code&gt;命令不能将包下载到指定的目录中去，这就需要先下载到&lt;code&gt;$GOPATH/src/&lt;/code&gt;目录下，再手动铐到vendor下，这能忍吗？&lt;/p&gt;&#xA;&lt;p&gt;这时有两种选，一种是使用govendor命令，但我不喜欢，它的运行本身会依赖一个配置文件，还需要我去记一些乱七八糟的命令，另一种思路是先创建一个空的临时的GOPATH目录，将需要的包用&lt;code&gt;go get&lt;/code&gt;下载进入，然后将所有的包铐出来，可以写个简单的脚本来做。&lt;/p&gt;&#xA;&lt;p&gt;假设我现在要下载一个golang包&lt;code&gt;github.com/coreos/etcd/client&lt;/code&gt;到当前项目的vendor目录下，执行以下命令：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;mkdir /tmp/go/{bin,pkg,src}&#xA;GOPATH=/tmp/go go get -v github.com/coreos/etcd/client&#xA;/bin/mv -rf /tmp/go/src/* vendor/&#xA;/bin/rm -rf /tmp/go&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/golang/golang-grpc-demo.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/golang/golang-grpc-demo.html</guid>
      <description>&lt;h1 id=&#34;grpc使用指南&#34;&gt;gRPC使用指南&lt;a class=&#34;anchor&#34; href=&#34;#grpc%e4%bd%bf%e7%94%a8%e6%8c%87%e5%8d%97&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;p&gt;gRPC是一个由google开源的RPC框架，它支持多种语言之间的相互调用，依赖开源项目&lt;code&gt;google/protobuf&lt;/code&gt;作为序列化工具。&lt;/p&gt;&#xA;&lt;p&gt;相比于几年前的gRPC，新版gRPC的使用方式发生了一些改变，编译&lt;code&gt;.proto&lt;/code&gt;文件时所用的命令已经与之前不同，而且产生的&lt;code&gt;.go&lt;/code&gt;文件按照数据结构序列化和使用接口分为两个文件。&lt;/p&gt;&#xA;&lt;h2 id=&#34;准备环境&#34;&gt;准备环境&lt;a class=&#34;anchor&#34; href=&#34;#%e5%87%86%e5%a4%87%e7%8e%af%e5%a2%83&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;安装golang&#34;&gt;安装Golang&lt;a class=&#34;anchor&#34; href=&#34;#%e5%ae%89%e8%a3%85golang&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;p&gt;安装&lt;a href=&#34;https://golang.org/dl/&#34;&gt;最新版Golang&lt;/a&gt;。&lt;/p&gt;&#xA;&lt;h3 id=&#34;安装protocol-buffers编译器&#34;&gt;安装Protocol Buffers编译器&lt;a class=&#34;anchor&#34; href=&#34;#%e5%ae%89%e8%a3%85protocol-buffers%e7%bc%96%e8%af%91%e5%99%a8&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;p&gt;&lt;code&gt;protoc&lt;/code&gt;是一个二进制文件，用来编译&lt;code&gt;.proto&lt;/code&gt;文件，输出指定语言的源码。进入&lt;a href=&#34;https://github.com/google/protobuf/releases&#34;&gt;&lt;code&gt;protoc&lt;/code&gt;发布页面&lt;/a&gt;，按照自己的平台下载相应压缩包，比如64位linux就下载&lt;a href=&#34;https://github.com/protocolbuffers/protobuf/releases/download/v3.13.0/protoc-3.13.0-linux-x86_64.zip&#34;&gt;&lt;code&gt;protoc-3.13.0-linux-x86_64.zip&lt;/code&gt;&lt;/a&gt;，解压后把二进制文件放到&lt;code&gt;$GOPATH/bin&lt;/code&gt;下。&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ protoc --version&#xA;libprotoc 3.13.0&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;安装protocol-buffers-go插件&#34;&gt;安装Protocol Buffers GO插件&lt;a class=&#34;anchor&#34; href=&#34;#%e5%ae%89%e8%a3%85protocol-buffers-go%e6%8f%92%e4%bb%b6&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;p&gt;&lt;code&gt;protoc-gen-go&lt;/code&gt;和&lt;code&gt;protoc-gen-go-grpc&lt;/code&gt;两个二进制文件会被&lt;code&gt;protoc&lt;/code&gt;调用，前者用于从&lt;code&gt;.proto&lt;/code&gt;文件中编译出Go语言数据结构，这些数据结构带有序列化函数，后者用于产生Go语言编程接口。&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go get google.golang.org/protobuf/cmd/protoc-gen-go \&#xA;    google.golang.org/grpc/cmd/protoc-gen-go-grpc&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;添加golang依赖&#34;&gt;添加Golang依赖&lt;a class=&#34;anchor&#34; href=&#34;#%e6%b7%bb%e5%8a%a0golang%e4%be%9d%e8%b5%96&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;p&gt;执行前确保项目中包含了&lt;code&gt;go.mod&lt;/code&gt;文件。&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go get google.golang.org/grpc&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;编写一个demo&#34;&gt;编写一个Demo&lt;a class=&#34;anchor&#34; href=&#34;#%e7%bc%96%e5%86%99%e4%b8%80%e4%b8%aademo&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;新建一个名为grpc的Golang项目，结构如下：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;grpc&#xA;├── client&#xA;│   └── main.go&#xA;├── proto&#xA;│   ├── grpc_grpc.pb.go&#xA;│   ├── grpc.pb.go&#xA;│   └── grpc.proto&#xA;└── server&#xA;    └── main.go&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;编写proto文件&#34;&gt;编写.proto文件&lt;a class=&#34;anchor&#34; href=&#34;#%e7%bc%96%e5%86%99proto%e6%96%87%e4%bb%b6&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;p&gt;&lt;code&gt;grpc/proto/grpc.proto&lt;/code&gt;&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ssyntax = &amp;#34;proto3&amp;#34;;&#xA;&#xA;package proto;&#xA;&#xA;option go_package = &amp;#34;github.com/sycki/examples/grpc&amp;#34;;&#xA;&#xA;// 定义一个RPC Server&#xA;// 包含两个函数可供Client调用&#xA;service Greeter {&#xA;  rpc AddUser (UserRequest) returns (UserResponse);&#xA;  rpc GetUser (UserRequest) returns (UserResponse);&#xA;}&#xA;// 调用时的数据格式&#xA;message UserRequest {&#xA;&#x9;string Name = 1;&#xA;&#x9;int32 age = 2;&#xA;&#x9;string address = 3;&#xA;}&#xA;// 返回值的数据格式&#xA;message UserResponse {&#xA;&#x9;string Name = 1;&#xA;&#x9;int32 age = 2;&#xA;&#x9;string address = 3;&#xA;}&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;生成golang代码&#34;&gt;生成Golang代码&lt;a class=&#34;anchor&#34; href=&#34;#%e7%94%9f%e6%88%90golang%e4%bb%a3%e7%a0%81&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;protoc --go_out=. --go_opt=paths=source_relative \&#xA;--go-grpc_out=. --go-grpc_opt=paths=source_relative \&#xA;proto/grpc.proto&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;执行成功会在proto目录下生成两个&lt;code&gt;.go&lt;/code&gt;源文件，一个包含了数据结构，一个包含调用接口。&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/golang/golang-profiler.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/golang/golang-profiler.html</guid>
      <description>&lt;h1 id=&#34;应用性能分析&#34;&gt;应用性能分析&lt;a class=&#34;anchor&#34; href=&#34;#%e5%ba%94%e7%94%a8%e6%80%a7%e8%83%bd%e5%88%86%e6%9e%90&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;p&gt;本文介绍使用pprof工具分析go程序的方法，让你快速找到程序中的性能瓶颈。&lt;/p&gt;&#xA;&lt;h2 id=&#34;基本原理&#34;&gt;基本原理&lt;a class=&#34;anchor&#34; href=&#34;#%e5%9f%ba%e6%9c%ac%e5%8e%9f%e7%90%86&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;在go的安装包中提供了pprof性能分析工具，使用方法为&lt;code&gt;go tool pprof &amp;lt;运行时数据&amp;gt;&lt;/code&gt;，然后它可以根据我们提供的数据分析出程序中各函数据CPU使用情况、内存使用情况、各协程运行情况，其中&amp;lt;运行时数据&amp;gt;的获取有两种方式，一种是让程序在执行时直接保存运行时数据，一种是通过程序的HTTP端口动态获取，这两种方式都需要入侵代码，也就是在目标程序中插入&lt;code&gt;runtime/pprof&lt;/code&gt;或&lt;code&gt;net/http/pprof&lt;/code&gt;两个包的代码来生成pprof工具需要的数据。下面以HTTP方式为例介绍pprof用法。&lt;/p&gt;&#xA;&lt;h2 id=&#34;准备数据&#34;&gt;准备数据&lt;a class=&#34;anchor&#34; href=&#34;#%e5%87%86%e5%a4%87%e6%95%b0%e6%8d%ae&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;只需在目标程序中以匿名方式引入&lt;code&gt;net/http/pprof&lt;/code&gt;包，然后启动一个http服务即可，如下：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;import _ &amp;#34;net/http/pprof&amp;#34;&#xA;func main(){&#xA;&#x9;go func() {&#xA;&#x9;&#x9;logger.Error(http.ListenAndServe(&amp;#34;:8081&amp;#34;, nil))&#xA;&#x9;}()&#xA;&#x9;...&#xA;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后pprof就可以从8081端口上分析程序了。&lt;/p&gt;&#xA;&lt;h2 id=&#34;开始分析&#34;&gt;开始分析&lt;a class=&#34;anchor&#34; href=&#34;#%e5%bc%80%e5%a7%8b%e5%88%86%e6%9e%90&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;这时先在本地安装一个命令行工具，pprof在生成图片时会用到：&lt;code&gt;brew install graphviz&lt;/code&gt;（mac命令）&lt;/p&gt;&#xA;&lt;p&gt;分析CPU性能：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go tool pprof http://localhost:8081/debug/pprof/profile&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;命令执行后会阻塞30秒来收集数据，然后进入一个shell界面，等待输入命令：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Fetching profile over HTTP from http://localhost:8081/debug/pprof/profile&#xA;Saved profile in /Users/sycki/pprof/pprof.samples.cpu.001.pb.gz&#xA;Type: cpu&#xA;Time: Oct 16, 2018 at 6:31pm (CST)&#xA;Duration: 30.01s, Total samples = 240ms (  0.8%)&#xA;Entering interactive mode (type &amp;#34;help&amp;#34; for commands, &amp;#34;o&amp;#34; for options)&#xA;(pprof) png&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这时我们输入&lt;code&gt;png&lt;/code&gt;它就会生成一张png的图片，很清楚的画出占用CPU时间较多函数以及它们关系：&#xA;&lt;img src=&#34;img/golang-profiler/profile001.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;&#xA;&lt;p&gt;分析内存的方法一样：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go tool pprof http://localhost:3999/debug/pprof/heap&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;协程执行情况：&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/golang/golang-regexp-performance.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/golang/golang-regexp-performance.html</guid>
      <description>&lt;h1 id=&#34;正则性能优化&#34;&gt;正则性能优化&lt;a class=&#34;anchor&#34; href=&#34;#%e6%ad%a3%e5%88%99%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;p&gt;最近在编码时用到了golang（版本为&lt;code&gt;1.11.0&lt;/code&gt;）正则库中的&lt;code&gt;ReplaceAllLiteral(data, nil)&lt;/code&gt;函数，发现golang的正则替换比java和php的正则替换慢很多，后来找到了方法，可以大幅度提升golang正则的性能，文章后面部分有具体的对比数据。&lt;/p&gt;&#xA;&lt;h2 id=&#34;golang正则为什么比php慢&#34;&gt;golang正则为什么比php慢&lt;a class=&#34;anchor&#34; href=&#34;#golang%e6%ad%a3%e5%88%99%e4%b8%ba%e4%bb%80%e4%b9%88%e6%af%94php%e6%85%a2&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;我并不是第一个发现golang的正则库比php慢的，因为在golang的开源社区中有人已经提出了类似的问题，见&lt;a href=&#34;https://github.com/golang/go/issues/19629&#34;&gt;issues&lt;/a&gt;，有人回复说：像php、python这样的语言的正则引擎，是用高度优化的C代码实现的，所以比较快。好吧，但java也比golang快至少可以说明golang的正则引擎还是有优化的空间。&lt;/p&gt;&#xA;&lt;h2 id=&#34;提升golang正则性能&#34;&gt;提升golang正则性能&lt;a class=&#34;anchor&#34; href=&#34;#%e6%8f%90%e5%8d%87golang%e6%ad%a3%e5%88%99%e6%80%a7%e8%83%bd&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;后来我现了一个叫&lt;code&gt;rure-go&lt;/code&gt;的项目，详见 &lt;a href=&#34;github.com/BurntSushi/rure-go&#34;&gt;github.com&lt;/a&gt;，这个项目是一个用Rust语言实现的golang正则引擎，原理是先将Rust语言的正则库编译为一个.so动态库，然后用golang语言封装出来一套正则处理函数去调用.so动态库中的函数。&lt;/p&gt;&#xA;&lt;p&gt;具体步骤：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;先安装Rust：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;curl https://sh.rustup.rs -sSf | sh&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;将Rust的正则库编译为动态库（Rust支持交叉编译）：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;git clone git://github.com/rust-lang-nursery/regex&#xA;cargo build --release --manifest-path ./regex/regex-capi/Cargo.toml&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这时在&lt;code&gt;./regex/target/release/&lt;/code&gt;目录下会出现一个.so文件，把它放到你喜欢地方，比如在你的golang项目下新建一个&lt;code&gt;./lib&lt;/code&gt;目录，然后就可以删掉Rust相关的东西了。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;在你的golang项目中引入&lt;code&gt;rure-go&lt;/code&gt;项目，然后编写你的业务逻辑，注意这个包中没有&lt;code&gt;ReplaceAll()&lt;/code&gt;这样的函数，所以要达到&lt;code&gt;ReplaceAll(data, nil)&lt;/code&gt;的效果，需要先用&lt;code&gt;FindAll()&lt;/code&gt;在data中找到所有匹配的位置，然后把所有不匹配的内容提取出来拼到一起。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;编译和运行时需要指定动态库的位置，因为&lt;code&gt;github.com/BurntSushi/rure-go&lt;/code&gt;会依赖它，注意，当指定了动态库后就不能使用go的交叉编译了：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;如果你的电脑是MAC&#xA;编译&#xA;CGO_LDFLAGS=&amp;#34;-L$(pwd)/lib&amp;#34; go build ./your/project/main&#xA;启动&#xA;DYLD_LIBRARY_PATH=./lib ./main&#xA;&#xA;如果你的电脑是Linux&#xA;编译&#xA;CGO_LDFLAGS=&amp;#34;-L$(pwd)/lib&amp;#34; go build ./your/project/main&#xA;启动&#xA;LD_LIBRARY_PATH=./lib ./main&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;性能对比&#34;&gt;性能对比&lt;a class=&#34;anchor&#34; href=&#34;#%e6%80%a7%e8%83%bd%e5%af%b9%e6%af%94&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;对比php&#34;&gt;对比php&lt;a class=&#34;anchor&#34; href=&#34;#%e5%af%b9%e6%af%94php&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;调用次数&lt;/th&gt;&#xA;          &lt;th&gt;php用时(秒)&lt;/th&gt;&#xA;          &lt;th&gt;go优化前(秒)&lt;/th&gt;&#xA;          &lt;th&gt;go优化后(秒)&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;100&lt;/td&gt;&#xA;          &lt;td&gt;3.119&lt;/td&gt;&#xA;          &lt;td&gt;未记录&lt;/td&gt;&#xA;          &lt;td&gt;1.864&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;1000&lt;/td&gt;&#xA;          &lt;td&gt;27.115&lt;/td&gt;&#xA;          &lt;td&gt;45.285&lt;/td&gt;&#xA;          &lt;td&gt;16.475&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;5000&lt;/td&gt;&#xA;          &lt;td&gt;135.88&lt;/td&gt;&#xA;          &lt;td&gt;未记录&lt;/td&gt;&#xA;          &lt;td&gt;82.42&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h3 id=&#34;对比java&#34;&gt;对比java&lt;a class=&#34;anchor&#34; href=&#34;#%e5%af%b9%e6%af%94java&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;调用次数&lt;/th&gt;&#xA;          &lt;th&gt;java用时(秒)&lt;/th&gt;&#xA;          &lt;th&gt;go优化前(秒)&lt;/th&gt;&#xA;          &lt;th&gt;go优化后(秒)&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;1000&lt;/td&gt;&#xA;          &lt;td&gt;5.210&lt;/td&gt;&#xA;          &lt;td&gt;9.399&lt;/td&gt;&#xA;          &lt;td&gt;1.155&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;2000&lt;/td&gt;&#xA;          &lt;td&gt;10.652&lt;/td&gt;&#xA;          &lt;td&gt;18.844&lt;/td&gt;&#xA;          &lt;td&gt;2.286&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;10000&lt;/td&gt;&#xA;          &lt;td&gt;50.156&lt;/td&gt;&#xA;          &lt;td&gt;93.974&lt;/td&gt;&#xA;          &lt;td&gt;11.163&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h2 id=&#34;总结&#34;&gt;总结&lt;a class=&#34;anchor&#34; href=&#34;#%e6%80%bb%e7%bb%93&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;golang标准库中的正则处理引擎性能比较差，如果遇到对性能要求较高的需求，可以用&lt;code&gt;github.com/BurntSushi/rure-go&lt;/code&gt;包代替，它可以大幅提升正则处理性能。&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/golang/golang-tls-web.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/golang/golang-tls-web.html</guid>
      <description>&lt;h1 id=&#34;web应用开发&#34;&gt;web应用开发&lt;a class=&#34;anchor&#34; href=&#34;#web%e5%ba%94%e7%94%a8%e5%bc%80%e5%8f%91&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;p&gt;编写一个基于安全协议的WEB服务器，并将80端口重定向到443端口。&lt;/p&gt;&#xA;&lt;h2 id=&#34;创建一个服务端&#34;&gt;创建一个服务端&lt;a class=&#34;anchor&#34; href=&#34;#%e5%88%9b%e5%bb%ba%e4%b8%80%e4%b8%aa%e6%9c%8d%e5%8a%a1%e7%ab%af&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main&#xA;&#xA;func main() {&#xA;&#x9;// 指定证书文件并启动服务&#xA;&#x9;s := &amp;amp;http.Server{Addr: &amp;#34;:443&amp;#34;, Handler: buildMux()}&#xA;&#x9;go s.ListenAndServeTLS(&amp;#34;/opt/ssl/cert.pem&amp;#34;, &amp;#34;/opt/ssl/privkey.pem&amp;#34;)&#xA;&#xA;&#x9;// 再创建一个监听在80端口的Server，它负责把80上的所有请求重定向到443端口&#xA;&#x9;s80 := &amp;amp;http.Server{Addr: &amp;#34;:80&amp;#34;, Handler: http.HandlerFunc(redirect80), ErrorLog: ctx.GetLogger()}&#xA;&#x9;go s80.ListenAndServe()&#xA;&#xA;&#x9;// 创建一个channel，用来监听kill信号&#xA;&#x9;stop := make(chan string, 1)&#xA;&#x9;defer close(stop)&#xA;&#x9;signal.Notify(sig, os.Interrupt, syscall.SIGTERM)&#xA;&#x9;&amp;lt;-stop&#xA;&#x9;&#xA;&#x9;s.Shutdown(context.Background())&#xA;&#x9;s80.Shutdown(context.Background())&#xA;}&#xA;&#xA;func redirect80(w http.ResponseWriter, r *http.Request) {&#xA;        target := &amp;#34;https://&amp;#34; + r.Host + r.URL.Path&#xA;        if len(r.URL.RawQuery) &amp;gt; 0 {&#xA;                target += &amp;#34;?&amp;#34; + r.URL.RawQuery&#xA;        }&#xA;&#xA;        http.Redirect(w, r, target, http.StatusTemporaryRedirect)&#xA;}&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;uri匹配规则&#34;&gt;URI匹配规则&lt;a class=&#34;anchor&#34; href=&#34;#uri%e5%8c%b9%e9%85%8d%e8%a7%84%e5%88%99&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;下面代码是向ServerMux注册一个Handler：&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/golang/golang-web-and-curl.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/golang/golang-web-and-curl.html</guid>
      <description>&lt;h1 id=&#34;解析客户端参数&#34;&gt;解析客户端参数&lt;a class=&#34;anchor&#34; href=&#34;#%e8%a7%a3%e6%9e%90%e5%ae%a2%e6%88%b7%e7%ab%af%e5%8f%82%e6%95%b0&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;h3 id=&#34;1发送简单键值对&#34;&gt;1.发送简单键值对&lt;a class=&#34;anchor&#34; href=&#34;#1%e5%8f%91%e9%80%81%e7%ae%80%e5%8d%95%e9%94%ae%e5%80%bc%e5%af%b9&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;curl -H &amp;#34;Content-Type: application/x-www-form-urlencoded&amp;#34; \&#xA;-d id=100 \&#xA;-d name=golang \&#xA;localhost/books&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这时curl会把数据拼接为&lt;code&gt;id=100&amp;amp;name=golang&lt;/code&gt;形式放入请求体中，不对数据进行编码，意味着如果数据中含有&lt;code&gt;&amp;amp; ? = @&lt;/code&gt;等符号时，服务端将无法解析出键值对。&lt;/p&gt;&#xA;&lt;h3 id=&#34;服务端解析&#34;&gt;服务端解析&lt;a class=&#34;anchor&#34; href=&#34;#%e6%9c%8d%e5%8a%a1%e7%ab%af%e8%a7%a3%e6%9e%90&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;p&gt;服务端收到请求后发现内容类型为&lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt;，所以当&lt;code&gt;r.ParseForm()&lt;/code&gt;函数被执行时，它会将&lt;code&gt;r.Body&lt;/code&gt;中的数据解析为键值对形式，并保存在map结构中，以便使用&lt;code&gt;r.FormValue()&lt;/code&gt;函数获取。&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func books(w http.ResponseWriter, r *http.Request) {&#xA;    id := r.FormValue(&amp;#34;id&amp;#34;)&#xA;    name := r.FormValue(&amp;#34;name&amp;#34;)&#xA;}&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;2发送编码的键值对&#34;&gt;2.发送编码的键值对&lt;a class=&#34;anchor&#34; href=&#34;#2%e5%8f%91%e9%80%81%e7%bc%96%e7%a0%81%e7%9a%84%e9%94%ae%e5%80%bc%e5%af%b9&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;curl -H &amp;#34;Content-Type: application/x-www-form-urlencoded&amp;#34; \&#xA;localhost/books&#xA;--data-urlencode &amp;#39;id=100&amp;#39; \&#xA;--data-urlencode &amp;#34;bookContent=`&amp;lt;/tmp/book.txt`&amp;#34;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这时curl同样会将所有键值对用&lt;code&gt;&amp;amp;&lt;/code&gt;符号拼接起来，不同的是它会将所有值部分编码为&lt;code&gt;%39%AC+%0B&lt;/code&gt;形式，也就是用三个字节代表一个字节，这样服务端就不会出现解析不了的问题，如果有多个键值对，必须用多个&lt;code&gt;--data-urlencode&lt;/code&gt;标识。&lt;/p&gt;&#xA;&lt;h3 id=&#34;服务端解析-1&#34;&gt;服务端解析&lt;a class=&#34;anchor&#34; href=&#34;#%e6%9c%8d%e5%8a%a1%e7%ab%af%e8%a7%a3%e6%9e%90-1&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;p&gt;服务端收到请求后发现内容类型为&lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt;，所以当&lt;code&gt;r.ParseForm()&lt;/code&gt;函数被执行时，它会将&lt;code&gt;r.Body&lt;/code&gt;中的数据解析为键值对形式，同时所有数据会被解码为原始数据（其实在上一种情况中，数据同样会被解码一次，但解码后的数据与解码前是一样的），然后保存在map结构中，以便使用&lt;code&gt;r.FormValue()&lt;/code&gt;函数获取。&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func books(w http.ResponseWriter, r *http.Request) {&#xA;    id := r.FormValue(&amp;#34;id&amp;#34;)&#xA;    bookContent := r.FormValue(&amp;#34;bookContent&amp;#34;)&#xA;}&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;3发送文件中的数据&#34;&gt;3.发送文件中的数据&lt;a class=&#34;anchor&#34; href=&#34;#3%e5%8f%91%e9%80%81%e6%96%87%e4%bb%b6%e4%b8%ad%e7%9a%84%e6%95%b0%e6%8d%ae&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;curl -H &amp;#34;Content-Type: text/plain&amp;#34; \&#xA;--data-binary @file.txt \&#xA;&amp;#39;localhost/books?id=100&amp;amp;name=book1&amp;#39;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这时我们并不希望我们的数据被服务端当做键对来解析，所以应该用其它字段值来替换&lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt;，比如我们设置为&lt;code&gt;text/plain&lt;/code&gt;或&lt;code&gt;application/json&lt;/code&gt;都是可以的，这里没有用&lt;code&gt;-d&lt;/code&gt;是因为&lt;code&gt;-d&lt;/code&gt;会默认去掉文件内容中所有的&lt;code&gt;\n&lt;/code&gt;和&lt;code&gt;\r&lt;/code&gt;，然后放入请求体中，显然我们并不希望数据被偷偷改掉，所以应该用&lt;code&gt;--data-binary&lt;/code&gt;选项来代替&lt;code&gt;-d&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;h3 id=&#34;服务端解析-2&#34;&gt;服务端解析&lt;a class=&#34;anchor&#34; href=&#34;#%e6%9c%8d%e5%8a%a1%e7%ab%af%e8%a7%a3%e6%9e%90-2&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;p&gt;服务端收到请求后发现内容类型为&lt;code&gt;text/plain&lt;/code&gt;，这时你仍可以执行&lt;code&gt;r.ParseForm()&lt;/code&gt;函数，但它只会解析&lt;code&gt;query&lt;/code&gt;中的参数而不会解析&lt;code&gt;r.Body&lt;/code&gt;中的数据。&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func books(w http.ResponseWriter, r *http.Request) {&#xA;    id := r.FormValue(&amp;#34;id&amp;#34;)&#xA;    name := r.FormValue(&amp;#34;name&amp;#34;)&#xA;    data, _ := ioutil.ReadAll(r.Body)&#xA;}&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;4发送字符串&#34;&gt;4.发送字符串&lt;a class=&#34;anchor&#34; href=&#34;#4%e5%8f%91%e9%80%81%e5%ad%97%e7%ac%a6%e4%b8%b2&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;curl -H &amp;#34;Content-Type: application/json&amp;#34; \&#xA;-d &amp;#39;{&amp;#34;k1&amp;#34;: &amp;#34;v1&amp;#34;}&amp;#39; \&#xA;localhost/books&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这时数据被直接放入请求体，它与&lt;code&gt;text/plain&lt;/code&gt;的行为是一样的。&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/golang/unicode-to-zh.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/golang/unicode-to-zh.html</guid>
      <description>&lt;h1 id=&#34;unicode转中文&#34;&gt;unicode转中文&lt;a class=&#34;anchor&#34; href=&#34;#unicode%e8%bd%ac%e4%b8%ad%e6%96%87&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// unicode2zh 将unicode转为中文，并去掉空格&#xA;func unicode2zh(uText string) (context string) {&#xA;&#x9;for i, char := range strings.Split(uText, `\\u`) {&#xA;&#x9;&#x9;if i &amp;lt; 1 {&#xA;&#x9;&#x9;&#x9;context = char&#xA;&#x9;&#x9;&#x9;continue&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;length := len(char)&#xA;&#x9;&#x9;if length &amp;gt; 3 {&#xA;&#x9;&#x9;&#x9;pre := char[:4]&#xA;&#x9;&#x9;&#x9;zh, err := strconv.ParseInt(pre, 16, 32)&#xA;&#x9;&#x9;&#x9;if err != nil {&#xA;&#x9;&#x9;&#x9;&#x9;context += char&#xA;&#x9;&#x9;&#x9;&#x9;continue&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;context += fmt.Sprintf(&amp;#34;%c&amp;#34;, zh)&#xA;&#xA;&#x9;&#x9;&#x9;if length &amp;gt; 4 {&#xA;&#x9;&#x9;&#x9;&#x9;context += char[4:]&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;}&#xA;&#xA;&#x9;context = strings.TrimSpace(context)&#xA;&#xA;&#x9;return context&#xA;}&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/java/java-from-class-to-machine-code.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/java/java-from-class-to-machine-code.html</guid>
      <description>&lt;h1 id=&#34;java---从class到机器码&#34;&gt;Java - 从CLASS到机器码&lt;a class=&#34;anchor&#34; href=&#34;#java---%e4%bb%8eclass%e5%88%b0%e6%9c%ba%e5%99%a8%e7%a0%81&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;p&gt;你真的了解Java代码的执行过程吗？我们都知道，Java代码是被编译成字节码后被JVM所执行，那JVM又是怎么执行的？不是说CPU只能认识机器码吗？那么从CLASS到机器码之间发生了什么？&lt;/p&gt;&#xA;&lt;p&gt;记得刚开始学Java的时候，老师告诉我们说：“Java是一种解释型语言，我们写的Java代码会被编译成字节码，然后由JVM解释执行”。这样说当然没错啊，只是还不够全面而已。当时在学习Java，同时我也在自学C语言（这么经典的编程语言怎么可以不学），想看看它们之们到底有什么不同之处，后来了解到C语言在被编译时，中间发生了很多事情，最后变成了二进制码，才能被CPU直接执行。可Java呢？老师明明说Java的源码是被编译成了字节码，CPU怎么可能直接认识字节码呢？上网搜了很多资料，都在说Class被JVM加载的过程，千篇一律，这个问题真的困惑我很久，后来有幸看到一篇文章（链接在本文尾部），才渐渐明白了困惑我很久问题。&lt;/p&gt;&#xA;&lt;h2 id=&#34;了解编译过程&#34;&gt;了解编译过程&lt;a class=&#34;anchor&#34; href=&#34;#%e4%ba%86%e8%a7%a3%e7%bc%96%e8%af%91%e8%bf%87%e7%a8%8b&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;我们先简单回顾一下C语言的执行过程： 假设在Linux系统上用GCC编译一个C文件，下面结论只为帮助理解。&lt;/p&gt;&#xA;&lt;p&gt;编写源文件[a.c] -&amp;gt; 预编译 -&amp;gt; [a.i] -&amp;gt; 编译 -&amp;gt; [a.s] -&amp;gt; 汇编（可选） -&amp;gt; [a.o] -&amp;gt; 链接 -&amp;gt; 机器码 -&amp;gt; CPU&lt;/p&gt;&#xA;&lt;p&gt;再回顾一下Java的执行过程： 编写源文件[a.java] -&amp;gt; 编译 -&amp;gt; [a.class/a.jar] -&amp;gt; JVM -&amp;gt; ? -&amp;gt; CPU&lt;/p&gt;&#xA;&lt;p&gt;其中，在编译过程中，也有类似C语言中的链接的过程，比如自定a.java中引用了第三方jar包中的类，那么需要在编译时将这个第三方jar包与a.java打包在一起（类似C中的静态链接），否则需要在运行a.class时，通过指定运行时参数引用到这个第三方jar包（类似C中的动态链接） 关键在class被JVM加载到内存以后，JVM会把字节码翻译成机器码，然后被CPU执行，只不过这一步发生在内存当中，翻译过的机器码也不会被保存在磁盘上（取决于JVM的实现），所以很少有人注意，为会什么JVM的默认实现不把翻译过的机器码保存在磁盘上呢？很简单，虽然是同一个class文件，但放在windowns下翻译出来的机器码跟Linux下翻译出来的机器码并不相同，这样就失去了Java程序的一大特性：可移植性。&lt;/p&gt;&#xA;&lt;h2 id=&#34;jit优化&#34;&gt;JIT优化&lt;a class=&#34;anchor&#34; href=&#34;#jit%e4%bc%98%e5%8c%96&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;说到这里，就得提一提JIT这个东西了，JIT是just in time的缩写, 也就是即时编译编译器，是JVM的一部分，它是的作用是什么呢？上面说过，class字节码是在被CPU执行前翻译成机器码的，那如果我们写了一段循环执行的代码，就这样一句一句翻译再执行必然会很慢，JIT的作用就是把那些需要频繁执行的代码一次性编译成机器码保存在内存当中，这样就避免了大量重复的翻译工作，也就加快了运行速度，而JIT编译代码本身也需要时间，所以那些只需要运行一次的代码则不经过JIT，由解释器解释执行。&lt;/p&gt;&#xA;&lt;p&gt;那什么样的代码才算是“频繁执行的代码”？这里JIT有自己的判断标准，主要由两个计数器决定，一个是方法被调用的次数，另一个是方法中循环被回弹执行的次数，当次数到达一定界限时，该段代码才会被编译，这个阈值可以通过 &lt;code&gt;-XX:CompileThreshold=N&lt;/code&gt; 这个选项指定，默认值为10000 最后再总结一下Java代码被执行的过程： 编写Java源码（示例）：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;int a = 1&#xA;int b = 2&#xA;int c = a + b&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后经过javac命令编译后变成了class文件，如果此时将其反汇编，将看到如下：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;0 iload_1&#xA;1 iload_2&#xA;2 iadd&#xA;3 istore_3&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当这个class被执行时，它在内存中会被一句一句翻成机器码，可能像下面这样：&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/java/java-nio-frame.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/java/java-nio-frame.html</guid>
      <description>&lt;h1 id=&#34;java---nio框架&#34;&gt;Java - NIO框架&lt;a class=&#34;anchor&#34; href=&#34;#java---nio%e6%a1%86%e6%9e%b6&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;什么是-nio&#34;&gt;什么是 NIO&lt;a class=&#34;anchor&#34; href=&#34;#%e4%bb%80%e4%b9%88%e6%98%af-nio&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;为了弥补 Java IO 的不足，Java 从 1.4 版本开始引入了 NIO 框架，也就是说 NIO 是一套新的 IO 框架，一般解释为 Non-blocking IO，有时也解释为 New IO。它可以在实现高并发服务器的同时占用很少的资源。&lt;/p&gt;&#xA;&lt;h2 id=&#34;传统-io-框架&#34;&gt;传统 IO 框架&lt;a class=&#34;anchor&#34; href=&#34;#%e4%bc%a0%e7%bb%9f-io-%e6%a1%86%e6%9e%b6&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;对于传统的 IO 框架，NIO 的优势主要体现在对请求的处理上，下面我们先来看看用传统 IO 怎样建立一个 TCP 连接。 首先创建服务端，并等待新的连接，下面是伪代码：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ServerSocket ser = new ServerSocket(8081);&#xA; &#xA;while (true) {&#xA;     &#xA;    Socket sk = ser.accept();&#xA; &#xA;    startNewThread(sk);&#xA; &#xA;}&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;&#xA;&lt;li&gt;第一行是创建一个服务端对象，并准备监听本机的 8081 端口。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;Socket sk = ser.accept();&lt;/code&gt; 表示开始监听新的连接请求，这行代码是阻塞式的，直到有新的客户端连接过来，会返回一个新 Socket 连接对象。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;startNewThread()&lt;/code&gt; 方法是处理 Socket 连接的主要逻辑，它会创建一个新的线程并立即返回，该线程的工作是一直监听客户端发来的数据，然后作出回应。&lt;/li&gt;&#xA;&lt;li&gt;这时又会回到循环的项部，继续等待新的连接，这就是一个服务端了。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;缺点：乍一看没什么问题，一切都很美好不是吗，但是当连接的请求多了呢，比如几万或者几百万？这样的话就会有几百万个线程同时运行，因为每一个Socket都需要一个线程来监听数据，即使大部分 Socket 都是空闲状态，只有一小部分正在繁忙的交换数据，这一百万个线程如果每个只占用 1M 的内存，那也需要 1T 的内存！这显然不太明智。&lt;/p&gt;&#xA;&lt;h2 id=&#34;nio-框架&#34;&gt;NIO 框架&lt;a class=&#34;anchor&#34; href=&#34;#nio-%e6%a1%86%e6%9e%b6&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;在上例中共有两种监听事件，一种是主线程不断地监听新的连接，另一种是其它子线程监听它所负责的Socket上的数据，那能不能把这些需要监听对象放在一起呢？然后用一个线程或少量几个线程专门负责监听所有对象上的请求？？这样就能节省大量资源啊！实际上这也是完全合理的，并且在新的 IO 框架中就是这么做的！那么我们来看看NIO的实现方式吧。&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/java/netty-guide.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/java/netty-guide.html</guid>
      <description>&lt;h1 id=&#34;java---netty入门&#34;&gt;Java - Netty入门&lt;a class=&#34;anchor&#34; href=&#34;#java---netty%e5%85%a5%e9%97%a8&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;什么是netty&#34;&gt;什么是Netty&lt;a class=&#34;anchor&#34; href=&#34;#%e4%bb%80%e4%b9%88%e6%98%afnetty&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;Netty 是一个高性能高可用的 NIO 框架，并且使用简单，用它可以轻松地开发诸如协议服务器和客户端之类的网络应用程序。它大大简化了网络编程，如 TCP 和 UDP 套接字服务器开发。已经被其它很多项目使用，比如 Spark。&lt;/p&gt;&#xA;&lt;h2 id=&#34;为什么不用-java-标准库中的-nio-框架&#34;&gt;为什么不用 Java 标准库中的 NIO 框架&lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%ba%e4%bb%80%e4%b9%88%e4%b8%8d%e7%94%a8-java-%e6%a0%87%e5%87%86%e5%ba%93%e4%b8%ad%e7%9a%84-nio-%e6%a1%86%e6%9e%b6&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;它实际上是 Java 标准库中的 NIO 框架的一个实现，并将它做成了一个通用框架，最重要的是它经过了很多项目的验证与打磨，现在已经非常稳定，如果项目组要从头开始实现一个这样好用的 NIO 框架成本是很高的，而且还需要长时间的打磨。由于 Netty 是开源项目，社区又很活跃，因此很多项目从一开始就选择 Netty 作为自己的 NIO 框架，以降低开发成本。&lt;/p&gt;&#xA;&lt;h2 id=&#34;开始动手&#34;&gt;开始动手&lt;a class=&#34;anchor&#34; href=&#34;#%e5%bc%80%e5%a7%8b%e5%8a%a8%e6%89%8b&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;我们 Netty 框架来编写一个简易应用程序，并说明它的执行流程，这个程序分为服务端和客户端两个部分，每个部分有两个类。&lt;/p&gt;&#xA;&lt;h2 id=&#34;编写服务端&#34;&gt;编写服务端&lt;a class=&#34;anchor&#34; href=&#34;#%e7%bc%96%e5%86%99%e6%9c%8d%e5%8a%a1%e7%ab%af&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;先来写服务端的主程序 &lt;code&gt;TestServer&lt;/code&gt; 类，其实不是一个类，因为它只包含一个 &lt;code&gt;main&lt;/code&gt; 方法而已：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package com.kxdmmr.demo.netty;&#xA; &#xA;import io.netty.bootstrap.ServerBootstrap;&#xA;...&#xA; &#xA;public class TestServer {&#xA; &#xA;    static final int PORT = Integer.parseInt(System.getProperty(&amp;#34;port&amp;#34;, &amp;#34;8081&amp;#34;));&#xA;    static final int SIZE = Integer.parseInt(System.getProperty(&amp;#34;size&amp;#34;, &amp;#34;128&amp;#34;));&#xA;     &#xA;    public static void main(String[] args) throws Exception {&#xA;        NioEventLoopGroup bossGroup = new NioEventLoopGroup();&#xA;        NioEventLoopGroup workerGroup = new NioEventLoopGroup();&#xA;        try{&#xA;            // 1.创建服务端&#xA;            ServerBootstrap b = new ServerBootstrap();&#xA;            // 2.配置服务端&#xA;            b.group(bossGroup, workerGroup)&#xA;            .channel(NioServerSocketChannel.class)&#xA;            .childHandler(new ChannelInitializer&amp;lt;SocketChannel&amp;gt;() {&#xA;                @Override&#xA;                public void initChannel(SocketChannel ch) throws Exception {&#xA;                    // 注入自定义的处理程序&#xA;                    ch.pipeline().addLast(new TestServerHandler());&#xA;                }&#xA;            })&#xA;            .option(ChannelOption.SO_BACKLOG, SIZE)&#xA;            .childOption(ChannelOption.SO_KEEPALIVE, true);&#xA;             &#xA;            // 3.启动服务端&#xA;            ChannelFuture f = b.bind(PORT).sync();&#xA;             &#xA;            f.channel().closeFuture().sync();&#xA;        } finally {&#xA;            // 停止所有线程池中的线程&#xA;            workerGroup.shutdownGracefully();&#xA;            bossGroup.shutdownGracefully();&#xA;        }&#xA;         &#xA;    }&#xA;}&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;创建服务端的整个过程可以分为三个步骤：1.创建服务端，2.配置服务端，3.启动服务端。&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/kubernetes/docker-auto-test-product.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/kubernetes/docker-auto-test-product.html</guid>
      <description>&lt;h1 id=&#34;产品自动化测试&#34;&gt;产品自动化测试&lt;a class=&#34;anchor&#34; href=&#34;#%e4%ba%a7%e5%93%81%e8%87%aa%e5%8a%a8%e5%8c%96%e6%b5%8b%e8%af%95&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;p&gt;目前公司正在开发大数据平台，在开发过程中，每当发布了新版本时，开发组通知测试组，然后测试组从 Hudson （一个持续集成工具）下载所有的 rpm 包，在测试机上进行安装部署，然后跑测试用例，出测试结果，恢复系统环境以供再次安装测试。这个过程中显然有很多重复性工作，因此，为了缩短产品迭代周期，节省劳动力，我们需要一套自动化测试方案。 本文就笔者目前条件和环境探讨一个可行的方案，不作为具体实现，触类旁通，具体实现还请参考实际情况。&lt;/p&gt;&#xA;&lt;h2 id=&#34;基本思路&#34;&gt;基本思路&lt;a class=&#34;anchor&#34; href=&#34;#%e5%9f%ba%e6%9c%ac%e6%80%9d%e8%b7%af&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;首先，我们需要一个 Linux 集群，这里我们就用 Docker ，这样我们可以快速的创建一个 Linux 集群出来，并且很好的隔离系统环境，不用每次安装完再恢复系统环境。&lt;/li&gt;&#xA;&lt;li&gt;其次是大数据集群的部署，其中每个组件都有那么多的配置项，怎么办？？笔者目前所开发的大数据平台是用 Ambari 来作为集群管理工具，Ambari 是一个主从架构的分布式管理工具，主要有 Seriver 和 Agent 两个服务组成，它的功能包括有集群的创建 、组件的安装与卸载、监控集群状态等等，它还提供了一个功能叫 Ambari Blueprint ，这个功能可以帮我们免去一切人工操作与各组件的配置，并让我们可以更容易地实现将大数据集群的部署与配置脚本化。在这里我们就用它来创建集群。 关于更多 Ambari Blueprint 介绍和使用方法请看本文尾部提供的链接。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;实现步骤&#34;&gt;实现步骤&lt;a class=&#34;anchor&#34; href=&#34;#%e5%ae%9e%e7%8e%b0%e6%ad%a5%e9%aa%a4&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;即然要部署大数据集群，那么安装包从何而来？？我们的大数据平台是用 Hudson 来实现持续集成的，而实现自动化测试的环境是另一台服务器，所以需要远程检测 Hudson 上发布的新版本并下载，这里可以用爬虫方式来检测指定页面上的内容，如果发新有的版本就下载即可。也可以在 Hudson 服务器上写一段小程序，做为一个触发点，每当有版本编译出来就远程通知给测试机，让测试机开始下载。&lt;/li&gt;&#xA;&lt;li&gt;测试机一旦下载成功，便开始创建 Docker 容器，这里我们把容器当作虚拟机来用，所以打算搭建什么规模的集群就创建几个容器，本次我们打算搭建5个节点的集群，所以创建5个容器出来，这里需要注意的是，用来创建容器的镜像最好提前配置好，比如说大数据平台依赖的一些系统配置等等。&lt;/li&gt;&#xA;&lt;li&gt;部署 Ambari，我们刚才创建了一共5个容器，在第一个容器内安装 Ambari-Server 与 Ambari-Agent，其它四个容器只安装 Ambari-Agent 就可以了&lt;/li&gt;&#xA;&lt;li&gt;用 Ambari Blueprint 安装各个组件（如：Haoop、Spark、Hive 等），这里会用到两个 JSON 文件，这两个文件是重中之重，这两个文件作用如下：&#xA;&lt;img src=&#34;img/docker-auto-test-product/docker-auto-test-product_blueprint.jpg&#34; alt=&#34;&#34; /&gt;&#xA;上图中左边是两个 JSON 文件，它们通 http 请求发送给 Ambari-Server 端，然后 Ambari-Server 会根据 JSON 信息创建出一个集群来。&#xA;那么 JSON 从哪来呢，最简单的方法是从一个已安装好的 Ambari 集群导出，像下面这条命令：&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;curl -H &amp;#34;X-Requested-By: ambari&amp;#34; -u admin:admin -X GET \ &#xA;http://$ambari_server_ip:8080/api/v1/clusters/$cluster_name?format=blueprint &amp;gt; blueprint_document.json&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样相当于把当前的集群状态记录下来，而第二个 JSON 文件需要自己定义。下面是两个 JSON 文件中部分示例：&#xA;&lt;img src=&#34;img/docker-auto-test-product/docker-auto-test-product_json-768x456.png&#34; alt=&#34;&#34; /&gt;&#xA;下面开始创建集群，将上面第一个 JSON 文件发送给 Ambari—Server 并注册一个 Blueprint：&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/kubernetes/docker-bigdata-develope.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/kubernetes/docker-bigdata-develope.html</guid>
      <description>&lt;h1 id=&#34;与大数据平台开发&#34;&gt;与大数据平台开发&lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%8e%e5%a4%a7%e6%95%b0%e6%8d%ae%e5%b9%b3%e5%8f%b0%e5%bc%80%e5%8f%91&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;发现问题&#34;&gt;发现问题&lt;a class=&#34;anchor&#34; href=&#34;#%e5%8f%91%e7%8e%b0%e9%97%ae%e9%a2%98&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;场景一 在大数据平台的开发过程中，开发人员通常需要自己有一套集群，以便反复测试自己负责的模块，难道要给每人都配几台机器？ 场景二 测试组需要反复的安装整个平台以便发现问题，而一旦安装就很难再让 Linux 系统恢复到一个干净的状态，或者说需要花费很多时间，那如何快速地恢复系统环境？ 场景三 测试人员在测试中发现了一个 Bug，需要保存现场，可测试还要继续，怎么办？ 场景四 如何把一个部署好的大数据平台快速地迁移到其它地方？&lt;/p&gt;&#xA;&lt;h2 id=&#34;传统解决方案&#34;&gt;传统解决方案&lt;a class=&#34;anchor&#34; href=&#34;#%e4%bc%a0%e7%bb%9f%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;解决这个问题第一个想到的当然是用虚拟机了，而之前也确实用的是虚拟机，但这种方式不能完美的解决以上问题，比如：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;虽然它也可以迁移，但这并不是它所擅长的，不够灵活，很笨重&lt;/li&gt;&#xA;&lt;li&gt;虚拟机的快照可以保存当前的状态，但要恢复回去就得把当前正在运行的虚拟机关闭，并不适合频繁保存当前状态&lt;/li&gt;&#xA;&lt;li&gt;虽然可以给每个人都分配几个虚拟机用，但它是一个完整的系统，本身需要较多的资源，底层物理机的资源很快就被用完了，我们需要寻找其它方式来弥补这些不足&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;docker-技术的引入&#34;&gt;Docker 技术的引入&lt;a class=&#34;anchor&#34; href=&#34;#docker-%e6%8a%80%e6%9c%af%e7%9a%84%e5%bc%95%e5%85%a5&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;Docker 项目的目标是实现轻量级的操作系统虚拟化解决方案，换句话说，它可以让我们把一台物理机虚拟成多台来使用，而且它还可以保修改、完整的迁移到其它地方、性能损耗小等等好处，可以说很好解决了我们的问题。 那为什么不用虚拟机？ 因为它比虚拟机更轻便，Docker容器中不包含操作系统，启动一个Docker容器只要几秒种的时间，在一台物理机上可以创建几百上千个容器，而虚拟做不到。 下面是 Docker 与虚拟机的实现原理图&lt;/p&gt;&#xA;&lt;h3 id=&#34;docker-设计图&#34;&gt;Docker 设计图&lt;a class=&#34;anchor&#34; href=&#34;#docker-%e8%ae%be%e8%ae%a1%e5%9b%be&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;p&gt;&lt;img src=&#34;img/docker-bigdata-develope/docker-bigdata-develope_darch-300x244.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;vm-设计图&#34;&gt;VM 设计图&lt;a class=&#34;anchor&#34; href=&#34;#vm-%e8%ae%be%e8%ae%a1%e5%9b%be&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;p&gt;&lt;img src=&#34;img/docker-bigdata-develope/docker-bigdata-develope_vmarch-272x300.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;&#xA;&lt;p&gt;可见容器是在操作系统层面上实现虚拟化，直接复用本地主机的操作系统，而传统方式则是在硬件层面实现。&lt;/p&gt;&#xA;&lt;h2 id=&#34;环境的搭建&#34;&gt;环境的搭建&lt;a class=&#34;anchor&#34; href=&#34;#%e7%8e%af%e5%a2%83%e7%9a%84%e6%90%ad%e5%bb%ba&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;在实践过程中，部署一套可用的 Docker 环境，必需做好以下前提工作：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;搭建私有镜像仓库，用来统一存放构建好的镜像&lt;/li&gt;&#xA;&lt;li&gt;搭建一个安装包仓库，用来存放我们发布的各种版本的大数据安装包等&lt;/li&gt;&#xA;&lt;li&gt;使多个物理机上的 Dcoker 容器可以相互通信，官方已存给出了方案&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;为平台定制基础镜像&#34;&gt;为平台定制基础镜像&lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%ba%e5%b9%b3%e5%8f%b0%e5%ae%9a%e5%88%b6%e5%9f%ba%e7%a1%80%e9%95%9c%e5%83%8f&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;即然要在Docke容器内安装我们的平台，那就需要一个统一的 Linux 系统做为我们的 Dcoker 容器，比如 Ubuntu、CentOS 等发行商都会发布自己的Docker基础镜像到 Docker Hub 上，如果 Docker Hub 上恰好没有你需要的镜像，也可以自己制作。&lt;/li&gt;&#xA;&lt;li&gt;比如用 CentOS 做为我们的基础镜像，那么先把它 pull 下来&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[user@host1 ~]$ docker pull centos:6.8 &#xA;Using default tag: latest&#xA;latest: Pulling from ubuntu&#xA;8aec416115fd: Extracting [================&amp;gt;                          ] 16.78 MB/50.31 MB&#xA;695f074e24e3: Download complete &#xA;946d6c48c2a7: Download complete &#xA;bc7277e579f0: Verifying Checksum &#xA;...&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;3&#34;&gt;&#xA;&lt;li&gt;然后我们用这个镜像创建一个容器，并在里面配一些我们的大数据平台依赖的参数，比如 ntpd、httpd 服务等等，最终生成我们平台专属的基础镜像。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[user@host1 ~]$ docker run -tid --name build -h build centos:6.8 bash      # 创建一个容器&#xA;f5e71cd81252a3563a03ad8daee81047b62ab5d892ebbfbf71cf53415f29c130&#xA;[user@host1 ~]$ docker exec -ti build bash&#xA;[root@build ~]$ yum install ntpd      # 定制自已的配置&#xA;...&#xA;[root@build ~]$ exit&#xA;[user@host1 ~]$ docker commit build my-centos      # 保存为自已的镜像&#xA;ha256:71cd81252a3563a03ad8daee81047b62ab5d892ebbfbf71cf53415f29c130950&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;4&#34;&gt;&#xA;&lt;li&gt;这是很关键的一步，有了它以后，所有人员可以随时创建一个自己需要的Linux环境出来，以便在其内进行产品的研究和实验，且每个人的环境互不相干，当容器内的环境被破坏后，可以删掉再创建，这样一来，场景一和二所遇到的问题也就迎刃面解。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;将已经部署好的集群做成镜像&#34;&gt;将已经部署好的集群做成镜像&lt;a class=&#34;anchor&#34; href=&#34;#%e5%b0%86%e5%b7%b2%e7%bb%8f%e9%83%a8%e7%bd%b2%e5%a5%bd%e7%9a%84%e9%9b%86%e7%be%a4%e5%81%9a%e6%88%90%e9%95%9c%e5%83%8f&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;我们可以把已经部署了集群的容器保存成多种镜像，如：只包含了 Hadoop 的集群、同时包含 Hadoop、Zookeeper、Hbase 的集群，或安装了所有组件的集群等等，然后上传到私有仓库，其它人需要的时候，直接启动自已需要的集群就可以了，因为免去了部暑与配置等步骤，因而大幅度提高了工作效率，也提高了产品迭代速度。&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/kubernetes/docker-build-centos65.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/kubernetes/docker-build-centos65.html</guid>
      <description>&lt;h1 id=&#34;手工构建基础镜像&#34;&gt;手工构建基础镜像&lt;a class=&#34;anchor&#34; href=&#34;#%e6%89%8b%e5%b7%a5%e6%9e%84%e5%bb%ba%e5%9f%ba%e7%a1%80%e9%95%9c%e5%83%8f&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;p&gt;前段时间，老大说要把目前正在开发的产品放在Docker容器中跑，而且容器的系统版本必须跟开发一致（CentOS6.5），然后我跑去Docker Hub上找一圈，发现Centos官方并没有提供这个版本！纳尼？？开什么玩笑？好吧，然后又搜了一圈，找到了下面这个链接，解释了为什么没有CentOS6.5： &lt;a href=&#34;https://github.com/CentOS/sig-cloud-instance-images/issues/13&#34;&gt;https://github.com/CentOS/sig-cloud-instance-images/issues/13&lt;/a&gt; ，大意是说，官方觉得没必要用CentOS6.5，因为有更高的版本能可以用，并且修复了低版本中的Bug，如果他们提供了6.5的版本，那可能还需要提供6.4，6.3等等，所以直接就不提供低版本了。&lt;/p&gt;&#xA;&lt;p&gt;好吧，但最终要用哪个版本不是我说了算的，然后上Docker官网看看怎么手动构建自已的基础镜像，不幸的是，它虽提供了构建CentOS的基础镜像，但并不能构建出6.5版本的，于是乎又是一顿google，最终还是找到一个比较靠谱的文章，英文，且简略，地址我写在本文最后的部分，下面是我结合自已的需求构建镜像的全部过程。&lt;/p&gt;&#xA;&lt;h2 id=&#34;需要的环境&#34;&gt;需要的环境&lt;a class=&#34;anchor&#34; href=&#34;#%e9%9c%80%e8%a6%81%e7%9a%84%e7%8e%af%e5%a2%83&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;一个正常运行的CentOS6.5系统，这里我用的是我们产品的开发环境系统&lt;/li&gt;&#xA;&lt;li&gt;可以联外网，因为要下载东西3. 一个CentOS6.5的yum源，这里我用的是一个ISO文件直接mount到本地就可以用了&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;开始构建&#34;&gt;开始构建&lt;a class=&#34;anchor&#34; href=&#34;#%e5%bc%80%e5%a7%8b%e6%9e%84%e5%bb%ba&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;安装febootstrap与xz&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;yum install -y febootstrap xz&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;挂载自己的repo镜像，以下是一个例子：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;mount -t iso9660 -o loop /data/CentOS-6.5-x86_64-DVD.iso /data/iso&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;另注：如果你没有这样的iso文件，可以去CentOS官方下载一个，下载这个就行：&lt;code&gt;CentOS-6.5-x86_64-minimal.iso&lt;/code&gt;，然后按以上方式挂载。 当然，如果你有自已的yum源服务器也可以，那它应该长这个样子：&lt;code&gt;http://your.host.com/repodir&lt;/code&gt;，或者这样子：&lt;code&gt;file:///var/www/html/repodir&lt;/code&gt;。&#xA;开始生成镜像文件夹&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;febootstrap -i bash -i coreutils -i tar -ai bzip2 -i gzip \&#xA;-i vim-minimal -i wget -i patch -i diffutils -i iproute \&#xA;-i yum centos6.5 centos6.5-base-image file:///data/iso&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;说明：&#xA;&lt;code&gt;file:///data/iso&lt;/code&gt;：自己的repo源&#xA;&lt;code&gt;centos6.5&lt;/code&gt;：镜像版本&#xA;&lt;code&gt;centos6.5-base-image&lt;/code&gt;：文件夹名字&lt;/p&gt;&#xA;&lt;p&gt;在文件夹内创建三个文件&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;touch centos6.5-base-ks/etc/resolv.conf touch centos6.5-base-ks/sbin/init echo -e &amp;#39;NETWORKING=yes\nHOSTNAME=build&amp;#39; /etc/sysconfig/network&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;打包文件夹&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;tar --numeric-owner -Jcpf centos6.5-base.tar.xz -C centos6.5-base-image . &lt;/code&gt;&lt;/pre&gt;&lt;p&gt;把打包好的文件发送到Docker环境下，并导入到Docker&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;scp centos6.5-base.tar.xz docker.host.com:/root&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后去对应的机器上（docker.host.com），把包导入到Docker，使之成为一个Docker镜像&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/kubernetes/docker-code-create-container.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/kubernetes/docker-code-create-container.html</guid>
      <description>&lt;h1 id=&#34;docker源码-创建容器&#34;&gt;DOCKER源码-创建容器&lt;a class=&#34;anchor&#34; href=&#34;#docker%e6%ba%90%e7%a0%81-%e5%88%9b%e5%bb%ba%e5%ae%b9%e5%99%a8&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;h3 id=&#34;daemon结构体&#34;&gt;Daemon结构体&lt;a class=&#34;anchor&#34; href=&#34;#daemon%e7%bb%93%e6%9e%84%e4%bd%93&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;p&gt;&lt;code&gt;daemon/daemon.go&lt;/code&gt;&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type Daemon struct {&#xA;    // ... 省略多行 ...&#xA;    containerdCli         *containerd.Client&#xA;    containerd            libcontainerdtypes.Client&#xA;    volumes           *volumesservice.VolumesService&#xA;    // ... 省略多行 ...&#xA;}&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;client结构体&#34;&gt;client结构体&lt;a class=&#34;anchor&#34; href=&#34;#client%e7%bb%93%e6%9e%84%e4%bd%93&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;p&gt;Daemon中的containerd字段负责容器相关操作，Daemon对象所有对容器的操作都是通过调用containerd对象相应函数来完成的，它是一个接口，相应的实现定义在&lt;code&gt;libcontainerd/remote/client.go&lt;/code&gt;文件中，它具有以下函数（只列出部分）：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func (c *client) Version(ctx context.Context) (containerd.Version, error)&#xA;&#xA;func (c *client) Restore(ctx context.Context, id string, attachStdio libcontainerdtypes.StdioCallback) (alive bool, pid int, p libcontainerdtypes.Process, err error)&#xA;&#xA;func (c *client) Create(ctx context.Context, id string, ociSpec *specs.Spec, runtimeOptions interface{}, opts ...containerd.NewContainerOpts) error&#xA;&#xA;func (c *client) Start(ctx context.Context, id, checkpointDir string, withStdin bool, attachStdio libcontainerdtypes.StdioCallback) (int, error)&#xA;&#xA;func (c *client) Exec(ctx context.Context, containerID, processID string, spec *specs.Process, withStdin bool, attachStdio libcontainerdtypes.StdioCallback) (int, error)&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;client结构体-1&#34;&gt;Client结构体&lt;a class=&#34;anchor&#34; href=&#34;#client%e7%bb%93%e6%9e%84%e4%bd%93-1&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;p&gt;client结构体是一个较高层的封装，它在实例化的时候依赖Client结构体，而Client结构体实际是一个RPC客户端，所有容器操作都是通过RPC调用containerd进程，关键代码：&#xA;&lt;code&gt;vendor/github.com/containerd/containerd/api/services/containers/v1/containers.pb.go&lt;/code&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/kubernetes/docker-code-create-network.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/kubernetes/docker-code-create-network.html</guid>
      <description>&lt;h1 id=&#34;docker源码-创建网络&#34;&gt;DOCKER源码-创建网络&lt;a class=&#34;anchor&#34; href=&#34;#docker%e6%ba%90%e7%a0%81-%e5%88%9b%e5%bb%ba%e7%bd%91%e7%bb%9c&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;h3 id=&#34;daemon结构体&#34;&gt;Daemon结构体&lt;a class=&#34;anchor&#34; href=&#34;#daemon%e7%bb%93%e6%9e%84%e4%bd%93&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;p&gt;&lt;code&gt;daemon/daemon.go&lt;/code&gt;&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type Daemon struct {&#xA;    // ... 省略多行 ...&#xA;    EventsService     *events.Events&#xA;    netController     libnetwork.NetworkController&#xA;    volumes           *volumesservice.VolumesService&#xA;    discoveryWatcher  discovery.Reloader&#xA;    // ... 省略多行 ...&#xA;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Daemon中的netController字段负责网络相关操作，它是一个接口，其接口的定义和实现都在&lt;code&gt;vendor/github.com/docker/libnetwork/controller.go&lt;/code&gt;文件中。&lt;/p&gt;&#xA;&lt;h3 id=&#34;controller结构体&#34;&gt;controller结构体&lt;a class=&#34;anchor&#34; href=&#34;#controller%e7%bb%93%e6%9e%84%e4%bd%93&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;p&gt;controller结构体实现了libnetwork.NetworkController接口，Daemon对象的对网络设备的增删改查都是调用controller对象的相关函数，其中创建网络的关键函数如下：&#xA;&lt;code&gt;vendor/github.com/docker/libnetwork/controller.go&lt;/code&gt;&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func (c *controller) NewNetwork(networkType, name string, id string, options ...NetworkOption) (Network, error) {&#xA;    // ... 省略多行 ...&#xA;    network := &amp;amp;network{&#xA;        name:             name,&#xA;        networkType:      networkType,&#xA;        generic:          map[string]interface{}{netlabel.GenericData: make(map[string]string)},&#xA;        ipamType:         defaultIpam,&#xA;        id:               id,&#xA;        created:          time.Now(),&#xA;        ctrlr:            c,&#xA;        persist:          true,&#xA;        drvOnce:          &amp;amp;sync.Once{},&#xA;        loadBalancerMode: loadBalancerModeDefault,&#xA;    }&#xA;    // ... 省略多行 ...&#xA;    err = c.addNetwork(network)&#xA;    // ... 省略多行 ...&#xA;    return network, nil&#xA;}&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;根据驱动创建网络&#34;&gt;根据驱动创建网络&lt;a class=&#34;anchor&#34; href=&#34;#%e6%a0%b9%e6%8d%ae%e9%a9%b1%e5%8a%a8%e5%88%9b%e5%bb%ba%e7%bd%91%e7%bb%9c&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;p&gt;addNetwork()函数中先根据network对象的网络类型获取相应的驱动，然后调用该驱动对象的&lt;code&gt;d.CreateNetwork()&lt;/code&gt;函数：&#xA;&lt;code&gt;vendor/github.com/docker/libnetwork/controller.go&lt;/code&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/kubernetes/docker-code-start-dockerd.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/kubernetes/docker-code-start-dockerd.html</guid>
      <description>&lt;h1 id=&#34;docker源码-启动流程&#34;&gt;DOCKER源码-启动流程&lt;a class=&#34;anchor&#34; href=&#34;#docker%e6%ba%90%e7%a0%81-%e5%90%af%e5%8a%a8%e6%b5%81%e7%a8%8b&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;h3 id=&#34;dockerd启动流程&#34;&gt;dockerd启动流程&lt;a class=&#34;anchor&#34; href=&#34;#dockerd%e5%90%af%e5%8a%a8%e6%b5%81%e7%a8%8b&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;当用户执行命令&lt;code&gt;systemctl start docker&lt;/code&gt;后，systemd检查docker配置文件&lt;code&gt;/usr/lib/systemd/system/docker.service&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;因为docker配置文件中定义了&lt;code&gt;BindsTo=containerd.service&lt;/code&gt;，所以containerd将先启动。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;如果containerd启动失败，那么dockerd也将启动失败。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;containerd启动成功后，dockerd二进制文件开始启动，开始执行main()函数。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;dockerd程序的main函数所在文件：&lt;code&gt;cmd/dockerd/docker.go&lt;/code&gt;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;main函数中的调用的&lt;code&gt;newDaemonCommand()&lt;/code&gt;函数用于构建一个Command对象，该对象定义如下：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;cmd := &amp;amp;cobra.Command{&#xA;        Use:           &amp;#34;dockerd [OPTIONS]&amp;#34;,&#xA;        Short:         &amp;#34;A self-sufficient runtime for containers.&amp;#34;,&#xA;        SilenceUsage:  true,&#xA;        SilenceErrors: true,&#xA;        Args:          cli.NoArgs,&#xA;        RunE: func(cmd *cobra.Command, args []string) error {&#xA;            opts.flags = cmd.Flags()&#xA;            return runDaemon(opts)&#xA;        },&#xA;        DisableFlagsInUseLine: true,&#xA;        Version:               fmt.Sprintf(&amp;#34;%s, build %s&amp;#34;, dockerversion.Version, dockerversion.GitCommit),&#xA;    }&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Command对象中的RunE字段就是用来启动dockerd的函数，它最终调用了&lt;code&gt;DaemonCli.start()&lt;/code&gt;函数，DaemonCli定义：&#xA;&lt;code&gt;cmd/dockerd/daemon.go&lt;/code&gt;&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type DaemonCli struct {&#xA;    *config.Config&#xA;    configFile *string&#xA;    flags      *pflag.FlagSet&#xA;    api             *apiserver.Server&#xA;    d               *daemon.Daemon&#xA;    authzMiddleware *authorization.Middleware&#xA;}&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;而&lt;code&gt;DaemonCli&lt;/code&gt;实例中的&lt;code&gt;start()&lt;/code&gt;函数是dockerd启动的主要逻辑，主要包含以下事项：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;从命令行中加载日志相关参数，并配置logrus日志对象&lt;/li&gt;&#xA;&lt;li&gt;根据命令行参数判断是否打开Debug模式，是否打开实验特性&lt;/li&gt;&#xA;&lt;li&gt;创建&lt;code&gt;--data-root&lt;/code&gt;目录&lt;/li&gt;&#xA;&lt;li&gt;创建PID文件&lt;/li&gt;&#xA;&lt;li&gt;是否启用无root模式&lt;/li&gt;&#xA;&lt;li&gt;加载API Server相关配置，包括证书&lt;/li&gt;&#xA;&lt;li&gt;创建API Server，但现在不启动&lt;/li&gt;&#xA;&lt;li&gt;创建一个协程与containerd保持心跳，如果连接containerd失败，则dockerd启动失败&lt;/li&gt;&#xA;&lt;li&gt;监听信号量并设置hook函数用于释放DaemonCli对象&lt;/li&gt;&#xA;&lt;li&gt;创建Daemon实例，创建Daemon的过程中创建了几个重要对象（这里只列出部分，后面会细讲）：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;containerd：负责容器相关操作，且依赖一个RPC客户端，大部分容器相关操作都通过RPC调用containerd进程来完成&lt;/li&gt;&#xA;&lt;li&gt;volumes：负责volume的创建、查找、删除等&lt;/li&gt;&#xA;&lt;li&gt;imageService：负责镜像相关操作&lt;/li&gt;&#xA;&lt;li&gt;netController：负责网络设备的相关操作&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;将Daemon对象放入DaemonCli对象中&lt;/li&gt;&#xA;&lt;li&gt;启动Metrics服务，默认地址：unix:/var/run/docker/metrics.sock&lt;/li&gt;&#xA;&lt;li&gt;如果之前配置过swarm的话，则重新加入集群，并启动集群总的服务&lt;/li&gt;&#xA;&lt;li&gt;构建API路由：用Daemon对象中包含的各核心功能与API Path对应起来&lt;/li&gt;&#xA;&lt;li&gt;启动API Server，默认地址：unix:/var/run/docker.sock&lt;/li&gt;&#xA;&lt;li&gt;阻塞直到API Server协程发生错误或完成退出后，结束各个协程&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;daemon结构体&#34;&gt;Daemon结构体&lt;a class=&#34;anchor&#34; href=&#34;#daemon%e7%bb%93%e6%9e%84%e4%bd%93&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;p&gt;以下是Daemon结构体的定义，在19.03.7版本中包含40个字段，下面我们只分析几个重要字段：&#xA;&lt;code&gt;daemon/daemon.go&lt;/code&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/kubernetes/docker-config-direct-lvm.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/kubernetes/docker-config-direct-lvm.html</guid>
      <description>&lt;h1 id=&#34;配置direct-lvm&#34;&gt;配置direct-lvm&lt;a class=&#34;anchor&#34; href=&#34;#%e9%85%8d%e7%bd%aedirect-lvm&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;关于-docker-存储引擎&#34;&gt;关于 Docker 存储引擎&lt;a class=&#34;anchor&#34; href=&#34;#%e5%85%b3%e4%ba%8e-docker-%e5%ad%98%e5%82%a8%e5%bc%95%e6%93%8e&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;在 CentOS 上安装 Docker 时，默认的存储方式为 devicemapper，而 devicemapper 又有两种模式，默认为 loop-lvm，也就是挂载 loop 设备的方式，在安装 Doccker 后，它会挂载两个 loop 设备用作存储，这两个 loop 设备对应 Docker 安装目录下的两个文件，如下：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[user@ser0 ~]$ sudo losetup -a&#xA;/dev/loop0: [64770]:2164801071 (/var/lib/docker/devicemapper/devicemapper/data)&#xA;/dev/loop1: [64770]:2164801072 (/var/lib/docker/devicemapper/devicemapper/metadata)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;看下它们的大小：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[user@ser0 ~]$ sudo ls -hls /var/lib/docker/devicemapper/devicemapper/&#xA;total 52G&#xA;52G -rw-------. 1 root root 100G Jan 7 07:28 data&#xA;54M -rw-------. 1 root root 2.0G Jan 7 15:28 metadata&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;它的优点是不用过多配置，开箱即用，但性能很差，默认可使用的空间是100G，在使用时有各种问题，官方不推荐这种方式用在生产中，另一种方式是direct-lvm，性能好且稳定，本文将介绍如何配置它。&lt;/p&gt;&#xA;&lt;h2 id=&#34;基本原理&#34;&gt;基本原理&lt;a class=&#34;anchor&#34; href=&#34;#%e5%9f%ba%e6%9c%ac%e5%8e%9f%e7%90%86&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;准备一块单独的磁盘给Docker存储用，逻辑物理均可，用lvm2工具将这块磁盘分为两个逻辑卷，再将这两个逻辑卷转换成thin pool类型，然后配置给Docker。&lt;/p&gt;&#xA;&lt;h2 id=&#34;开始配置&#34;&gt;开始配置&lt;a class=&#34;anchor&#34; href=&#34;#%e5%bc%80%e5%a7%8b%e9%85%8d%e7%bd%ae&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;查看当前存储引擎：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[user@ser0 ~]$ sudo docker info&#xA;...&#xA;Server Version: 1.12.1 Storage Driver: devicemapper&#xA;Pool Name: docker-253:2-6442838537-pool     # 这里表示当前是loop-lvm模式&#xA;Pool Blocksize: 65.54 kB&#xA;Base Device Size: 53.69 GB&#xA;Backing Filesystem: xfs&#xA;Data file: /dev/loop0&#xA;Metadata file: /dev/loop1&#xA;Data Space Used: 55.5 GB&#xA;Data Space Total: 107.4 GB                  # 默认只有100G可用空间，届时将无法创建容器&#xA;Data Space Available: 51.88 GB&#xA;Metadata Space Used: 33.37 MB&#xA;Metadata Space Total: 2.147 GB&#xA;Metadata Space Available: 2.114 GB&#xA;Thin Pool Minimum Free Space: 10.74 GB&#xA;Udev Sync Supported: true&#xA;...&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;查看磁盘使用情况&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/kubernetes/docker-dynamic-port-map.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/kubernetes/docker-dynamic-port-map.html</guid>
      <description>&lt;h1 id=&#34;动态映射端口&#34;&gt;动态映射端口&lt;a class=&#34;anchor&#34; href=&#34;#%e5%8a%a8%e6%80%81%e6%98%a0%e5%b0%84%e7%ab%af%e5%8f%a3&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;p&gt;虽然设计者们一再地强调在使用Docker时要遵循最佳实践，但很多情况下并不能完全做到最佳实践，就比如我们现在的情况，是把Docker当做虚拟机来用，每个容器中包含了很多服务，，，当然，这也带来了很多问题，就比如：要映射很多的端口到物理机。&lt;/p&gt;&#xA;&lt;h2 id=&#34;痛苦的映射问题&#34;&gt;痛苦的映射问题&lt;a class=&#34;anchor&#34; href=&#34;#%e7%97%9b%e8%8b%a6%e7%9a%84%e6%98%a0%e5%b0%84%e9%97%ae%e9%a2%98&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;在启动一个Docker容器时，可以指定-p参数来把容器内的端口映射到宿主机的IP端口上，这样可以很方便地从外界访问容器中的服务，一开始全都是用-p这种方式来做，如果容器中有10个端口需要映射到外面，那就指定10个-p选项，实际上可能更多，如下：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[root@blog ~]# docker run \&#xA;--name node1 \&#xA;-p 10.0.82.43:22:22 \&#xA;-p 10.0.82.43:8080:8080 \&#xA;-p 10.0.82.43:6066:6066 \&#xA;-p 10.0.82.43:7071:7071 \&#xA;-p 10.0.82.43:111:111 \&#xA;-p 10.0.82.43:5005:5005 \&#xA;-p 10.0.82.43:6265:6265 \&#xA;-p 10.0.82.43:7699:7699 \&#xA;...&#xA;-tid node-base &lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后当docker ps的时候会看到整个屏幕被-p参数给占满了，，，好吧，这个不是问题，问题是如果在使用了很久后发现有一个端口没有映射出来！或者是你需要通过Java API远程调用容器中的程序，而又恰好没有映射那个端口，那该怎么办？&lt;/p&gt;&#xA;&lt;h2 id=&#34;映射的实现&#34;&gt;映射的实现&lt;a class=&#34;anchor&#34; href=&#34;#%e6%98%a0%e5%b0%84%e7%9a%84%e5%ae%9e%e7%8e%b0&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;其实Docker run命令中的-p选项，最终是通过宿主机上的iptables来实现的（也许你早就发现了，只是没有仔细研究），在Docker的宿主机上查看一下iptables的nat表，大概会看到下面这样：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[root@blog ~]# iptables -t nat -nvL&#xA;Chain PREROUTING (policy ACCEPT 1082K packets, 173M bytes)&#xA; pkts bytes target     prot opt in     out     source               destination         &#xA;  637 37876 DNAT       tcp  --  *      *       0.0.0.0/0            10.100.124.231       tcp dpt:80 to:10.100.124.231:5000&#xA; 452K   27M DOCKER     all  --  *      *       0.0.0.0/0            0.0.0.0/0            ADDRTYPE match dst-type LOCAL&#xA; &#xA;Chain INPUT (policy ACCEPT 267K packets, 29M bytes)&#xA; pkts bytes target     prot opt in     out     source               destination         &#xA; &#xA;Chain OUTPUT (policy ACCEPT 144K packets, 8644K bytes)&#xA; pkts bytes target     prot opt in     out     source               destination         &#xA;26032 1563K DOCKER     all  --  *      *       0.0.0.0/0           !127.0.0.0/8          ADDRTYPE match dst-type LOCAL&#xA; &#xA;Chain POSTROUTING (policy ACCEPT 144K packets, 8666K bytes)&#xA; pkts bytes target     prot opt in     out     source               destination         &#xA; 108K 7893K MASQUERADE  all  --  *      !docker0  192.11.231.0/24      0.0.0.0/0          &#xA;91402 6409K MASQUERADE  all  --  *      !docker_gwbridge  192.12.231.0/24      0.0.0.0/0          &#xA;    0     0 MASQUERADE  tcp  --  *      *       192.11.231.2         192.11.231.2         tcp dpt:5000&#xA;    0     0 MASQUERADE  tcp  --  *      *       192.11.231.8         192.11.231.8         tcp dpt:8080&#xA;    0     0 MASQUERADE  tcp  --  *      *       192.11.231.8         192.11.231.8         tcp dpt:5005&#xA; &#xA;Chain DOCKER (2 references)&#xA; pkts bytes target     prot opt in     out     source               destination         &#xA;    4   264 RETURN     all  --  docker0 *       0.0.0.0/0            0.0.0.0/0          &#xA;    9   540 RETURN     all  --  docker_gwbridge *       0.0.0.0/0            0.0.0.0/0          &#xA;26315 1579K DNAT       tcp  --  !docker0 *       0.0.0.0/0            10.100.124.231       tcp dpt:5000 to:192.11.231.2:5000&#xA;    0     0 DNAT       tcp  --  !docker0 *       0.0.0.0/0            10.100.124.115       tcp dpt:8080 to:192.11.231.8:8080&#xA;    0     0 DNAT       tcp  --  !docker0 *       0.0.0.0/0            10.100.124.115       tcp dpt:5005 to:192.11.231.8:5005&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;最主要最下面的DOCKER链，最后那三条规则就是在启动容器时指定了-p所导致的，那个5000端口你应该很熟悉，那是Register服务的端口号，我们可以通过它在局域网中上传和下载镜像，而且我在启动它的时候也只映射了这一个端口，如下：&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/kubernetes/docker-multi-host-with-zk.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/kubernetes/docker-multi-host-with-zk.html</guid>
      <description>&lt;h1 id=&#34;多主机通信之zk&#34;&gt;多主机通信之ZK&lt;a class=&#34;anchor&#34; href=&#34;#%e5%a4%9a%e4%b8%bb%e6%9c%ba%e9%80%9a%e4%bf%a1%e4%b9%8bzk&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;p&gt;目前（2016.09.15）公司正在开发一个新产品，每次测试组在部署新版本时，需要先将 Linux 环境配好，卸载后又需要重新配置 Linux 环境，显然中间有很多重复性工作，所以为了加快产品版本迭代速度，减少重复性工作，我们利用Docker来做环境隔离和快速部署。 而为了测试产品性能，又须要运行在多个物理机上，那么Docker如何在多物理机间通信，就是首先要解决的问题。 上网找了很久的资料，大概有以下几种：&lt;/p&gt;&#xA;&lt;p&gt;Swarm模式：这是官方提供的Docker集群模式，且能够跨物理机通信，使用起简单方便，先看一个简单的例子，下面的命令在Swarm集群中创建一个Service：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;docker service create \&#xA;--constraint node.hostname==biyu-c3.com \&#xA;--name sys \&#xA;--replicas 1 \&#xA;--network ingress \&#xA;kxdmmr/centos6.8-ssh bash -c &amp;#39;/usr/sbin/sshd -D&amp;#39;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;而我们启动自已的容器可能要加一些别的参数，比如：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;docker run --privileged=true --ip 19.19.19.19 &#xA;--name hostname -h hostname -p 8080:8080 -p 80:80 &#xA;-v /data/hadoop-data:/data --storage-opt size=30G&#xA;-tid registry.io:5000/centos6.5&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如上，其中的选项：&lt;code&gt;--privileged&lt;/code&gt;、&lt;code&gt;--ip&lt;/code&gt; 在 Swarm 模式中是不提供的，目前也没有办法实现（当然你也可以自已把 Docker 重写了&amp;hellip;），所以不得不另寻它路。&#xA;自己修改网络配置，将 Dockre 网桥与物理机设在同一网段&amp;hellip;，这种方式一看我就头大了，非官方的，太麻烦，且没有保证。&lt;/p&gt;&#xA;&lt;p&gt;用第三方的服务发现工具，Docker 支持的工具有：Consul、Etcd、Zookeeper，官方给了一个列子，是在一个物理机创建多个虚拟机来模拟的，跟在物理机上还是有区别的，而且官方也没有给多更多资料，只好自已摸索了，好在最终用Zookeeper解决了问题。这种方式的好处是，我们在创建和使用容器时，跟以前没有任何区别，启动容器后，各物理机上的容器可以直接通信，且可以使用以前使用的任何选项。下面我们就动手实现一下。&lt;/p&gt;&#xA;&lt;h2 id=&#34;基本原理&#34;&gt;基本原理&lt;a class=&#34;anchor&#34; href=&#34;#%e5%9f%ba%e6%9c%ac%e5%8e%9f%e7%90%86&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;原理就是在物理机上搭建 Zookeeper，然后每个机器上的 Docker daemon 进程将网络配置和每个容器的ip等信息存储到 Zookeeper，具体细节较复杂，笔者没有彻底明白。&lt;/p&gt;&#xA;&lt;h2 id=&#34;环境描述&#34;&gt;环境描述&lt;a class=&#34;anchor&#34; href=&#34;#%e7%8e%af%e5%a2%83%e6%8f%8f%e8%bf%b0&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;硬件环境 机器数量：5&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;100.0.8.27  node27.kxdmmr.com&#xA;100.0.8.28  node28.kxdmmr.com&#xA;100.0.8.29  node29.kxdmmr.com&#xA;100.0.8.30  node30.kxdmmr.com&#xA;100.0.8.31  node31.kxdmmr.com&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;系统环境 系统版本：官方 CentOS 7 内核版本：3.10.0-327.el7.x86_64&#xA;Docker 环境 Docker版本：1.12.1 基础镜像拉取地址：&lt;code&gt;daocloud.io/centos:6&lt;/code&gt; 基础镜像系统版本：centos 6.8&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/kubernetes/docker-registry-deploy-manage.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/kubernetes/docker-registry-deploy-manage.html</guid>
      <description>&lt;h1 id=&#34;私有仓库的搭建与管理&#34;&gt;私有仓库的搭建与管理&lt;a class=&#34;anchor&#34; href=&#34;#%e7%a7%81%e6%9c%89%e4%bb%93%e5%ba%93%e7%9a%84%e6%90%ad%e5%bb%ba%e4%b8%8e%e7%ae%a1%e7%90%86&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;docker-registry-简介&#34;&gt;Docker Registry 简介&lt;a class=&#34;anchor&#34; href=&#34;#docker-registry-%e7%ae%80%e4%bb%8b&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;怎样在几个机器之间使用同一个镜像？难道要先上传到官方的仓库，另几个机器去下载吗？当然不是了，最好的方法就是搭建一个本地的仓库。 Docker Registry 就是官方提供的搭建本地仓库的方案，它有两种搭建方式， http 与 https ，如果你只简单的在本地使用，第一种就足够了，如果考虑到安全方面，就用 https ，这种方式当然就需要为你的仓库服务器申请证书了，或者自建一个证书机构，自已为自已颁发证书。本文只介绍 http 方式，并介绍仓库的上传、下载、查询、删除等常用操作。&lt;/p&gt;&#xA;&lt;h2 id=&#34;环境描述&#34;&gt;环境描述&lt;a class=&#34;anchor&#34; href=&#34;#%e7%8e%af%e5%a2%83%e6%8f%8f%e8%bf%b0&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;假设我有三台机器，他它们的/etc/hosts文件包含如下内容：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[user@ser1 ~]$ cat /etc/hosts&#xA;10.100.100.101  ser1.node.com  registry.io&#xA;10.100.100.102  ser2.node.com&#xA;10.100.100.103  ser3.node.com&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;很显然，我要在第一台机器上部署 Docker Registry ，并且这三台机器都已安装好了Docker服务&lt;/p&gt;&#xA;&lt;h2 id=&#34;docker-registry-搭建&#34;&gt;Docker Registry 搭建&lt;a class=&#34;anchor&#34; href=&#34;#docker-registry-%e6%90%ad%e5%bb%ba&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;官方提供的私有仓库是以镜像像方式提供的，也就是说你只要把这个镜像下载下来启动就可以了，当然还要自已定制一些运行参数。 关于所有可配置项，可以去官网查看，具体地址在本文尾部。&lt;/p&gt;&#xA;&lt;p&gt;在第一台机器上运行官方提供的 Registry 容器&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo mkdir -p /data/docker-registry&#xA;&#xA;docker run -dt \&#xA;--name registry \&#xA;-p 10.100.100.101:5000:5000 \&#xA;--restart=always \&#xA;-v /data/docker-registry:/var/lib/registry \&#xA;-e REGISTRY_STORAGE_DELETE_ENABLED=true \&#xA;-e REGISTRY_STORAGE_DELETE_REDIRECT=true \&#xA;registry:2&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;参数说明：&#xA;&lt;code&gt;-p 10.100.100.101:5000:5000&lt;/code&gt; 这是把容器的端口映射到物理机，这样在其它机器直接访问物理机就相当于访问仓库了&#xA;&lt;code&gt;--restart=always&lt;/code&gt; 这个参数可以让容器在发生意外的时候还可以自已启动，比如当我重启 Docker 服务的时候&#xA;&lt;code&gt;-v /data/docker-registry:/var/lib/registry&lt;/code&gt; 找一个容量大的挂载点映射给容器，用来存放上传的镜像&#xA;&lt;code&gt;-e&lt;/code&gt; 最后这两个是让我们可以远程删除已经上传的镜像&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/kubernetes/docker-with-glusterfs.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/kubernetes/docker-with-glusterfs.html</guid>
      <description>&lt;h1 id=&#34;数据持久化之glusterfs&#34;&gt;数据持久化之GlusterFS&lt;a class=&#34;anchor&#34; href=&#34;#%e6%95%b0%e6%8d%ae%e6%8c%81%e4%b9%85%e5%8c%96%e4%b9%8bglusterfs&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;p&gt;在用 Docker 搭建集群时，遇到一些数据持久化的问题，如果容器内的数据量大的话就不能将数据保存在容器内，否则不方便迁移，而如果使用 Volume 这样的方式挂载，那么假如容器挂掉以后，会在别的物理机上重新启起来（如 Swarm 模式），这样 Volume 方式就不生效了。所以容器内的数据的持久化是个必须解决的问题，相信很多人也遇到了这样的需求，本文就此问题介绍一些解决方法。&lt;/p&gt;&#xA;&lt;h2 id=&#34;关于-glusterfs&#34;&gt;关于 GlusterFS&lt;a class=&#34;anchor&#34; href=&#34;#%e5%85%b3%e4%ba%8e-glusterfs&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;GlusterFS 是一种开源的分布式文件系统，易于横向扩展，性能高，可直接用 Linux 系统的 mount 命令从远程挂载到本地来使用，比如下面一条命令：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;mount -t glusterfs glusterfs.server.com:/src-volume /mnt&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;说明： &lt;code&gt;-t glusterfs&lt;/code&gt; 是指挂载格式为 &lt;code&gt;glusterfs&lt;/code&gt;&#xA;&lt;code&gt;glusterfs.server.com&lt;/code&gt; 是指 glusterfs 服务所在的机器是址，这里换成IP当然也是可以的啦&#xA;&lt;code&gt;/mnt&lt;/code&gt; 是一个本地目录&#xA;这样就将 glusterfs 服务器上的一个卷挂载到本地了，然后就可以直接对 /mnt 下的文件进行存取，是不是感觉很方便？那怎么把它跟 Docker 结合起来呢？有两种方式， Docker 的 plugin 功能和容器内部挂载方式&lt;/p&gt;&#xA;&lt;h2 id=&#34;第一种docker-的-plugin-功能&#34;&gt;第一种：Docker 的 plugin 功能&lt;a class=&#34;anchor&#34; href=&#34;#%e7%ac%ac%e4%b8%80%e7%a7%8ddocker-%e7%9a%84-plugin-%e5%8a%9f%e8%83%bd&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;Docker 本身提供了一个 plugin 的功能模块，允许用户安装各种插件来扩展 Docker 的功能，而 GlusterFS 就是被其支持的插件之一，安装此插件后，就可以在启动容器的时候挂载 GlusterFS 类型的 Volume ，那么具体怎么做呢？&lt;/p&gt;&#xA;&lt;p&gt;部署 GlusterFS 服务，教程网上多的是，这里提供一篇： &lt;a href=&#34;http://navyaijm.blog.51cto.com/4647068/1258250&#34;&gt;http://navyaijm.blog.51cto.com/4647068/1258250&lt;/a&gt; 我们假设有三台主机部署了 GlusterFS ，分别为：&lt;code&gt;gfs-1&lt;/code&gt;、&lt;code&gt;gfs-2&lt;/code&gt;、&lt;code&gt;gfs-3&lt;/code&gt;&lt;/p&gt;&#xA;&lt;p&gt;在你安装有 Docker 的主机上，安装 go 语言环境，如已安装请跳过此步，安装方法请转到： &lt;a href=&#34;https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/01.1.md&#34;&gt;https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/01.1.md&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/kubernetes/k8s-calico.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/kubernetes/k8s-calico.html</guid>
      <description>&lt;h1 id=&#34;calico网络&#34;&gt;calico网络&lt;a class=&#34;anchor&#34; href=&#34;#calico%e7%bd%91%e7%bb%9c&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;什么是calico&#34;&gt;什么是Calico&lt;a class=&#34;anchor&#34; href=&#34;#%e4%bb%80%e4%b9%88%e6%98%afcalico&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;Calico是一个为k8s而设计的基于路由的容器网络解决方案，它的核心思想是把Linux节点当做路由器，用边界网关协议（BGP）将当前节点的路由信息通知给其它节点，来完成各个节点上的路由自动配置。&lt;/p&gt;&#xA;&lt;p&gt;有关BGP的作用和原理请看另一篇文章，&lt;a href=&#34;http://localhost:1313/articles/kubernetes/popular-bgp-protocol&#34;&gt;白话BGP协议&lt;/a&gt;。&lt;/p&gt;&#xA;&lt;h3 id=&#34;calico的组成&#34;&gt;Calico的组成&lt;a class=&#34;anchor&#34; href=&#34;#calico%e7%9a%84%e7%bb%84%e6%88%90&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;p&gt;Calico通常以Daemonset的方式安装到k8s集群中的每个子节点上，Pod的默认名字为calico-node，Pod中包含几个组件：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;BGP Client&lt;/code&gt;：BGP客户端，负责将本机的路由信息通知给其它所有节点，同时接收其它节点发来的信息，端口：179。&lt;code&gt;BGP Client&lt;/code&gt;引用了一个开源的BGP项目，你可以在本文最后找到项目地址&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;calico-felix&lt;/code&gt;：负表将将其它节点发来的路由信息设置到物理机上&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;BGP Route Reflector&lt;/code&gt;：另一个BGP客户端，在集群节点较多时启用此模式，比&lt;code&gt;BGP Client&lt;/code&gt;节省资源&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;工作原理&#34;&gt;工作原理&lt;a class=&#34;anchor&#34; href=&#34;#%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;p&gt;Calico启动后，所有节点上的BGP客户端将自己所在节点的主机名、IP地址、AS号等信息注册到ETCD中，这样所有节点的BGP就可以通过ETCD中的信息找到其它BGP，这时每个BGP定期将自已节点上的路由信息通知给其它所有BGP，其它节点收到信息后进行分析和筛选，将有用的信息通过&lt;code&gt;calico-felix&lt;/code&gt;设置到本地Linux路由表中。&lt;/p&gt;&#xA;&lt;p&gt;通过以下命令查看BGP注册在ETCD中的信息：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;curl -s localhost:2379/v2/keys/calico/bgp/v1/host | jq&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;数据流程&#34;&gt;数据流程&lt;a class=&#34;anchor&#34; href=&#34;#%e6%95%b0%e6%8d%ae%e6%b5%81%e7%a8%8b&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;p&gt;有A和B两台机器，每个机器上各有一个容器X和Y，第个容器中的虚拟网卡eth0分别对应了物理机上的一个虚拟网卡，如下图中所示，容器X中的eth0网卡对应了物理机上的103，这种成对出现的设备叫做veth设备，是Linux系统专门为Namespace（也就是容器技术）设计的，当有数据从一端进入以后会被自动转发到另一端，这样就可以在容器和物理之间方便地交换数据，当我们在k8s中创建一个Pod时，kubelet组件会调用CNI插件来为Pod添加虚拟网卡，veth设备就是在这个时候被创建的。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;img/k8s-calico/calico-data-process.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;&#xA;&lt;p&gt;当X访问Y时，报文先由容器中的&lt;code&gt;eth0@if103&lt;/code&gt;到达物理机上的&lt;code&gt;103: cali103&lt;/code&gt;，然后物理机上会有一条路由（通过命令&lt;code&gt;ip route&lt;/code&gt;查看），告诉系统将目标为2.2.0.0/16这个段的数据包全部转发到5.5.5.3，数据到了B以到，机器B上会有一条路由把目标为2.2.2.2的数据包转发到203网卡上，203同样是一个veth设备，它直接转发给容器中的&lt;code&gt;eth0@if203&lt;/code&gt;网卡，A和B上的两条路由就是由Calico来设置的。&lt;/p&gt;&#xA;&lt;h2 id=&#34;参考与引用&#34;&gt;参考与引用&lt;a class=&#34;anchor&#34; href=&#34;#%e5%8f%82%e8%80%83%e4%b8%8e%e5%bc%95%e7%94%a8&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://docs.projectcalico.org/v2.5/getting-started/kubernetes/installation/hosted/hosted&#34;&gt;Calico官方文档&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://nat.moe/technologies/nat/1256/&#34;&gt;白话BGP协议&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://github.com/osrg/gobgp&#34;&gt;使用GO语言实现的BGP项目&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/kubernetes/k8s-cni.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/kubernetes/k8s-cni.html</guid>
      <description>&lt;h1 id=&#34;k8s-cni&#34;&gt;k8s CNI&lt;a class=&#34;anchor&#34; href=&#34;#k8s-cni&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;cnicontainer-network-interface&#34;&gt;CNI（container network interface）&lt;a class=&#34;anchor&#34; href=&#34;#cnicontainer-network-interface&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;为了将网络功能插件化，k8s要1.5提出了CNI标准，现在我们常用的网络如：flannel、calico等都是基于CNI标准开发的。&lt;/p&gt;&#xA;&lt;h3 id=&#34;kubelet配置cni&#34;&gt;kubelet配置CNI&lt;a class=&#34;anchor&#34; href=&#34;#kubelet%e9%85%8d%e7%bd%aecni&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;--network-plugin=cni&#xA;--cni-bin-dir=/opt/cni/bin&#xA;--cni-conf-dir=/etc/cni/net.d&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;/opt/cni/bin&lt;/code&gt;：CNI插件的存放目录&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;/etc/cni/net.d&lt;/code&gt;：插件的配置文件的存放目录&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;接口定义&#34;&gt;接口定义&lt;a class=&#34;anchor&#34; href=&#34;#%e6%8e%a5%e5%8f%a3%e5%ae%9a%e4%b9%89&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;p&gt;&lt;code&gt;vendor/github.com/containernetworking/cni/libcni/api.go&lt;/code&gt;&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type CNI interface {&#xA;&#x9;AddNetworkList(net *NetworkConfigList, rt *RuntimeConf) (types.Result, error)&#xA;&#x9;DelNetworkList(net *NetworkConfigList, rt *RuntimeConf) error&#xA;&#xA;&#x9;AddNetwork(net *NetworkConfig, rt *RuntimeConf) (types.Result, error)&#xA;&#x9;DelNetwork(net *NetworkConfig, rt *RuntimeConf) error&#xA;}&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;接口实现&#34;&gt;接口实现&lt;a class=&#34;anchor&#34; href=&#34;#%e6%8e%a5%e5%8f%a3%e5%ae%9e%e7%8e%b0&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;p&gt;下面以calico-plugin为例说明CNI的实现，calico-plugin与&lt;a href=&#34;http://localhost:1313/articles/kubernetes/k8s-calico&#34;&gt;calico容器网络&lt;/a&gt;之间没有直接关系，我们通常说的calico指的是这两个东西的组合，而calico容器网络是解决不同物理机上容器之间的通信，而calico-plugin是在k8s创建Pod时为Pod设置虚拟网卡，也就是容器中的&lt;code&gt;eth0&lt;/code&gt;和&lt;code&gt;lo&lt;/code&gt;网卡，calico-plugin是由两个静态的二进制文件组成，由kubelet以命令行的形式调用，这两个二进制的作用如下：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;calico-ipam：分配IP，维护IP池，需要依赖etcd。&lt;/li&gt;&#xA;&lt;li&gt;calico：通过调用系统API来修改namespace中的网卡信息。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;文件在物理机上的位置：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;/opt/cni/&#xA;├── bin&#xA;│   ├── calico&#xA;│   ├── calico-ipam&#xA;└── net.d&#xA;    └── 10-calico.conf&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;calico-plugin在ETCD中维护的信息：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;curl -s localhost:2379/v2/keys/calico/ipam/v2/assignment/ipv4/block | jq&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;calico插件配置&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;vim /opt/cni/net.d/10-calico.conf&#xA;{&#xA;    &amp;#34;name&amp;#34;: &amp;#34;calico-k8s-network&amp;#34;,&#xA;    &amp;#34;cniVersion&amp;#34;: &amp;#34;0.1.0&amp;#34;,&#xA;    &amp;#34;type&amp;#34;: &amp;#34;calico&amp;#34;,&#xA;    &amp;#34;etcd_endpoints&amp;#34;: &amp;#34;http://127.0.0.1:2379&amp;#34;,&#xA;    &amp;#34;log_level&amp;#34;: &amp;#34;info&amp;#34;,&#xA;    &amp;#34;ipam&amp;#34;: {&#xA;        &amp;#34;type&amp;#34;: &amp;#34;calico-ipam&amp;#34;&#xA;    },&#xA;    &amp;#34;kubernetes&amp;#34;: {&#xA;        &amp;#34;kubeconfig&amp;#34;: &amp;#34;/opt/rainbond/kubernetes/kubecfg/admin.kubeconfig&amp;#34;&#xA;    }&#xA;}&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;calico-plugin工作原理&#34;&gt;calico-plugin工作原理&lt;a class=&#34;anchor&#34; href=&#34;#calico-plugin%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;p&gt;kubelet在创建一个Pod时，会先启动puase容器，然后为这个容器添加设置网络，也就是添加网卡，这里会通过CNI调起文件系统中的&lt;code&gt;/opt/cni/bin/calico&lt;/code&gt;，并将Pod信息通过标准输入(stdin)传递给calico进程，calico通过修改系统中Namespace达到为容器添加网卡的目的。&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/kubernetes/k8s-code-apiserver-start.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/kubernetes/k8s-code-apiserver-start.html</guid>
      <description>&lt;h1 id=&#34;k8s源码分析-apiserver&#34;&gt;k8s源码分析-apiserver&lt;a class=&#34;anchor&#34; href=&#34;#k8s%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90-apiserver&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;p&gt;本系列文章是基于kubernetes1.7版本的。&lt;/p&gt;&#xA;&lt;h2 id=&#34;main函数&#34;&gt;main函数&lt;a class=&#34;anchor&#34; href=&#34;#main%e5%87%bd%e6%95%b0&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;apiserver的入口定义在&lt;code&gt;cmd/kube-apiserver/apiserver.go&lt;/code&gt;文件中：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func main() {&#xA;&#x9;rand.Seed(time.Now().UTC().UnixNano())&#xA;&#xA;&#x9;// 创建一个默认配置对象&#xA;&#x9;s := options.NewServerRunOptions()&#xA;&#x9;&#xA;&#x9;// 构建命令行对象&#xA;&#x9;s.AddFlags(pflag.CommandLine)&#xA;&#xA;    // 解析命令行参数&#xA;&#x9;flag.InitFlags()&#xA;&#x9;logs.InitLogs()&#xA;&#x9;defer logs.FlushLogs()&#xA;&#xA;&#x9;// 如果指定了-version选项，则打印版本号然后退出&#xA;&#x9;verflag.PrintAndExitIfRequested()&#xA;&#xA;&#x9;// 启动服务，并从管道中监听停止信号，该通道可能永远不会写入数据&#xA;&#x9;if err := app.Run(s, wait.NeverStop); err != nil {&#xA;&#x9;&#x9;fmt.Fprintf(os.Stderr, &amp;#34;%v\n&amp;#34;, err)&#xA;&#x9;&#x9;os.Exit(1)&#xA;&#x9;}&#xA;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个main函数看起来是比较直观的，中文的注释是我加上去的，便于阅读。&lt;/p&gt;&#xA;&lt;h2 id=&#34;初始化配置&#34;&gt;初始化配置&lt;a class=&#34;anchor&#34; href=&#34;#%e5%88%9d%e5%a7%8b%e5%8c%96%e9%85%8d%e7%bd%ae&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;在main函数中的第一行是为随机数产生器用当前时间提供了一个基数，避免多次启动产生相同的值，说明在这个组件中可能有些功能依赖了随数机。&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;s := options.NewServerRunOptions()&lt;/code&gt;显然是在创建一个配置对象，不过这个对象中只包含一些默认参数。&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;s.AddFlags(pflag.CommandLine)&lt;/code&gt;是构建一个命令行对象，怎么构建的呢，其实就是&lt;code&gt;s&lt;/code&gt;在&lt;code&gt;pflag.CommandLine&lt;/code&gt;这个对象中加了很多选项，并把自己的在很多字段以指针的方式注入到了&lt;code&gt;pflag.CommandLine&lt;/code&gt;中，这些选项是经过分组的，如ETCD相关配置、apiserver相关的请求超时时间等。&lt;/p&gt;&#xA;&lt;p&gt;紧接着&lt;code&gt;flag.InitFlags()&lt;/code&gt;解析所有命令行参数，并通过指针把值放到配置对象&lt;code&gt;s&lt;/code&gt;中。&lt;/p&gt;&#xA;&lt;p&gt;其中&lt;code&gt;flag&lt;/code&gt;这个包是k8s对开源项目&lt;code&gt;github.com/spf13/pflag&lt;/code&gt;的封装，而这个项目又是基于golang标准库中的flag包开发的，并且封装了一些实用的函数，可以让你快速生成自己的命令行选项。&lt;/p&gt;&#xA;&lt;h2 id=&#34;准备资源&#34;&gt;准备资源&lt;a class=&#34;anchor&#34; href=&#34;#%e5%87%86%e5%a4%87%e8%b5%84%e6%ba%90&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;然后调用到了Run()函数，定义在cmd/kube-apiserver/app/server.go文件中，这里代码较多就不全部贴出来了，为了保持文章的可读性，我会尽量减少函数展开的层数。&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;nodeTunneler, proxyTransport, err := CreateNodeDialer(runOptions)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面代码判断是否安装在云主机上，如果是，并且指定了密钥文件，也是就&lt;code&gt;--ssh-keyfile&lt;/code&gt;选项，则安装key到所有云主机的实例中，然后使用该密钥文件创建一个连接器&lt;code&gt;nodeTunneler&lt;/code&gt;，用来访问其它节点。&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;kubeAPIServerConfig, sharedInformers, versionedInformers, insecureServingOptions, serviceResolver, err := CreateKubeAPIServerConfig(runOptions, nodeTunneler, proxyTransport)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这句是利用最初的配置对象&lt;code&gt;runOptions&lt;/code&gt;创建用于启动apiserver的配置对象，与&lt;code&gt;runOptions&lt;/code&gt;不同的是，它还包括了启动apiserver所需的资源。&lt;/p&gt;&#xA;&lt;p&gt;该函数中做了以下几件事：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;根据用户指定的&lt;code&gt;--admission-control&lt;/code&gt;列表加载相应的admission插件，这些插件的作用是用来过滤API请求的，可以用来作请求的合法性检测，比如我们对所有&lt;code&gt;get csr&lt;/code&gt;的请求进行用户验证，如果该用户权限太低则拒绝该请求；也可以修改某个请求，比如为所有&lt;code&gt;create deployments&lt;/code&gt;的请求加上&lt;code&gt;scale=1&lt;/code&gt;等等。默认不加载任何规则。&lt;/li&gt;&#xA;&lt;li&gt;如果有必要的配置没有设置则为其设置默认值，如Service IP段、序列化缓存大小等。&lt;/li&gt;&#xA;&lt;li&gt;验证必要配置项，如果在此阶段有错误配置项，则所有错误信息将被打包返回。&lt;/li&gt;&#xA;&lt;li&gt;如果验证通过则开始连接ETCD，并启动同步信息的进程，该进程会一直监听apiserver的数据并同步到ETCD集群中。&lt;/li&gt;&#xA;&lt;li&gt;最后创建&lt;code&gt;master.Config&lt;/code&gt;对象，也就是&lt;code&gt;kubeAPIServerConfig&lt;/code&gt;变量，然后返回。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;kubeAPIServer, err := CreateKubeAPIServer(kubeAPIServerConfig, apiExtensionsServer.GenericAPIServer, sharedInformers, apiExtensionsConfig.CRDRESTOptionsGetter)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这行代码是比较核心的，它的作用如下：&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/kubernetes/k8s-code-kubelet.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/kubernetes/k8s-code-kubelet.html</guid>
      <description>&lt;h1 id=&#34;k8s源码分析-kubelet&#34;&gt;k8s源码分析-kubelet&lt;a class=&#34;anchor&#34; href=&#34;#k8s%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90-kubelet&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;p&gt;本文以&lt;code&gt;k8s v1.10&lt;/code&gt;为例，分析kubelet组件的工作原理。&lt;/p&gt;&#xA;&lt;h2 id=&#34;入口&#34;&gt;入口&lt;a class=&#34;anchor&#34; href=&#34;#%e5%85%a5%e5%8f%a3&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;main函数定义在&lt;a href=&#34;https://github.com/kubernetes/kubernetes/blob/release-1.10/pkg/kubelet/kubelet.go&#34;&gt;cmd/kubelet/kubelet.go&lt;/a&gt;，主要任务如下：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;创建命令行对象，包括解析用户指定的参数，生成配置对象等&lt;/li&gt;&#xA;&lt;li&gt;执行命令行对象，最后进入启动kubelet的逻辑，调用了kubelet的&lt;code&gt;RunKubelet()&lt;/code&gt;函数&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;创建kubelet&#34;&gt;创建kubelet&lt;a class=&#34;anchor&#34; href=&#34;#%e5%88%9b%e5%bb%bakubelet&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;以下是创建kubelet的关键函数，它创建了docker客户端、网络插件等重要组件：&lt;a href=&#34;https://github.com/kubernetes/kubernetes/blob/release-1.10/pkg/kubelet/kubelet.go#L321&#34;&gt;pkg/kubelet/kubelet.go:321&lt;/a&gt;&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func NewMainKubelet(kubeCfg *kubeletconfiginternal.KubeletConfiguration,&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;初始化容器运行时服务端cri&#34;&gt;初始化容器运行时服务端（CRI）&lt;a class=&#34;anchor&#34; href=&#34;#%e5%88%9d%e5%a7%8b%e5%8c%96%e5%ae%b9%e5%99%a8%e8%bf%90%e8%a1%8c%e6%97%b6%e6%9c%8d%e5%8a%a1%e7%ab%afcri&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;p&gt;在1.5以前的版本中，k8s依赖于dokcer，为了支持不同的容器运行时，比如rkt、containerd，kubelet从1.5开始加入了CRI标准，CRI是一组rpc接口，只要是实现了这组接口都可以作为kubelet的运行时，而且在k8s内部将之前的Pod抽象为一种更为通用的SandBox。&lt;/p&gt;&#xA;&lt;p&gt;调用过程如下：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;kubelet -&amp;gt; remote -&amp;gt; CRI -&amp;gt; dockershim -&amp;gt; docker_client -&amp;gt; docker_daemon&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;提出了CRI标准以后，意味着在新的版本里需要使用新的连接方式与docker通信，为了兼容以前的版本，k8s提供了针对docker的CRI实现，也就是kubelet包下的dockershim包，dockershim是一个rpc服务，监听一个端口供kubelet连接，dockershim收到kubelet的请求后，将其转化为REST API请求，发送给物理机上的docker daemon，以下是创建和启动dockershim的代码：&lt;a href=&#34;https://github.com/kubernetes/kubernetes/blob/release-1.10/pkg/kubelet/kubelet.go#L622&#34;&gt;pkg/kubelet/kubelet.go:NewMainKubelet():622&lt;/a&gt;&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 创建dockershim&#xA;ds, err := dockershim.NewDockerService(kubeDeps.DockerClientConfig, crOptions.PodSandboxImage, streamingConfig,&#xA;...&#xA;// 启动rpc服务&#xA;if err := server.Start(); err != nil {&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;创建Docker客户端的逻辑是在创建dockershim的过程中，关键代码：&lt;a href=&#34;https://github.com/kubernetes/kubernetes/blob/release-1.10/pkg/kubelet/dockershim/libdocker/client.go#L100&#34;&gt;pkg/kubelet/dockershim/libdocker/client.go:100&lt;/a&gt;&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;client, err := getDockerClient(dockerEndpoint)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;client对象就是docker的客户端，包含了我们常用的&lt;code&gt;docker  run&lt;/code&gt;，&lt;code&gt;docker images&lt;/code&gt;等所有操作，&lt;code&gt;dockerEndpoint&lt;/code&gt;就是&lt;code&gt;--container-runtime-endpoint&lt;/code&gt;选项的值，默认是&lt;code&gt;unix:///var/run/docker.sock&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;h3 id=&#34;初始化容器运行时客户端&#34;&gt;初始化容器运行时客户端&lt;a class=&#34;anchor&#34; href=&#34;#%e5%88%9d%e5%a7%8b%e5%8c%96%e5%ae%b9%e5%99%a8%e8%bf%90%e8%a1%8c%e6%97%b6%e5%ae%a2%e6%88%b7%e7%ab%af&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;p&gt;dockershim是rpc的服务端，&lt;code&gt;pkg/kubelet/remote&lt;/code&gt;包是rpc客户端的实现，此包下的函数由kubelet组件调用，创建remote的代码：&lt;a href=&#34;https://github.com/kubernetes/kubernetes/blob/release-1.10/pkg/kubelet/kubelet.go#L657&#34;&gt;pkg/kubelet/kubelet.go:657&lt;/a&gt;&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;runtimeService, imageService, err := getRuntimeAndImageServices(remoteRuntimeEndpoint, remoteImageEndpoint, kubeCfg.RuntimeRequestTimeout)&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;初始化网络插件cni&#34;&gt;初始化网络插件（CNI）&lt;a class=&#34;anchor&#34; href=&#34;#%e5%88%9d%e5%a7%8b%e5%8c%96%e7%bd%91%e7%bb%9c%e6%8f%92%e4%bb%b6cni&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;p&gt;创建CNI实例的逻辑是在创建dockershim的过程中，用来在容器中创建和删除网络设备，关键代码：&lt;a href=&#34;https://github.com/kubernetes/kubernetes/blob/release-1.10/pkg/kubelet/dockershim/docker_service.go#L232&#34;&gt;pkg/kubelet/dockershim/docker_service.go:NewDockerService():232&lt;/a&gt;&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;cniPlugins := cni.ProbeNetworkPlugins(pluginSettings.PluginConfDir, pluginSettings.PluginBinDirs)&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;初始化卷管理器&#34;&gt;初始化卷管理器&lt;a class=&#34;anchor&#34; href=&#34;#%e5%88%9d%e5%a7%8b%e5%8c%96%e5%8d%b7%e7%ae%a1%e7%90%86%e5%99%a8&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;p&gt;卷管理器的作用是检查容器需要的卷是否已挂载，需要卸载的卷是否已经卸载，关键代码：&lt;a href=&#34;https://github.com/kubernetes/kubernetes/blob/release-1.10/pkg/kubelet/kubelet.go#L817&#34;&gt;pkg/kubelet/kubelet.go:NewMainKubelet():817&lt;/a&gt;&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;klet.volumePluginMgr, err =&#xA;&#x9;&#x9;NewInitializedVolumePluginMgr(klet, secretManager, configMapManager, tokenManager, kubeDeps.VolumePlugins, kubeDeps.DynamicPluginProber)&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;初始化pod处理器&#34;&gt;初始化Pod处理器&lt;a class=&#34;anchor&#34; href=&#34;#%e5%88%9d%e5%a7%8b%e5%8c%96pod%e5%a4%84%e7%90%86%e5%99%a8&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;p&gt;创建一个叫worker的对象，它持有处理Pod的入口函数，也是就&lt;code&gt;klet.syncPod&lt;/code&gt;：&lt;a href=&#34;https://github.com/kubernetes/kubernetes/blob/release-1.10/pkg/kubelet/kubelet.go#L854&#34;&gt;pkg/kubelet/kubelet.go:NewMainKubelet():854&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/kubernetes/k8s-code-pod-create.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/kubernetes/k8s-code-pod-create.html</guid>
      <description>&lt;h1 id=&#34;k8s源码分析-创建pod流程&#34;&gt;k8s源码分析-创建Pod流程&lt;a class=&#34;anchor&#34; href=&#34;#k8s%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90-%e5%88%9b%e5%bb%bapod%e6%b5%81%e7%a8%8b&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;p&gt;本文从源码层面解释kubernetes从接收创建Pod的指令到实际创建Pod的整个过程。&lt;/p&gt;&#xA;&lt;h3 id=&#34;11-监听用户请求&#34;&gt;1.1 监听用户请求&lt;a class=&#34;anchor&#34; href=&#34;#11-%e7%9b%91%e5%90%ac%e7%94%a8%e6%88%b7%e8%af%b7%e6%b1%82&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;p&gt;监听的任务是由&lt;code&gt;kube-apiserver&lt;/code&gt;这个组件来完成的，它实际上是一个WEB服务，一般是以双向TLS认证方式启动的，所以在启动时需要提供证书、私钥、客户端的CA证书和CA私钥，当然也支持HTTP的方式，启动后就开始监听用户请求了。&lt;/p&gt;&#xA;&lt;h3 id=&#34;12-对请求分类&#34;&gt;1.2 对请求分类&lt;a class=&#34;anchor&#34; href=&#34;#12-%e5%af%b9%e8%af%b7%e6%b1%82%e5%88%86%e7%b1%bb&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;p&gt;&lt;code&gt;kube-apiserver&lt;/code&gt;中的WEB服务在启动时注册了很多的Handler，golang中的Handler相当于Java中的servlet或者是Spring中的Controller，是对某一业务逻辑的封装，通俗点说，一个Handler负责对一个URI请求的处理，而在&lt;code&gt;kube-apiserver&lt;/code&gt;中，Handler被封装成了一个叫Store的对象，怎么封装的呢？比如&lt;code&gt;/api/v1/namespaces/{namespace}/pods&lt;/code&gt;这个URI对应了一个叫&lt;code&gt;PodStorage&lt;/code&gt;的Store，这个Store中包含了对&lt;code&gt;/api/v1/namespaces/{namespace}/pods&lt;/code&gt;的多个Handler，这些Handler有的是处理创建请求，有的是处理删除请求等等，代表了对一种资源的操作集。&lt;/p&gt;&#xA;&lt;p&gt;我们来看看这个Store的定义：&#xA;&lt;code&gt;staging/src/k8s.io/apiserver/pkg/registry/generic/registry/store.go&lt;/code&gt;&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type Store struct {&#xA;    CreateStrategy rest.RESTCreateStrategy&#xA;    AfterCreate ObjectFunc&#xA;    UpdateStrategy rest.RESTUpdateStrategy&#xA;    AfterUpdate ObjectFunc&#xA;    DeleteStrategy rest.RESTDeleteStrategy&#xA;    AfterDelete ObjectFunc&#xA;...&#xA;}&#xA;&#xA;func (e *Store) Create(ctx genericapirequest.Context, obj runtime.Object, includeUninitialized bool) (runtime.Object, error) {&#xA;&#xA;func (e *Store) Update(ctx genericapirequest.Context, name string, objInfo rest.UpdatedObjectInfo) (runtime.Object, bool, error) {&#xA;...&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;因为每种资源所需要的操作不一样，所以Store中只包含了基本的通用的操作，作为一个基础类。&lt;/p&gt;&#xA;&lt;h3 id=&#34;13-处理请求&#34;&gt;1.3 处理请求&lt;a class=&#34;anchor&#34; href=&#34;#13-%e5%a4%84%e7%90%86%e8%af%b7%e6%b1%82&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;p&gt;在Store的定义中有一个&lt;code&gt;Storage   storage.Interface&lt;/code&gt;字段，Store中的创建、更新、删除等操作，比如上面的&lt;code&gt;Create()&lt;/code&gt;函数中会调用这个对象中的&lt;code&gt;Create()&lt;/code&gt;方法，也就是说这个Storage对象包含了一组更低级的操作，可以看作是数据的持久化层，这些操作都是通用的，而Store可以用Storage中的功能组合出具有不同功能的控制层对象，也就是Store对象啊，，好吧我们距离真相又进了一步，那这个&lt;code&gt;Storage  storage.Interface&lt;/code&gt;对象又是怎样实现的呢？&lt;/p&gt;&#xA;&lt;h3 id=&#34;14-数据存储到etcd&#34;&gt;1.4 数据存储到ETCD&lt;a class=&#34;anchor&#34; href=&#34;#14-%e6%95%b0%e6%8d%ae%e5%ad%98%e5%82%a8%e5%88%b0etcd&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;p&gt;&lt;code&gt;Storage&lt;/code&gt;字段是一个叫&lt;code&gt;Interface&lt;/code&gt;的类型，里面定义了一些数据持久层的操作，这里就不贴出来了，我们更关心它的实现，我们先来看看Interface实例的创建吧，它的创&#xA;建工作是由一个工厂类负责的：&#xA;&lt;code&gt;staging/src/k8s.io/apiserver/pkg/storage/storagebackend/factory/factory.go&lt;/code&gt;&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func Create(c storagebackend.Config) (storage.Interface, DestroyFunc, error) {&#xA;        switch c.Type {&#xA;        case storagebackend.StorageTypeETCD2:&#xA;                return newETCD2Storage(c)&#xA;        case storagebackend.StorageTypeUnset, storagebackend.StorageTypeETCD3:&#xA;                return newETCD3Storage(c)&#xA;        default:&#xA;                return nil, nil, fmt.Errorf(&amp;#34;unknown storage type: %s&amp;#34;, c.Type)&#xA;        }&#xA;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;好吧，看到这里就彻底明白了，根据配置中指定的存储服务创建不同的Storage对象，并且目前只支持ETCD2和ETCD3两种存储服务，持久层所做的增删改查就是对ETCD中&#xA;数据的增删改查，总结一下Storage对象也是就Interface被创建的过程：&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/kubernetes/k8s-code-scheduler-start.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/kubernetes/k8s-code-scheduler-start.html</guid>
      <description>&lt;h1 id=&#34;k8s源码分析-scheduler&#34;&gt;k8s源码分析-scheduler&lt;a class=&#34;anchor&#34; href=&#34;#k8s%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90-scheduler&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;p&gt;本文以kubenetes v1.7为例，说明&lt;code&gt;kube-scheduler&lt;/code&gt;组件的启动流程与工作原理。&lt;/p&gt;&#xA;&lt;h2 id=&#34;入口&#34;&gt;入口&lt;a class=&#34;anchor&#34; href=&#34;#%e5%85%a5%e5%8f%a3&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;scheduler的main函数定义在&lt;code&gt;plugin/cmd/kube-scheduler/scheduler.go&lt;/code&gt;中，main函数代码也比较清晰：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;创建默认配置对象&lt;/li&gt;&#xA;&lt;li&gt;将配置对象的指针传给命令行解析器，然后命令行解析器把解析到的各选项的值写入到配置对象中&lt;/li&gt;&#xA;&lt;li&gt;如果用户指定了&lt;code&gt;version&lt;/code&gt;选项则打印版本信息并退出&lt;/li&gt;&#xA;&lt;li&gt;将配置对象传给&lt;code&gt;Run()&lt;/code&gt;函数，然后就开始启动Scheduler了&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;创建客户端&#34;&gt;创建客户端&lt;a class=&#34;anchor&#34; href=&#34;#%e5%88%9b%e5%bb%ba%e5%ae%a2%e6%88%b7%e7%ab%af&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;kubeClient, leaderElectionClient, err := createClients(s)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;Run()&lt;/code&gt;函数一开始先创建了一个kubernetes的客户端，用来连接&lt;code&gt;kube-apiserver&lt;/code&gt;组件以获取集群信息，这个客户端对象会被包含在Scheduler对象中。&lt;/p&gt;&#xA;&lt;h2 id=&#34;创建缓存更新器&#34;&gt;创建缓存更新器&lt;a class=&#34;anchor&#34; href=&#34;#%e5%88%9b%e5%bb%ba%e7%bc%93%e5%ad%98%e6%9b%b4%e6%96%b0%e5%99%a8&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;informerFactory := informers.NewSharedInformerFactory(kubeClient, 0)&#xA;podInformer := factory.NewPodInformer(kubeClient, 0)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后又根据客户端创建出来两个&lt;code&gt;Informer&lt;/code&gt;对象，它跟客户端在一个包中，其作用是允许用户提供一些事件监听器（watcher），然后它有一个Run方法，启动以后会一直循环从&lt;code&gt;kube-apiserver&lt;/code&gt;中查询我们想要的信息，比如节点状态、新增Pod等等，如果有变化就会触发我们注册的相应的监听器对应的动作，然后本地有一个缓存对象，用来存放这些查询到的信息，这时只是创建，它们的Run方法还没有被调用。&lt;/p&gt;&#xA;&lt;h2 id=&#34;创建scheduler&#34;&gt;创建Scheduler&lt;a class=&#34;anchor&#34; href=&#34;#%e5%88%9b%e5%bb%bascheduler&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sched, err := CreateScheduler(&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Scheduler对象的创建与另外两个对象密切相关，一个是Config，它与Scheduler定义在一个文件中：&lt;code&gt;plugin/pkg/scheduler/scheduler.go&lt;/code&gt;，另一个是ConfigFactory，定义在&lt;code&gt;plugin/pkg/scheduler/factory/factory.go&lt;/code&gt;，它们的关系大概为：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;ConfigFactory的主要工作是维护本地已缓存调度资源，比如等待调度的Pod、已调度的Pod、集群节点列表、PV/PVC列表等，并由&lt;code&gt;Informer&lt;/code&gt;循环地从&lt;code&gt;apiserver&lt;/code&gt;中把资源更新到本地，当然还包括向队列增删改查的函数，这些函数由&lt;code&gt;Informer&lt;/code&gt;提供。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Scheduler是对ConfigFactory的高级抽象，相对包含的函数少一些，因为它封装出了更高级的功能，使用起来更简单。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;而Config是Scheduler中的一个字段，Config没有函数只有一些字段，主要的作用是包含了Scheduler运行时需要的资源，这个Config对象包含的元素如下：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type Config struct {&#xA;&#x9;SchedulerCache schedulercache.Cache&#xA;&#x9;Ecache     *core.EquivalenceCache&#xA;&#x9;NodeLister algorithm.NodeLister&#xA;&#x9;Algorithm  algorithm.ScheduleAlgorithm&#xA;&#x9;Binder     Binder&#xA;&#x9;PodConditionUpdater PodConditionUpdater&#xA;&#x9;PodPreemptor PodPreemptor&#xA;&#x9;NextPod func() *v1.Pod&#xA;&#x9;WaitForCacheSync func() bool&#xA;&#x9;Error func(*v1.Pod, error)&#xA;&#x9;Recorder record.EventRecorder&#xA;&#x9;StopEverything chan struct{}&#xA;}&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;其中&lt;code&gt;Algorithm&lt;/code&gt;字段自然就是调度算法了，&lt;code&gt;NodeLister&lt;/code&gt;字段表示集群中所有节点的列表，&lt;code&gt;Binder&lt;/code&gt;用来将指定Pod绑定到某一主机上。&lt;/p&gt;&#xA;&lt;h2 id=&#34;默认调度算法&#34;&gt;默认调度算法&lt;a class=&#34;anchor&#34; href=&#34;#%e9%bb%98%e8%ae%a4%e8%b0%83%e5%ba%a6%e7%ae%97%e6%b3%95&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;默认的调度算法对象在&lt;code&gt;pkg/scheduler/factory/factory.go:CreateFromKeys()&lt;/code&gt;函数中被创建：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;algo := core.NewGenericScheduler(&#xA;&#x9;c.schedulerCache,&#xA;&#x9;c.equivalencePodCache,&#xA;&#x9;c.podQueue,&#xA;&#x9;predicateFuncs,&#xA;&#x9;predicateMetaProducer,&#xA;&#x9;priorityConfigs,&#xA;&#x9;priorityMetaProducer,&#xA;&#x9;extenders,&#xA;&#x9;c.volumeBinder,&#xA;&#x9;c.pVCLister,&#xA;&#x9;c.alwaysCheckAllPredicates,&#xA;&#x9;c.disablePreemption,&#xA;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;所以调度一个Pod的具体实现就在这个&lt;code&gt;genericScheduler&lt;/code&gt;结构体中定义了，关键函数是它的&lt;code&gt;Schedule()&lt;/code&gt;函数了：&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/kubernetes/k8s-cri.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/kubernetes/k8s-cri.html</guid>
      <description>&lt;h1 id=&#34;k8s-cri&#34;&gt;k8s CRI&lt;a class=&#34;anchor&#34; href=&#34;#k8s-cri&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;cricontainer-runtime-interface&#34;&gt;CRI（container runtime interface）&lt;a class=&#34;anchor&#34; href=&#34;#cricontainer-runtime-interface&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;在1.5以前的版本中，k8s依赖于dokcer，为了与docker解耦并支持更多的容器运行时，比如rkt、containerd，kubelet从1.5开始加入了CRI，作为k8s和容器运行时通信的标准，CRI是一组rpc接口，也就是说只要是实现了这组接口都可以作为kubelet的运行时，另外在k8s内部将之前的Pod抽象为一种更为通用的SandBox。&lt;/p&gt;&#xA;&lt;h3 id=&#34;接口定义&#34;&gt;接口定义&lt;a class=&#34;anchor&#34; href=&#34;#%e6%8e%a5%e5%8f%a3%e5%ae%9a%e4%b9%89&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;v1.7 &lt;a href=&#34;https://github.com/kubernetes/kubernetes/blob/release-1.7/pkg/kubelet/apis/cri/v1alpha1/runtime&#34;&gt;pkg/kubelet/apis/cri/v1alpha1/runtime&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;v1.11 &lt;a href=&#34;https://github.com/kubernetes/kubernetes/tree/release-1.11/pkg/kubelet/apis/cri/runtime/v1alpha2&#34;&gt;pkg/kubelet/apis/cri/runtime/v1alpha2&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;接口实现&#34;&gt;接口实现&lt;a class=&#34;anchor&#34; href=&#34;#%e6%8e%a5%e5%8f%a3%e5%ae%9e%e7%8e%b0&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;p&gt;提出了CRI标准以后，意味着在新的版本里需要使用新的连接方式与docker通信，也就是说docker端需要按CRI的标准实现一个rpc的服务端，所以为了兼容以前的版本，不改变用户习惯，k8s提供了针对docker的CRI实现，也就是k8s源码中kubelet包下的dockershim包，dockershim是一个rpc服务，监听一个端口供kubelet连接，dockershim收到kubelet的请求后，将其转化为REST API请求，发送给物理机上的docker daemon，以下是创建和启动dockershim的代码（k8s v1.11版本）：&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;pkg/kubelet/kubelet.go:NewMainKubelet():617&lt;/code&gt;&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 创建dockershim&#xA;ds, err := dockershim.NewDockerService(kubeDeps.DockerClientConfig, crOptions.PodSandboxImage, streamingConfig,&#xA;...&#xA;// 启动rpc服务&#xA;if err := server.Start(); err != nil {&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;创建Docker客户端的逻辑是在创建dockershim的过程中，关键代码：&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;pkg/kubelet/dockershim/libdocker/client.go:100&lt;/code&gt;：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;client, err := getDockerClient(dockerEndpoint)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;client对象就是docker的客户端，包含了我们常用的&lt;code&gt;docker  run&lt;/code&gt;，&lt;code&gt;docker images&lt;/code&gt;等所有操作，其中&lt;code&gt;dockerEndpoint&lt;/code&gt;变量就是kubelet启动参数&lt;code&gt;--container-runtime-endpoint&lt;/code&gt;选项的值，默认是&lt;code&gt;unix:///var/run/docker.sock&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;p&gt;k8s调用容器运行时过程如下：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;kubelet -&amp;gt; remote -&amp;gt; CRI -&amp;gt; dockershim -&amp;gt; docker_client -&amp;gt; docker_daemon&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在Github上阅读完整的源码：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;CRI客户端实现（remote包）： &lt;a href=&#34;https://github.com/kubernetes/kubernetes/blob/release-1.11/pkg/kubelet/remote&#34;&gt;pkg/kubelet/remote&lt;/a&gt;，与容器相关的逻辑主要在&lt;a href=&#34;https://github.com/kubernetes/kubernetes/blob/release-1.11/pkg/kubelet/remote/remote_runtime.go&#34;&gt;remote_runtime.go&lt;/a&gt;文件中。&lt;/li&gt;&#xA;&lt;li&gt;CRI服务端实现（dockershim包）： &lt;a href=&#34;https://github.com/kubernetes/kubernetes/tree/release-1.11/pkg/kubelet/dockershim&#34;&gt;pkg/kubelet/dockershim&lt;/a&gt;，与容器相关的逻辑主要在&lt;a href=&#34;https://github.com/kubernetes/kubernetes/blob/release-1.11/pkg/kubelet/dockershim/docker_container.go&#34;&gt;docker_container.go&lt;/a&gt;文件中。&lt;/li&gt;&#xA;&lt;li&gt;dockershim调用Docker的逻辑： &lt;a href=&#34;https://github.com/kubernetes/kubernetes/tree/release-1.11/pkg/kubelet/dockershim/libdocker&#34;&gt;pkg/kubelet/dockershim/libdocker&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;kubelet相关参数&#34;&gt;kubelet相关参数&lt;a class=&#34;anchor&#34; href=&#34;#kubelet%e7%9b%b8%e5%85%b3%e5%8f%82%e6%95%b0&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;//指定资源管理驱动&#xA;--runtime-cgroups cgroupfs&#xA;//指定容器运行时&#xA;--container-runtime docker&#xA;//指定docker daemon的地址&#xA;--docker-endpoint unix:///var/run/docker.sock&#xA;//创建dockershim服务，供kubelet连接&#xA;--container-runtime-endpoint unix:///var/run/dockershim.sock&#xA;--image-service-endpoint unix:///var/run/dockershim.sock&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;相关资料&#34;&gt;相关资料&lt;a class=&#34;anchor&#34; href=&#34;#%e7%9b%b8%e5%85%b3%e8%b5%84%e6%96%99&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://localhost:1313/articles/kubernetes/k8s-code-kubelet&#34;&gt;kubelet源码分析&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://localhost:1313/articles/kubernetes/k8s-code-pod-create&#34;&gt;k8s创建Pod的流程&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/kubernetes/k8s-dashboard-with-heapster.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/kubernetes/k8s-dashboard-with-heapster.html</guid>
      <description>&lt;h1 id=&#34;k8s-仪表盘与性能指标&#34;&gt;k8s 仪表盘与性能指标&lt;a class=&#34;anchor&#34; href=&#34;#k8s-%e4%bb%aa%e8%a1%a8%e7%9b%98%e4%b8%8e%e6%80%a7%e8%83%bd%e6%8c%87%e6%a0%87&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;安装heapster&#34;&gt;安装Heapster&lt;a class=&#34;anchor&#34; href=&#34;#%e5%ae%89%e8%a3%85heapster&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;需要注意的地方就是镜像，如果官方的不能下载，可以选择国内的，共三个：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;docker pull kxdmmr/heapster-influxdb-amd64:v1.3.3&#xA;docker pull kxdmmr/heapster-grafana-amd64:v4.4.3&#xA;docker pull kxdmmr/heapster-amd64:v1.4.2&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后去官方下载三个yaml文件：&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/kubernetes/heapster/tree/master/deploy/kube-config/influxdb&#34;&gt;https://github.com/kubernetes/heapster/tree/master/deploy/kube-config/influxdb&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;还有一个关于RBAC的：&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/kubernetes/heapster/tree/master/deploy/kube-config/rbac&#34;&gt;https://github.com/kubernetes/heapster/tree/master/deploy/kube-config/rbac&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;修改文件内的镜像地址，然后通过kubectl create一次性创建它们。&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[root@node10 dashboard]# kubectl -n kube-system get pods&#xA;NAME                                        READY     STATUS    RESTARTS   AGE&#xA;heapster-7f776d4686-8nfz2                   1/1       Running   0          12d&#xA;monitoring-grafana-64768ccd78-4tgmd         1/1       Running   0          12d&#xA;monitoring-influxdb-84774b9644-z9m28        1/1       Running   0          12d&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;安装dashboard&#34;&gt;安装Dashboard&lt;a class=&#34;anchor&#34; href=&#34;#%e5%ae%89%e8%a3%85dashboard&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;下载yaml&#34;&gt;下载yaml&lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%8b%e8%bd%bdyaml&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;p&gt;下载&lt;a href=&#34;https://github.com/kubernetes/dashboard&#34;&gt;官方&lt;/a&gt;的yaml文件：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;mkdir dashboard &amp;amp;&amp;amp; cd dashboard&#xA;curl -O https://raw.githubusercontent.com/kubernetes/dashboard/master/src/deploy/recommended/kubernetes-dashboard.yaml&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;修改镜像地址&#34;&gt;修改镜像地址&lt;a class=&#34;anchor&#34; href=&#34;#%e4%bf%ae%e6%94%b9%e9%95%9c%e5%83%8f%e5%9c%b0%e5%9d%80&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;p&gt;如果你不能下载官方的镜像，可以选择国内镜像，将yaml文件内&lt;code&gt;image: k8s.gcr&lt;/code&gt;这一行改为&lt;code&gt;image: kxdmmr/kubernetes-dashboard-amd64:v1.8.1&lt;/code&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;挂载证书到pod中&#34;&gt;挂载证书到pod中&lt;a class=&#34;anchor&#34; href=&#34;#%e6%8c%82%e8%bd%bd%e8%af%81%e4%b9%a6%e5%88%b0pod%e4%b8%ad&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;p&gt;在默认的启动参数中指定了自动生成证书&lt;code&gt;--auto-generate-certificates&lt;/code&gt;，但实际并不能正常提供https服务，我们可以指定为自己的证书。&lt;/p&gt;&#xA;&lt;p&gt;我们打算将证书以Secret的方法挂载到Pod中，所以先将证书和私钥编码成base64，至于证书和私钥的选择，你可以专门为dashboard生成一对，也可以用已经存在的，这里我用安装集群时的一对密钥作为示例：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;less /etc/kubernetes/ssl/kubernetes.pem | base64 -w 0&#xA;less /etc/kubernetes/ssl/kubernetes-key.pem | base64 -w 0&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后将得到的两个base64码放入yaml文件中的Secret中，给它增加一个data字段，如下：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;apiVersion: v1&#xA;kind: Secret&#xA;metadata:&#xA;  labels:&#xA;    k8s-app: kubernetes-dashboard&#xA;  name: kubernetes-dashboard-certs&#xA;  namespace: kube-system&#xA;type: Opaque&#xA;data:&#xA;  certfile: EZ6VVcwZWx0NC94Z.........(省略)&#xA;  keyfile: LRVktLNCS0tLE9Qo=.........(省略)&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;引用证书&#34;&gt;引用证书&lt;a class=&#34;anchor&#34; href=&#34;#%e5%bc%95%e7%94%a8%e8%af%81%e4%b9%a6&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;p&gt;这里需要修改dashboard的启动参数，也就是Deployment部分:&#xA;&lt;code&gt;Deployment.spec.template.spec.containers.args&lt;/code&gt;：&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/kubernetes/k8s-expose-service.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/kubernetes/k8s-expose-service.html</guid>
      <description>&lt;h1 id=&#34;k8s-暴露服务&#34;&gt;k8s 暴露服务&lt;a class=&#34;anchor&#34; href=&#34;#k8s-%e6%9a%b4%e9%9c%b2%e6%9c%8d%e5%8a%a1&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;p&gt;在k8s集群中向外暴露服务目前官方支持两种方式：NodePort和Ingress，前者简单粗暴，而后者更高级优雅，那是不是前者就可以被抛弃了？至少目前来看不是的，它们都各有优势和不足，通常情况下需要两者配合使用来满足所有场景，必要时还需要修改自己的业务模块来支持k8s平台，下面我们从使用方法上和优缺点方面细说这两种方案。&lt;/p&gt;&#xA;&lt;h2 id=&#34;nodeport&#34;&gt;NodePort&lt;a class=&#34;anchor&#34; href=&#34;#nodeport&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;原理&#34;&gt;原理&lt;a class=&#34;anchor&#34; href=&#34;#%e5%8e%9f%e7%90%86&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;p&gt;这种方法其实类似于&lt;code&gt;docker run&lt;/code&gt;命令中的&lt;code&gt;-p&lt;/code&gt;选项，只不过在Kubernetes中用&lt;code&gt;kube-proxy&lt;/code&gt;组件代替了Docker的&lt;code&gt;-p&lt;/code&gt;的功能，并且是定义在&lt;code&gt;service&lt;/code&gt;中，其原理是通过操作系统的&lt;code&gt;iptables&lt;/code&gt;来将物理机上指定端口的数据转发到对应的Pod内。&lt;/p&gt;&#xA;&lt;h3 id=&#34;使用&#34;&gt;使用&lt;a class=&#34;anchor&#34; href=&#34;#%e4%bd%bf%e7%94%a8&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;p&gt;下面是定义一个NodePort类型的Service：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;apiVersion: v1&#xA;kind: Service&#xA;metadata:&#xA;  name: spark-driver&#xA;spec:&#xA;  type: NodePort&#xA;  externalIPs:&#xA;  - &amp;#34;10.100.100.100&amp;#34;&#xA;  ports:&#xA;  - port: 7070&#xA;    name: master&#xA;  - port: 4040&#xA;    name: appui&#xA;  selector:&#xA;    app: spark-driver-pod&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;10.100.100.100&lt;/code&gt;是k8s集群中某节点的物理IP地址，然后我们就可以通过&lt;code&gt;10.100.100.100:4040&lt;/code&gt;访问到&lt;code&gt;app: spark-driver-pod&lt;/code&gt;这个Pod的4040端口。&lt;/p&gt;&#xA;&lt;h3 id=&#34;限制&#34;&gt;限制&lt;a class=&#34;anchor&#34; href=&#34;#%e9%99%90%e5%88%b6&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;p&gt;很快你就会发现这种方式会有一个问题，当我们在k8s中创建了多个一样的服务，并且都需要访问它们的4040端口和7070端口时，我们需要为每个服务都绑定一个物理IP，而集群中的节点是有限的，很快就没有IP可以用了，这时候有两种变通的方法：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;把上面yaml文件定义中的4040改为其它端口，比如：4041、4042，由于每个服务映射出来的端口不一样，这时需要我们通过其它手段把这些信息记录下来，用户才知道怎样访问自己创建的服务，做这些事是需要工作量的，而且端口也并不是无限的。&lt;/li&gt;&#xA;&lt;li&gt;第二方法是增加IP，虽然节点是有限的，但如果你的集群使用的IP段是16位的话，还是有很多IP可以用的，方法就是在其中一个k8s子节点上增加子IP，比如几百个、几千个、几万个，，这个方法其实已经在我的前几篇文章中提到过了，具体操作可以参考我的&lt;a href=&#34;http://localhost:1313/articles/linux/linux-centos7-multi-ip&#34;&gt;这篇文章&lt;/a&gt;。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;ingress&#34;&gt;Ingress&lt;a class=&#34;anchor&#34; href=&#34;#ingress&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;上面说的两种变通方法其实有点“旁门左道”的味道了，而k8s官方在1.1及以上版本中提供了更优雅的方式来解决这个问题，那就是&lt;code&gt;Ingress&lt;/code&gt;，它是以插件的方式存在的，并且默认是没有安装的。&lt;/p&gt;&#xA;&lt;h3 id=&#34;原理-1&#34;&gt;原理&lt;a class=&#34;anchor&#34; href=&#34;#%e5%8e%9f%e7%90%86-1&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;p&gt;Ingress是通过在k8s集群中启动一个或多个nginx服务，然后通过k8s的REST API从&lt;code&gt;kube-apiserver&lt;/code&gt;中监控&lt;code&gt;Endpoint&lt;/code&gt;的变化来动态修改这个nginx的配置文件，将不同的请求转发给相应的Service来完成数据转发，这样说起来可能比较抽象，下面我们将用一个demo来说明它的工作原理。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;img/k8s-expose-service/k8s-ingress-principle.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;安装&#34;&gt;安装&lt;a class=&#34;anchor&#34; href=&#34;#%e5%ae%89%e8%a3%85&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;p&gt;Ingress的安装还是比较简单的，官方的安装文档在&lt;a href=&#34;https://github.com/kubernetes/ingress-nginx/blob/master/deploy/README.md&#34;&gt;这里&lt;/a&gt;，大概可以分为三步：&lt;/p&gt;&#xA;&lt;p&gt;1、下载yaml文件&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;mkdir ingress &amp;amp;&amp;amp; cd ingress&#xA;&#xA;curl -O https://raw.githubusercontent.com/kubernetes/ingress-nginx/master/deploy/namespace.yaml&#xA;curl -O https://raw.githubusercontent.com/kubernetes/ingress-nginx/master/deploy/default-backend.yaml&#xA;curl -O https://raw.githubusercontent.com/kubernetes/ingress-nginx/master/deploy/configmap.yaml&#xA;curl -O https://raw.githubusercontent.com/kubernetes/ingress-nginx/master/deploy/tcp-services-configmap.yaml&#xA;curl -O https://raw.githubusercontent.com/kubernetes/ingress-nginx/master/deploy/udp-services-configmap.yaml&#xA;curl -O https://raw.githubusercontent.com/kubernetes/ingress-nginx/master/deploy/rbac.yaml&#xA;curl -O https://raw.githubusercontent.com/kubernetes/ingress-nginx/master/deploy/with-rbac.yaml&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面每个命令都涉及一个yaml文件，其中&lt;code&gt;default-backend.yaml&lt;/code&gt;和&lt;code&gt;with-rbac.yaml&lt;/code&gt;两个文件中涉及到两个在国外的镜像，你可能下载不下来，这时需要改为国内镜像：&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/kubernetes/k8s-principle.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/kubernetes/k8s-principle.html</guid>
      <description>&lt;h1 id=&#34;k8s-基本原理&#34;&gt;k8s 基本原理&lt;a class=&#34;anchor&#34; href=&#34;#k8s-%e5%9f%ba%e6%9c%ac%e5%8e%9f%e7%90%86&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;k8s原理解析&#34;&gt;k8s原理解析&lt;a class=&#34;anchor&#34; href=&#34;#k8s%e5%8e%9f%e7%90%86%e8%a7%a3%e6%9e%90&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;kubernetes由多个模块组成，一般情况下，除去插件和依赖我们需要部署5个组件和一个静态工具，分别为：kube-apiserver、kube-scheduler、kube-controller-manager、kubelet、kube-proxy、kubectl，我们逐一讲解它们的作用及原理。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;img/k8s-principle/k8s-architecture.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;kube-apiserver&#34;&gt;kube-apiserver&lt;a class=&#34;anchor&#34; href=&#34;#kube-apiserver&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;p&gt;一个WEB服务，运行在主节点，它向外提供了很多的REST API，比如：新删改Pod、Service、Deployments，添加节点，提供对REST API的访问权限控制等。&lt;/p&gt;&#xA;&lt;p&gt;一般运行一个WEB服务都会依赖一个数据库，用来持久化WEB的状态，apiserver也不例外，它的运行需要依赖一个键值对存储服务，用来存储集群中所有信息，如：Pod状态、Node状态、已创建的Service、已创建的Endpoint，创建的Deployments、Statefulsets等，目前(v1.7.2)它只支持ETCD2、ETCD3两种存储服务，所以在部署apiserver前需要先部署一个ETCD集群，且默认地、它与apiserver之间的通信是TLS协议的，所以在apiserver和ETCD的启动参数中都会指定一对证书和密钥，其它所有组件与apiserver进行通信时也都是TLS方式。&lt;/p&gt;&#xA;&lt;h3 id=&#34;kube-scheduler&#34;&gt;kube-scheduler&lt;a class=&#34;anchor&#34; href=&#34;#kube-scheduler&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;p&gt;一个提供Pod调度功能和调度算法的组件，运行在主节点，它的工作原理是不断地从apiserver监听是否有新创建的Pod，或者说已创建但还没有进行调度的Pod，如果有则将该Pod放入本地队列，然后用指定的算法为集群中所有Node进行打分，将Pod绑定到得分最高的Node上，绑定其实就是将Node的Hostname写入到Pod对象对应的字段中，然后将Pod信息写回到apiserver中，至此调度就算完成了。&lt;/p&gt;&#xA;&lt;p&gt;scheduler启动时可以指定调度算法，默认的算法名为&amp;quot;default-scheduler&amp;quot;，原理是遍历所有Node，用Node的剩余内存和CPU作为权重，计算出每个Node的分数，如果有多个第一名则随机选其中一个第一名。&lt;/p&gt;&#xA;&lt;h3 id=&#34;kube-controller-menager&#34;&gt;kube-controller-menager&lt;a class=&#34;anchor&#34; href=&#34;#kube-controller-menager&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;p&gt;负责管理其它scale-controller，运行在主节点，我们创建Deployments、Statefulsets等资源的时候会有一个相应的scale-controller被创建出来，用来监控该资源的副本数是否与预期数量相同。&lt;/p&gt;&#xA;&lt;h3 id=&#34;kubelet&#34;&gt;kubelet&lt;a class=&#34;anchor&#34; href=&#34;#kubelet&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;p&gt;做实际部署工作的组件，运行在每个子节点上，原理是所有kubelet不断从apiserver检测已绑定主机但还未部署的Pod，如果这个Pod是绑这定在自己主机上的则将其部署，然后通过REST API将Pod状态更新到apiserver中。除此之外它还要发送心跳给apiserver并汇报自身状态。&lt;/p&gt;&#xA;&lt;h3 id=&#34;kube-proxy&#34;&gt;kube-proxy&lt;a class=&#34;anchor&#34; href=&#34;#kube-proxy&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;p&gt;与kubelet一起被部署在每个子节点上，负责从&lt;code&gt;api-server&lt;/code&gt;中监听service和endpoint资源，并在物理机上通过iptables或ipvs为Pod设置端口转发、负载均衡以及从service到Pod的数据转发。&lt;/p&gt;&#xA;&lt;h3 id=&#34;kubectl&#34;&gt;kubectl&lt;a class=&#34;anchor&#34; href=&#34;#kubectl&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;p&gt;一个k8s客户端，可以部署在任何地方，它的运行需要依赖一个配置文件，用来提供apiserver的地址、端口、证书等信息，以下是一个创建Deployments的示例：&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;vim spark.yaml&lt;/code&gt;&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;apiVersion: apps/v1beta1&#xA;kind: Deployment&#xA;metadata:&#xA;  name: spark-executor&#xA;spec:&#xA;  replicas: 10&#xA;  template:&#xA;    metadata:&#xA;      labels:&#xA;        app: spark-executor&#xA;    spec:&#xA;      containers:&#xA;      - name: spark-executor&#xA;        image: registry.io:5000/leap/spark:latest&#xA;        imagePullPolicy: Always&#xA;        resources:&#xA;          requests:&#xA;            memory: &amp;#34;2G&amp;#34;&#xA;            cpu: &amp;#34;5&amp;#34;&#xA;          limits:&#xA;            memory: &amp;#34;2G&amp;#34;&#xA;            cpu: &amp;#34;5&amp;#34;&#xA;        ports:&#xA;        - containerPort: 8081&#xA;          name: port-1&#xA;        env:&#xA;        - name: DEBUG&#xA;          value: &amp;#34;__DEBUG&amp;#34;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;kubectl -n p48-u26-jiajun2 create spark.yml&lt;/code&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/kubernetes/kubeedge-code.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/kubernetes/kubeedge-code.html</guid>
      <description>&lt;h1 id=&#34;kubeedge源码分析&#34;&gt;KubeEdge源码分析&lt;a class=&#34;anchor&#34; href=&#34;#kubeedge%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;p&gt;本文以1.2.1版本为例，项目结构说明：&lt;a href=&#34;https://github.com/kubeedge/kubeedge/blob/v1.2.1/README_zh.md&#34;&gt;kubeedge&lt;/a&gt;。&lt;/p&gt;&#xA;&lt;h2 id=&#34;边缘端模块&#34;&gt;边缘端模块&lt;a class=&#34;anchor&#34; href=&#34;#%e8%be%b9%e7%bc%98%e7%ab%af%e6%a8%a1%e5%9d%97&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;edgehub&#34;&gt;EdgeHub&lt;a class=&#34;anchor&#34; href=&#34;#edgehub&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;p&gt;模块位置：&lt;code&gt;edge/pkg/edgehub&lt;/code&gt;&#xA;该模块用于与CloudHub通信，目前支持两种方式与CloudHub建立连接：QUIC协议和WebSocket协议，无论使用哪种方式都会使用TLS加密。&lt;/p&gt;&#xA;&lt;h4 id=&#34;使用quic方式&#34;&gt;使用QUIC方式&lt;a class=&#34;anchor&#34; href=&#34;#%e4%bd%bf%e7%94%a8quic%e6%96%b9%e5%bc%8f&#34;&gt;#&lt;/a&gt;&lt;/h4&gt;&#xA;&lt;p&gt;关键代码&lt;a href=&#34;github.com/kubeedge/kubeedge/blob/v1.2.1/edge/pkg/edgehub/clients/quicclient/quicclient.go#L75&#34;&gt;quicclient.go:75&lt;/a&gt;：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func (qcc *QuicClient) Init() error {&#xA;    // ... 省略多行 ...&#xA;    client := qclient.NewQuicClient(option, exOpts)&#xA;    // ... 省略多行 ...&#xA;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面的&lt;code&gt;NewQuicClient()&lt;/code&gt;函数其实是调用第三方包（quic-go）建立多路复用的UDP连接与CloudHub端通信&lt;a href=&#34;github.com/lucas-clemente/quic-go/blob/v0.10.2/client.go#L86&#34;&gt;client.go:86&lt;/a&gt;：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func DialAddrContext(ctx context.Context, addr string, tlsConf *tls.Config, config *Config,) (Session, error) {&#xA;    // ... 省略多行 ...&#xA;    udpConn, err := net.ListenUDP(&amp;#34;udp&amp;#34;, &amp;amp;net.UDPAddr{IP: net.IPv4zero, Port: 0})&#xA;    return dialContext(ctx, udpConn, udpAddr, addr, tlsConf, config, true)&#xA;}&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;使用websocket方式&#34;&gt;使用WebSocket方式&lt;a class=&#34;anchor&#34; href=&#34;#%e4%bd%bf%e7%94%a8websocket%e6%96%b9%e5%bc%8f&#34;&gt;#&lt;/a&gt;&lt;/h4&gt;&#xA;&lt;p&gt;关键代码&lt;a href=&#34;github.com/kubeedge/kubeedge/blob/v1.2.1/edge/pkg/edgehub/clients/wsclient/websocket.go#L47&#34;&gt;websocket.go:75&lt;/a&gt;：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func (qcc *QuicClient) Init() error {&#xA;    // ... 省略多行 ...&#xA;    client := &amp;amp;wsclient.Client{Options: option, ExOpts: exOpts}&#xA;    // ... 省略多行 ...&#xA;}&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/kubernetes/kubernetes-quick-deloy-17.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/kubernetes/kubernetes-quick-deloy-17.html</guid>
      <description>&lt;h1 id=&#34;k8s-快速部署-17&#34;&gt;k8s 快速部署 1.7&lt;a class=&#34;anchor&#34; href=&#34;#k8s-%e5%bf%ab%e9%80%9f%e9%83%a8%e7%bd%b2-17&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;p&gt;最近（2017.07.30）k8s 又发布了新版本，这个版本中增加了两种持久化存储方案，StorygeOS 与 Local ，为了一探究竟，我部署了一套最新版的 k8s 集群，虽然我在半年前部署过一次，并写过一篇 k8s-v1.5 版本部署的文篇，但那次的经验已经不再适用于新版本，这让我又体验了一次 k8s 的部署过程，这简直是种折磨，我现在新重新整理出来，希望给读者带来帮助。&lt;/p&gt;&#xA;&lt;h2 id=&#34;环境说明&#34;&gt;环境说明&lt;a class=&#34;anchor&#34; href=&#34;#%e7%8e%af%e5%a2%83%e8%af%b4%e6%98%8e&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;这次同样是用的 k8s 官方提供的快速安装工具 &lt;code&gt;kubeadm&lt;/code&gt;，这种方式依然被官方视为实验性功能，并不建议用在生产环境之中，先说明一下我的环境。&lt;/p&gt;&#xA;&lt;p&gt;服务器三台：node1.docker.com, node2.docker.com, node3.docker.com&lt;/p&gt;&#xA;&lt;p&gt;操作系统：CentOS 7.2-1511 64位 Docker 版本：1.12.6&lt;/p&gt;&#xA;&lt;p&gt;Kubernetes 版本：1.7.0&lt;/p&gt;&#xA;&lt;p&gt;部署方式：官方提供的 kubeadm 工具&lt;/p&gt;&#xA;&lt;h2 id=&#34;准备-linux&#34;&gt;准备 Linux&lt;a class=&#34;anchor&#34; href=&#34;#%e5%87%86%e5%a4%87-linux&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;关于系统，我用的是 CentOS7.2，官方说的是只要 CentOS7 就可以，如果是 Ubuntu 的话，版本要在 Ubuntu 16.04 或以上，或者是 HypriotOS v1.0.1+ 系统，不过我没用过这个系统。。&lt;/p&gt;&#xA;&lt;h2 id=&#34;安装-docker&#34;&gt;安装 Docker&lt;a class=&#34;anchor&#34; href=&#34;#%e5%ae%89%e8%a3%85-docker&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;所有节点都需要做这个步骤，这里要提醒大家一下，如果你按照 Docker 官网给出的方式，通过官方提供的 repo 源安装了最新版的 Docker，最好卸载掉，然后重新安装 1.12.x 版本的 Docker，否则后导致后面初始化 K8s 时失败，我已经在这个环节上浪费掉很多时间了，，k8s 官方说 Docker-1.13.x 也是可以的，但我没有试过，，所以正确的安装姿势是，用 CentosOS 7.2 自带的 repo 源来安装，如果你的系统中有 /etc/yum.repos.d/docker.repo 这个文件的话，请移除，然后执行：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;yum install docker-1.12.6 -y&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果你的系统自带的源中没有找到 docker，那可以尝试从 Docker 官网安装，但一定要是 1.12.x 的 Docker 版本，请参考&lt;a href=&#34;https://docs.docker.com/engine/installation/linux/docker-ce/centos/#install-using-the-repository&#34;&gt;Docker 官方文档&lt;/a&gt;。&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/kubernetes/kubernetes-quick-deloy.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/kubernetes/kubernetes-quick-deloy.html</guid>
      <description>&lt;h1 id=&#34;k8s-快速部署-15&#34;&gt;k8s 快速部署 1.5&lt;a class=&#34;anchor&#34; href=&#34;#k8s-%e5%bf%ab%e9%80%9f%e9%83%a8%e7%bd%b2-15&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;p&gt;本篇文章可能已不再适用于最新版本的 k8s，您可以看我的另一篇文章：&lt;a href=&#34;http://localhost:1313/articles/kubernetes/kubernetes-quick-deloy-17&#34;&gt;Kubernetes - 快速部署(1.7)&lt;/a&gt;。&lt;/p&gt;&#xA;&lt;p&gt;k8s 即 kubernetes，它是一个由谷歌开源的容器管理框架，提供完善的容器管理功能，如：Docker 容器编排，服务发现，状态监视等，据说它融合了谷歌多年的容器运营经验，所以目前为止，在容器管理界它是最成熟的，但它并不容易使用，比起 Docker 自带的容器管理框架 Swarm 要复杂的多，有人称 Kubernetes 的集群部署是地狱级的，这并不夸张。 Kubernetes 在 1.5 版本以后，谷歌简化了它的部署流程，小编看了官网的介绍，只需要在各个机器上执行一两条命令就可以搭建一个 k8s 集群，所以赶紧小试了一把，然而实际上并没那么容易，今天就记录在此。下面我们就来搭建一个 k8s 集群，并安装一个 WEB UI 应用（Dashboard）做为示例。&lt;/p&gt;&#xA;&lt;h2 id=&#34;环境描述&#34;&gt;环境描述&lt;a class=&#34;anchor&#34; href=&#34;#%e7%8e%af%e5%a2%83%e6%8f%8f%e8%bf%b0&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;三台机器：node1.docker.com, node2.docker.com, node3.docker.com&lt;/li&gt;&#xA;&lt;li&gt;操作系统：CentOS 7.2&lt;/li&gt;&#xA;&lt;li&gt;k8s 版本：v1.5.1&lt;/li&gt;&#xA;&lt;li&gt;好多地方需要用 root 权限，所以笔者在这里直接用 root 用户了&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;在每台机器上安装-k8s&#34;&gt;在每台机器上安装 k8s&lt;a class=&#34;anchor&#34; href=&#34;#%e5%9c%a8%e6%af%8f%e5%8f%b0%e6%9c%ba%e5%99%a8%e4%b8%8a%e5%ae%89%e8%a3%85-k8s&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;这一步的难点在于相关资 源的下载，这些镜像都是在谷歌的服务器上，国内不能下载，这里有几个选择，一是用加速器，二是在网上找一下，看有没有其它人共享下载好的 k8s 与相关镜像，有的话最好，三是购买几台国外的服务器来部署 k8s，当然还有其它方式，相信这难不倒诸位，笔者推荐第一种。&lt;/p&gt;&#xA;&lt;p&gt;以下是本文用到的所有镜像，如果你用上述的第二种方式，请提前下载好这些镜像：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[root@node1 ~]# docker images &#xA;REPOSITORY                                                   TAG                 IMAGE ID            CREATED             SIZE&#xA;docker.io/weaveworks/weave-npc                               1.9.2               6d47d7ef52cf        3 days ago          58.23 MB&#xA;docker.io/weaveworks/weave-kube                              1.9.2               c187d4ccbf10        3 days ago          163.2 MB&#xA;gcr.io/google_containers/kube-proxy-amd64                    v1.5.3              932ee3606ada        2 weeks ago         173.5 MB&#xA;gcr.io/google_containers/kube-scheduler-amd64                v1.5.3              cb0ce9bb60f9        2 weeks ago         54 MB&#xA;gcr.io/google_containers/kube-controller-manager-amd64       v1.5.3              25304c6f1bb2        2 weeks ago         102.8 MB&#xA;gcr.io/google_containers/kube-apiserver-amd64                v1.5.3              93d8b30a8f27        2 weeks ago         125.9 MB&#xA;gcr.io/google_containers/kubernetes-dashboard-amd64          v1.5.1              1180413103fd        7 weeks ago         103.6 MB&#xA;gcr.io/google_containers/etcd-amd64                          3.0.14-kubeadm      856e39ac7be3        3 months ago        174.9 MB&#xA;gcr.io/google_containers/kubedns-amd64                       1.9                 26cf1ed9b144        3 months ago        47 MB&#xA;gcr.io/google_containers/dnsmasq-metrics-amd64               1.0                 5271aabced07        4 months ago        14 MB&#xA;gcr.io/google_containers/kube-dnsmasq-amd64                  1.4                 3ec65756a89b        5 months ago        5.126 MB&#xA;gcr.io/google_containers/kube-discovery-amd64                1.0                 c5e0c9a457fc        5 months ago        134.2 MB&#xA;gcr.io/google_containers/exechealthz-amd64                   1.2                 93a43bfb39bf        5 months ago        8.375 MB&#xA;gcr.io/google_containers/pause-amd64                         3.0                 99e59f495ffa        10 months ago       746.9 kB&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;解决了下载问题就开始安装 k8s 各组件了，因为笔者是 CentOS 系统，执行以下命令安装：&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/kubernetes/popular-bgp-protocol.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/kubernetes/popular-bgp-protocol.html</guid>
      <description>&lt;h1 id=&#34;白话bgp协议&#34;&gt;白话BGP协议&lt;a class=&#34;anchor&#34; href=&#34;#%e7%99%bd%e8%af%9dbgp%e5%8d%8f%e8%ae%ae&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;什么是bgp&#34;&gt;什么是BGP&lt;a class=&#34;anchor&#34; href=&#34;#%e4%bb%80%e4%b9%88%e6%98%afbgp&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;引用维基百科对BGP的描述:&lt;/p&gt;&#xA;&lt;blockquote class=&#39;book-hint &#39;&gt;&#xA;&lt;p&gt;边界网关协议（英文：Border Gateway Protocol, BGP）是互联网上一个核心的去中心化自治路由协议。 它通过维护IP路由表或&amp;rsquo;前缀&amp;rsquo;表来实现自治系统（AS）之间的可达性，属于矢量路由协议。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;BGP是一种通信协议、一组规范、一种解决方案，通俗的说，它用来在多个路由器之间共享彼此的路由表信息，代替了人工维护各个路由器上的路由表，这在大的网络拓扑结构中是很有用的。&lt;/p&gt;&#xA;&lt;h2 id=&#34;为什么用bgp&#34;&gt;为什么用BGP&lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%ba%e4%bb%80%e4%b9%88%e7%94%a8bgp&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;我们通过一个例子来看看BGP到底解决了什么问题。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;img/popular-bgp-protocol/bgp-protocol.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;&#xA;&lt;p&gt;图中有两个路由器R1和R2，为了方便讨论，我将每个IP写成了1.1、2.2的形式，你也可以把它想象成1.1.1.1和2.2.2.2的形式，其中5.5是一个公网IP，其它均是公司内部规划的私有IP，红色的字母代表路由器上的接口，每个路由器旁边有一张表，表示了它们当前的路由信息，并且这几条路由信息是它们默认生成的。&lt;/p&gt;&#xA;&lt;p&gt;当主机2.2访问主机1.2时，报文先到达R2，这时由于R2的路由表中没有1.2的路由信息，所以报文会被转发到默认网关1.1，然后数据包从R2的A接口发出并到达R1，由于R1中有1.2的路由，所以报文可以到过1.2主机。&lt;/p&gt;&#xA;&lt;p&gt;当主机1.2访问主机2.2时，由于R1中没有2.2的路由，报文会被送到默认网关5.1，也就是Internet网，结果可想而知，数据包最终会因为TTL耗尽而被丢弃。&lt;/p&gt;&#xA;&lt;p&gt;要解决1.2不能访问2.2的问题，我们需要在R1上加一条路由，如下：&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;目标&lt;/th&gt;&#xA;          &lt;th&gt;网关&lt;/th&gt;&#xA;          &lt;th&gt;接口&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;2.2&lt;/td&gt;&#xA;          &lt;td&gt;&lt;/td&gt;&#xA;          &lt;td&gt;C&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;p&gt;这样当报文到了R1以后，就会被R1从C接口发送到R2，R2再将报文转发给2.2。&lt;/p&gt;&#xA;&lt;p&gt;但是在网络拓扑非常复杂的情况下，会有很多的路由器以及成千上万的主机（这里不限于同一个公司内部的路由器和主机，更实际的情况是多个公司、多个网络提供商、多个自治网络(AS)组合起来的复杂网络），靠人工为每台路由器配置和维护路由表就会变得不实现。&lt;/p&gt;&#xA;&lt;p&gt;那能不能自动化完成这些事情呢？答案是可以的，例如上面我们为R1增加的路由信息的操作，实际上可以在所有路由器上各自启动一个服务序程序，让它们将自己的路由表通过TCP连接共享给其它所有路由器，其它路由器收到信息后进行分析，将有用的信息添加到自己的路由表中。这样的服务程序就是BGP，它的目标就是解决大型网络中的可达性信息的共享和管理问题。&lt;/p&gt;&#xA;&lt;p&gt;实际上，BGP协议被称为最复杂的网络协议之一，实现一个可用的BGP协议需要很多知识，在这里我也只能粗略说一下它的作用和基本原理，让你快速了解到BGP到底是什么，如果需要深入BGP可以查阅相关书籍，如《BGP设计与实现》。&lt;/p&gt;&#xA;&lt;h2 id=&#34;怎样实现bgp&#34;&gt;怎样实现BGP&lt;a class=&#34;anchor&#34; href=&#34;#%e6%80%8e%e6%a0%b7%e5%ae%9e%e7%8e%b0bgp&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;我接触过一个使用BGP实现的容器网络通信方案Calico，它把Linux节点当做路由器，在多个节点之间使用BGP协议共享路由信息，这个Calico项目是开源的，这篇Calico的文章在这里：&lt;a href=&#34;http://localhost:1313/articles/kubernetes/k8s-calico&#34;&gt;Calico网络&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/linux/linux-centos7-multi-ip.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/linux/linux-centos7-multi-ip.html</guid>
      <description>&lt;h1 id=&#34;centos7增加子ip&#34;&gt;Centos7增加子IP&lt;a class=&#34;anchor&#34; href=&#34;#centos7%e5%a2%9e%e5%8a%a0%e5%ad%90ip&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;p&gt;假设你的 Linux 主机上运行了多了 Docker 容器，而这些容器都需要映射同样的端口号到物理机，以便向外提供服务。这时你可能想到把这些容器的端口映给物理机的不同端口上，如下：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;docker run \&#xA;-p 8080:8080 \&#xA;-p 8081:8081 \&#xA;-p 8082:8080 \&#xA;...&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但这样很容易记不清每个端口对应的服务，本文将介绍一种更优雅的方式解决这个问题。&lt;/p&gt;&#xA;&lt;h2 id=&#34;基本原理&#34;&gt;基本原理&lt;a class=&#34;anchor&#34; href=&#34;#%e5%9f%ba%e6%9c%ac%e5%8e%9f%e7%90%86&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;通过修改 Linux 配置文件，为 Linux 主机创建多个子 IP ，为每个容器中的端口映射到不同的 IP 上即可。&lt;/p&gt;&#xA;&lt;h2 id=&#34;实现步骤&#34;&gt;实现步骤&lt;a class=&#34;anchor&#34; href=&#34;#%e5%ae%9e%e7%8e%b0%e6%ad%a5%e9%aa%a4&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;查看当前网卡状态&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[suer@ser0 ~]$ ip a&#xA;1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue state UNKNOWN &#xA;    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00&#xA;    inet 127.0.0.1/8 scope host lo&#xA;       valid_lft forever preferred_lft forever&#xA;    inet6 ::1/128 scope host &#xA;       valid_lft forever preferred_lft forever&#xA;2: enp8s0f0: &amp;lt;NO-CARRIER,BROADCAST,MULTICAST,UP&amp;gt; mtu 1500 qdisc mq state DOWN qlen 1000&#xA;    link/ether 70:e2:84:0e:5a:87 brd ff:ff:ff:ff:ff:ff&#xA;3: enp10s0: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000&#xA;    link/ether 70:e2:84:0e:5a:86 brd ff:ff:ff:ff:ff:ff&#xA;    inet 10.100.124.231/24 brd 10.100.124.255 scope global enp10s0&#xA;       valid_lft forever preferred_lft forever&#xA;4: enp8s0f1: &amp;lt;NO-CARRIER,BROADCAST,MULTICAST,UP&amp;gt; mtu 1500 qdisc mq state DOWN qlen 1000&#xA;    link/ether 70:e2:84:0e:5a:88 brd ff:ff:ff:ff:ff:ff&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们看到第三个网卡 IP 地址为：10.100.124.231，也就是目前系统的主 IP 地址，它的名字为：enp10s0&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/linux/linux-parallel-progress.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/linux/linux-parallel-progress.html</guid>
      <description>&lt;h1 id=&#34;炫酷的并行进度条&#34;&gt;炫酷的并行进度条&lt;a class=&#34;anchor&#34; href=&#34;#%e7%82%ab%e9%85%b7%e7%9a%84%e5%b9%b6%e8%a1%8c%e8%bf%9b%e5%ba%a6%e6%9d%a1&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;p&gt;你知道怎样写一个并行的进度条吗，如果是在WEB页上或是GUI编程中这很简单，如果是用Shell写呢？或者Python？也许哪天你需要写一个这样的程序，也许这时的你正一筹莫展，那么恭喜你看到本文。 我们先来看一个例子：&#xA;&lt;img src=&#34;img/linux-parallel-progress/linux-parallel-progress_progress.png&#34; alt=&#34;&#34; /&gt;&#xA;这是一个普通的软件安装程序，图中的两个箭头指向两个不同的进度条，其中上方是总进度条，右下角那个是一个不停转圈圈的进度条，表示该步骤正在进行中。没错，这是用Python脚本实现的，用Shell也是一样，而且可能比Python还要简单。&lt;/p&gt;&#xA;&lt;h2 id=&#34;python实现&#34;&gt;Python实现&lt;a class=&#34;anchor&#34; href=&#34;#python%e5%ae%9e%e7%8e%b0&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;在Python中，线程是假线程，它与C或者Java中的线程不同，为了完美，博主在实现的时候用了多进程，也就是multiprocessing模块。&lt;/li&gt;&#xA;&lt;li&gt;在主进程中启动两个子进试，分别负责两个进度条（当然也可以是任意多个），总进度条需要一个全局变量，以在不同的步骤中为其赋不同的值，小进度条在每步完成的时候向下移动一行。&lt;/li&gt;&#xA;&lt;li&gt;关于光标控制，这是一个关键点，因为在任何情况下，屏幕上只有一个光标，且所有输出都会落在光标处，那上例中的总进度条怎么会出现在光标的上方呢？这就需要移动光标了，在Python中，它没有这个能力，只能借助第三方库来实现，这样就为程序的跨平台带来麻烦，而Shell本身提供了这个功能，而且简单到不行，假设我要在屏幕的第三十行第五十列打印一个“hello”，只需这样：&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;echo -e &amp;#34;\033[30;50Hhello&amp;#34;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;或者：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;printf &amp;#34;\033[%d;%dH%s&amp;#34; 30 50 hello&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;4&#34;&gt;&#xA;&lt;li&gt;接下来就是对光标进一步控制，因为在上一步中将光标移到了总进度条的位置，当打印完指定的字符后还需要移动到小进度条的位置，博主在网上搜索良久后终于找到了完美的方法，也是简单到不行：tput sc 与 tput rc 两条命令，前者用于暂时保存光标位置，然后不管将光标称动到哪，后者都能将位置还原，现在我们将上步骤中的打印命令改良一下：&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;tput sc ;printf &amp;#34;\033[%d;%dH%s\n&amp;#34; 30 50 hello ;tput rc&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;5&#34;&gt;&#xA;&lt;li&gt;最后就是同步问题，因为两个进度条是并行执行的，这意味着两个进程可能会在同一时刻执行打印命令，导致打印在屏幕上的字符可能错乱，所以我们要保证在同一时刻只有一个进程在调用print命令，这就用到了多进程锁，而multiprocessing模块已经提供了这样的锁&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;综上所述，这里给出一个简单的示例：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#!/usr/bin/python&#xA;# -*- coding: utf-8 -*-&#xA; &#xA;import os,time&#xA;from multiprocessing import Process, Manager, Lock&#xA; &#xA;# 打印info在终端的指定位置&#xA;def writer(info, y = 0, x = 0):&#xA;    with lock:&#xA;        print_cmd = &amp;#34;tput sc &amp;gt;&amp;amp;2 &amp;amp;&amp;amp; echo -e &amp;#39;\033[%s;%sH%s&amp;#39; &amp;gt;&amp;amp;2 &amp;amp;&amp;amp; tput rc &amp;gt;&amp;amp;2&amp;#34; % (y, x, info)&#xA;        os.system(print_cmd)&#xA; &#xA;# 根据pbar_data内的数据打印进度条，bar_length为进度条总长度&#xA;def progress_bar(pbar_data, y = 0, x = 0, bar_length = 80):&#xA;    percent = float(bar_length) / 100&#xA;    while pbar_data[0] &amp;lt; bar_length:&#xA;        time.sleep(0.05)&#xA;        current = int(float(pbar_data[1]) * percent)&#xA;        if pbar_data[0] != current:&#xA;            for i in range(pbar_data[0], current + 1):&#xA;                time.sleep(pbar_data[2])&#xA;                info = &amp;#34;\033[1;32;40m Progress: [&amp;#34; + (&amp;#34;=&amp;#34; * (i - 1) + &amp;#34;&amp;gt;&amp;#34;).ljust(bar_length,&amp;#34; &amp;#34;) + &amp;#34;] &amp;#34; + str(int(i / percent)) + &amp;#34;% \033[0m&amp;#34;&#xA;                writer(info, y)&#xA;            pbar_data[0] = current&#xA; &#xA;&amp;#39;&amp;#39;&amp;#39;&#xA;创建全局变量，用于将主进程信息传递给子进程&#xA;data_a[0]: 已完成进度的百分比&#xA;data_a[1]: 目前最新进度的百分比&#xA;data_a[2]: 进度条变化速度&#xA;&amp;#39;&amp;#39;&amp;#39;&#xA; &#xA;# pbar_a的数据&#xA;data_a = Manager().list()&#xA;data_a.append(0)&#xA;data_a.append(2)&#xA;data_a.append(0.5)&#xA; &#xA;# pbar_b的数据&#xA;data_b = Manager().list()&#xA;data_b.append(0)&#xA;data_b.append(2)&#xA;data_b.append(0.5)&#xA; &#xA;# 创建进程锁&#xA;lock = Lock()&#xA; &#xA;# 创建总进度条进程&#xA;pbar_a = Process(target = progress_bar, args=(data_a, 10, 0))&#xA;pbar_a.daemon = True&#xA; &#xA;# 创建其它进度条进程&#xA;pbar_b = Process(target = progress_bar, args=(data_b, 12, 0))&#xA;pbar_b.daemon = True&#xA; &#xA;# 隐藏光标&#xA;os.system(&amp;#34;printf &amp;#39;\33[2J\33[?25l\r&amp;#39;&amp;#34;)&#xA; &#xA;# 开始其它步骤并打印进度条&#xA;pbar_a.start()&#xA;pbar_b.start()&#xA; &#xA;# Step 1&#xA;data_a[1] = 10&#xA;data_b[1] = 30&#xA;time.sleep(5)&#xA; &#xA;# Step 2&#xA;data_a[1] = 70&#xA;data_a[2] = 0.1&#xA;time.sleep(5)&#xA; &#xA;# Step 3&#xA;data_a[1] = 100&#xA;data_b[1] = 100&#xA;data_b[2] = 0.05&#xA; &#xA;# 等待进度条执行完毕&#xA;pbar_a.join()&#xA;pbar_b.join()&#xA; &#xA;# 显示光标&#xA;os.system(&amp;#34;printf &amp;#39;\33[?25h\n&amp;#39;&amp;#34;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;-End-&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/linux/linux-pipe-redirect.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/linux/linux-pipe-redirect.html</guid>
      <description>&lt;h1 id=&#34;管道与重定向详解&#34;&gt;管道与重定向详解&lt;a class=&#34;anchor&#34; href=&#34;#%e7%ae%a1%e9%81%93%e4%b8%8e%e9%87%8d%e5%ae%9a%e5%90%91%e8%af%a6%e8%a7%a3&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;unix-哲学&#34;&gt;Unix 哲学&lt;a class=&#34;anchor&#34; href=&#34;#unix-%e5%93%b2%e5%ad%a6&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;在 Unix 系统中，任何程序都可以实现三个接口，即：标准输入（stdin）、标准输出（stdout）、标准错误输出（stderr），你应该注意到，这三个东西前面都有标准两个字，是的，正是这种标准，使得 Unix 系统中的所有独立的程序可以相互传递数据而没有任何限制，这种机制给用户带来了极大的方便，这正是 Unix 哲学！&lt;/p&gt;&#xA;&lt;h2 id=&#34;什么是管道&#34;&gt;什么是管道&lt;a class=&#34;anchor&#34; href=&#34;#%e4%bb%80%e4%b9%88%e6%98%af%e7%ae%a1%e9%81%93&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;在 Unix/Linux 中，有一个常用的符号，叫做管道符，写做：&amp;quot;|&amp;quot;，举个例子：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ls / | grep usr&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;ls&lt;/code&gt; 和 &lt;code&gt;grep&lt;/code&gt; 是两个独立的程序，但是 &lt;code&gt;ls&lt;/code&gt; 的输出数据可以传给 &lt;code&gt;grep&lt;/code&gt; 继续处理，而管道符&amp;quot;|&amp;ldquo;在中间起到了数据传输的作用，正如其名，它就像一根橡胶水管，这根水管的两端可以连接任意程序，因为这些程序都向外提供了一组一模一样的接口，这样我们就可以将任意数量的不同功能的程序随意组合起来使用。&lt;/p&gt;&#xA;&lt;h2 id=&#34;什么是重定向&#34;&gt;什么是重定向&lt;a class=&#34;anchor&#34; href=&#34;#%e4%bb%80%e4%b9%88%e6%98%af%e9%87%8d%e5%ae%9a%e5%90%91&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;在上例中，管道符的一端连接到 &lt;code&gt;ls&lt;/code&gt; 的标准输出，另一端连接到 &lt;code&gt;grep&lt;/code&gt; 的标准输入，那我们能不能将其中一端连接到一个文件呢？这样我们就可以将结果数据保存下来，或者将一个文件输入到某个程序中去。当然可以，这时就用到重定向了，下面以 Bash Shell 为例，解释常用重定向符号的意义及其用法。&lt;/p&gt;&#xA;&lt;h2 id=&#34;重定向符号&#34;&gt;重定向符号&lt;a class=&#34;anchor&#34; href=&#34;#%e9%87%8d%e5%ae%9a%e5%90%91%e7%ac%a6%e5%8f%b7&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;code&gt;0&amp;lt;&lt;/code&gt; 标准输入重定向，0可省略&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;1&amp;gt;&lt;/code&gt; 标准输出重定向，1可省略&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;2&amp;gt;&lt;/code&gt; 标准错误输出重定向&lt;/li&gt;&#xA;&lt;li&gt;它们的用法都是左边给定一个程序，右边给定一个文件，&lt;code&gt;&amp;gt;&lt;/code&gt; 表示覆盖，&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 表示追加。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;输出重定向&#34;&gt;输出重定向&lt;a class=&#34;anchor&#34; href=&#34;#%e8%be%93%e5%87%ba%e9%87%8d%e5%ae%9a%e5%90%91&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;如果我想把一个程序的标准输出追加到 &lt;code&gt;o.txt&lt;/code&gt; 文件中，而错误输出覆盖到 &lt;code&gt;e.txt&lt;/code&gt; 文件中，可以这样写：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ls &amp;gt;&amp;gt; o.txt 2&amp;gt; e.txt&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;把标准输出与错误输出都写入到 &lt;code&gt;o.txt&lt;/code&gt;：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ls &amp;amp;&amp;gt; o.txt&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;或者像下面这样写&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ls &amp;gt; o.txt 2&amp;gt;&amp;amp;1&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这两种写法是等价的，但明显第一种更为简洁。&lt;/p&gt;&#xA;&lt;p&gt;但不能写成下面这样：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ls 2&amp;gt;&amp;amp;1 &amp;gt; o.txt&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;它不会像你期望的那样执行，这行命令中有两个重定向操作，所有操作符会被从左到右依次解释，首先错误输出中的数据被重定向到标准输出流中，这时标准输出指向的是终端，然后第二个重定向操作将标准输出重定向到了 &lt;code&gt;o.txt&lt;/code&gt;，但这次操作只影响了标准输出，并没有影响错误输出的指向。&lt;/p&gt;&#xA;&lt;p&gt;上面的解释有些牵强，因为博主实在不知道该怎样翻译，官方解释如下：&lt;/p&gt;&#xA;&lt;blockquote class=&#39;book-hint &#39;&gt;&#xA;&lt;p&gt;directs only the standard output to file dirlist, because the standard error was duplicated from the standard output before the standard output was redirected to dirlist.&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/linux/linux-read-file-by-line.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/linux/linux-read-file-by-line.html</guid>
      <description>&lt;h1 id=&#34;逐行读取文件的几种方法&#34;&gt;逐行读取文件的几种方法&lt;a class=&#34;anchor&#34; href=&#34;#%e9%80%90%e8%a1%8c%e8%af%bb%e5%8f%96%e6%96%87%e4%bb%b6%e7%9a%84%e5%87%a0%e7%a7%8d%e6%96%b9%e6%b3%95&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;p&gt;shell编程也是一门学问，虽然功能有限，但要完全掌握它并不容易，甚至比JAVA这样的编程语言更难掌握，因为它考虑了太多的特殊情况，在编写的时候有更多的不确定性。&lt;/p&gt;&#xA;&lt;p&gt;有一次同事问我，shell里怎样逐行读取一个文件，以处理它，没想到他会被这样的问题给难住。原来他写了一个while语句（从网上搜的）来逐行处理文件，发现这个语句没有像预期的那样执行，写法如下：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[user@node1 ~]$ vim test.sh&#xA;#!/bin/bash&#xA; &#xA;index=1&#xA;while read line&#xA;do&#xA;&#x9;echo &amp;#34;$((index++)): $line&amp;#34;&#xA;&#x9;ssh localhost &amp;#34;echo $line &amp;gt;&amp;gt; b.txt&amp;#34;&#xA;done &amp;lt; a.txt&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;执行后，只打印出了a.txt中的第一行，当时以为写错了，结果在这个小问题上折腾了很久，再次上网搜索发现原来已很多人也遇到了同样的问题，而且有人已经给出来解释与解决方法。&lt;/p&gt;&#xA;&lt;h3 id=&#34;分析原因&#34;&gt;分析原因&lt;a class=&#34;anchor&#34; href=&#34;#%e5%88%86%e6%9e%90%e5%8e%9f%e5%9b%a0&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;p&gt;首先是跟ssh这个命令有关系，因为把ssh那一个行去掉以后就一切正常了。&lt;/p&gt;&#xA;&lt;p&gt;后来看到有网友说为ssh加上-n选项就可以了，所以特地看了下ssh命令的文档，找到了如下描述：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[user@node1 ~]$ man ssh&#xA;...&#xA;-n      Redirects stdin from /dev/null (actually, prevents reading from stdin).  This must be used when ssh is run in the background.  A com-&#xA;             mon trick is to use this to run X11 programs on a remote machine.  For example, ssh -n shadows.cs.hut.fi emacs &amp;amp; will start an emacs&#xA;             on shadows.cs.hut.fi, and the X11 connection will be automatically forwarded over an encrypted channel.  The ssh program will be put&#xA;             in the background.  (This does not work if ssh needs to ask for a password or passphrase; see also the -f option.)&#xA;...&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;看到这里应该明白了，主要是因为ssh会主动从输入流中读取数据。&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/linux/linux-resolve-iptables.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/linux/linux-resolve-iptables.html</guid>
      <description>&lt;h1 id=&#34;理解iptables&#34;&gt;理解iptables&lt;a class=&#34;anchor&#34; href=&#34;#%e7%90%86%e8%a7%a3iptables&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;p&gt;iptables是Linux系统中的一个命令，也是Linux系统上最常用的防火墙，我们常见的Linux发行版如：CentOS、Ubuntu等都是用iptables作为默认的防火墙，它的强大之处在于它可以控制所有进出系统的数据包。然而，对于初次接触它的人来说，这是个比较难用的命令，不止一个人问过我怎样写一条阻止某IP的命令，因为用它增加一条防火墙规则可能需要写一条很长的命令，如果你没有了解它的工作原理，是写不出一条完整的iptables命令的。本文将剖析它的工作原理并结合例子让你更容易使用它。&lt;/p&gt;&#xA;&lt;h2 id=&#34;前提工作&#34;&gt;前提工作&lt;a class=&#34;anchor&#34; href=&#34;#%e5%89%8d%e6%8f%90%e5%b7%a5%e4%bd%9c&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;要了解iptables就先要了解数据包，这里说的数据包指的是在网络中传输的数据包，又名：报文，如果你了解过TCP协议并写过相关的代码，那么这个词应该不会陌生，如果你不了也没关系，我们这就来谈一谈这个数据包的概念。&lt;/p&gt;&#xA;&lt;blockquote class=&#39;book-hint &#39;&gt;&#xA;&lt;p&gt;其实这个数据包的结构又要用到七层协议的概念，真是一环扣一环，这里我就且当你了解七层协议的概念，如果真的不懂可以先去看看《鸟哥的Linux私房菜》，不过我会尽量讲的通俗一些，希望这不会影响到你阅读下文。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&#34;网络传输&#34;&gt;网络传输&lt;a class=&#34;anchor&#34; href=&#34;#%e7%bd%91%e7%bb%9c%e4%bc%a0%e8%be%93&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;设有两台电脑A与B，A通过网络发送一个文件给B，这个文件会被切分成一个一个的小数据包，每个数据包大小约 1KB 左右，然后转成二进制码按顺序发出去，在网络中以电讯号的形式传输给B，B接收到以后再将这些二进制码转成数据包，最后组合成一个文件。&lt;/p&gt;&#xA;&lt;h2 id=&#34;封包表头&#34;&gt;封包表头&lt;a class=&#34;anchor&#34; href=&#34;#%e5%b0%81%e5%8c%85%e8%a1%a8%e5%a4%b4&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;数据包也称为封包，一个完整的封包，除了我们需要发送的内容以外还包含了很多额外信息，也就是封包表头，主要用来标记这个数据包“从哪里来到哪里去”，在上例中，如果AB相距较远的话，中间一般会经过多个路由器和交换机，当然还有网卡网线等。。。当一个封包经过途中每个设备时，这些设备都需要读出这些封包的表头，才能知道这个封包要去哪里，然后再发给对应的设备，下一个设备收到这个封包也是一样，最终到达了B，可以说封包表头与数据本身同等重要。&lt;/p&gt;&#xA;&lt;h2 id=&#34;封包格式&#34;&gt;封包格式&lt;a class=&#34;anchor&#34; href=&#34;#%e5%b0%81%e5%8c%85%e6%a0%bc%e5%bc%8f&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;实际上，每个数据包外面套了三层封包，每层都是不同的格式，用来给不同的设备读取。如果以TCP作为传输协议，这三层封包分别为：MAC封包、IP封包、TPC封包，用下图来说明它们的关系：&#xA;&lt;img src=&#34;img/linux-resolve-iptables/linux-resolve-iptables_data-package.png&#34; alt=&#34;&#34; /&gt;&#xA;图中只是简单的列出每个封包表头中较关键的信息，其实还有很多其它信息，比如TCP封包表头中的序列号、状态码，每种封包的详细格式，这里就不展开说明了，不然的话就有点跑题了。如果想深入了解的话网上有很多相关资料。&lt;/p&gt;&#xA;&lt;h2 id=&#34;iptables中的表table&#34;&gt;iptables中的表（table）&lt;a class=&#34;anchor&#34; href=&#34;#iptables%e4%b8%ad%e7%9a%84%e8%a1%a8table&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;终于说到正点了，，iptables的原理正是分析每个封包的表头，然后根据我们设定的防火墙规则作出相应的动作。 在iptables中有表的概念，使用的时候一般用默认的表，需要的话也可以自己建表，在CentOS6.5中默认有四张表：filter、nat、mangle、raw，每张表有不同的作用:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;filter&lt;/code&gt; 表的作用就是防火墙&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;nat&lt;/code&gt; 表是用来作数据转发&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;mangle&lt;/code&gt; 表专门对特定数据包进处理&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;raw&lt;/code&gt; 表也是在特殊情况下用的，可以减少iptabls对性能的影响&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;前两个表是常用的表，后两个用的很少，而且博主一直没有用过，本文只对前两个表进行介绍。&lt;/p&gt;&#xA;&lt;h2 id=&#34;表中的链chains&#34;&gt;表中的链（chains）&lt;a class=&#34;anchor&#34; href=&#34;#%e8%a1%a8%e4%b8%ad%e7%9a%84%e9%93%bechains&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;上面的每张表中都有多个链，链可以理解为小表，每个小表用来处理不同的情况，在filter表中，默认有三个小表：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;INPUT&lt;/code&gt; 进入本机的封包要经过此链&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;OUTPUT&lt;/code&gt; 从本机发出的封包要经过此链&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;FORWARD&lt;/code&gt; 经过nat表后目标不是本机的封包会经过此链&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;在nat表中，默认也有三个小表：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;PREROUTING&lt;/code&gt; 封包进入本机时要先经过此链&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;POSTROUTING&lt;/code&gt; 封包从本机发送出去之前要经过此链&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;OUTPUT&lt;/code&gt; 经filter表过滤后的封包会经过此链&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;由此可以看出，数据包在经过这些链时，是有先后顺序的，而且每张表也是有关联的，如果我们只考虑filter表和nat表，那么封包在通过iptables时的顺序大致如下： &lt;img src=&#34;img/linux-resolve-iptables/linux-resolve-iptables_data-flow.png&#34; alt=&#34;&#34; /&gt; 上图中需要注意的是，nat表中的PREROUTING链，nat是用来做数据转发的，它可以修改封包表头中的内容，假设我在PREROUTING链中写入一条规则：将目标为本机的封包转发到 &lt;code&gt;137.137.0.200&lt;/code&gt; 这个IP上，这样当封包从PREROUTING链出来后，就不走图中的第二步，而是会经上图中的两条黄线，直接被送出本机。&lt;/p&gt;&#xA;&lt;h2 id=&#34;链中的规则rule&#34;&gt;链中的规则（rule）&lt;a class=&#34;anchor&#34; href=&#34;#%e9%93%be%e4%b8%ad%e7%9a%84%e8%a7%84%e5%88%99rule&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;每个小表中可以有多条规则，经过此小表的封包要符合此小表上的每条规则，最后才能通过，以filter表为例：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[root@blog ~]# iptables -t filter -n -L&#xA;Chain INPUT (policy DROP)&#xA;target     prot opt source               destination         &#xA;REJECT     all  --  191.96.249.0/24      0.0.0.0/0            reject-with icmp-port-unreachable&#xA;ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0            tcp dpt:22&#xA;ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0            tcp dpt:80&#xA; &#xA;Chain FORWARD (policy ACCEPT)&#xA;target     prot opt source               destination         &#xA; &#xA;Chain OUTPUT (policy ACCEPT)&#xA;target     prot opt source               destination &lt;/code&gt;&lt;/pre&gt;&lt;p&gt;命令说明：&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/linux/linux-send-mail.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/linux/linux-send-mail.html</guid>
      <description>&lt;h1 id=&#34;发送邮件的两种方式&#34;&gt;发送邮件的两种方式&lt;a class=&#34;anchor&#34; href=&#34;#%e5%8f%91%e9%80%81%e9%82%ae%e4%bb%b6%e7%9a%84%e4%b8%a4%e7%a7%8d%e6%96%b9%e5%bc%8f&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;p&gt;很多情况下，我们需要在服务器上向外发送邮件，用来获得任务报告、安全监控等等，到这里有人会说了：这还不简单！我一条命令分分种就可以搞定。 而实际上，还是有点难度的，难在哪？我想一定有人在Linux下发邮件的时候碰到过下面这样的情况 我们先来发一份邮件，Linux下发送邮件很简单：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;echo &amp;#34;hello&amp;#34; | mail -s &amp;#34;title&amp;#34; mybox@163.com -a nginx.log&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样发出去有两种结果，要么提示你发送失败，要么石沉大海，然后你各种尝试，，各种搜资料，，各种失败，， 说到底，主要是因为国内垃圾邮件太多导致的，在国内很多人利用邮箱向他们所谓的“客户”（那些并没有订阅的人）或其它使用邮箱的人群发送大量的广告，以此牟利，甚至还发往国外，使得各大邮箱服务商不得不想办法来过滤这些垃圾邮件，像上面那封邮件也会被当成是垃圾邮件，然后让我们这些用邮箱干正事的人也跟着受罪，无知的人们哪。。那我们该怎么办？本文将介绍两种可行的方法。&lt;/p&gt;&#xA;&lt;h2 id=&#34;在linux下发送邮件按照发送原理大概分为两类&#34;&gt;在Linux下发送邮件，按照发送原理大概分为两类&lt;a class=&#34;anchor&#34; href=&#34;#%e5%9c%a8linux%e4%b8%8b%e5%8f%91%e9%80%81%e9%82%ae%e4%bb%b6%e6%8c%89%e7%85%a7%e5%8f%91%e9%80%81%e5%8e%9f%e7%90%86%e5%a4%a7%e6%a6%82%e5%88%86%e4%b8%ba%e4%b8%a4%e7%b1%bb&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;一种是把 Linux 本身当做邮件服务器，由它来直接发送给其它发件人，但这种方式有个弊端，假设我要给 &lt;a href=&#34;mailto:abc@163.com&#34;&gt;abc@163.com&lt;/a&gt; 发一份邮件，那么邮件到达 163 服务时，它可能把我们的邮件当成垃圾邮件，导致邮件被拒收，本文不介绍此种方式。&lt;/li&gt;&#xA;&lt;li&gt;还有一种方式是通过第三方服务器发送，假设我要给 &lt;a href=&#34;mailto:abc@163.com&#34;&gt;abc@163.com&lt;/a&gt; 发一份邮件，我可以先把邮件交给 qq 邮件服务器，qq 服务器再转发给 163 服务器，这样就会降低被拒收的概率，但这种方式需要先通过 qq 邮件服务器的登录认证才行，这也是本文重点介绍的方式。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;先引用两句名言&#34;&gt;先引用两句名言&lt;a class=&#34;anchor&#34; href=&#34;#%e5%85%88%e5%bc%95%e7%94%a8%e4%b8%a4%e5%8f%a5%e5%90%8d%e8%a8%80&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;blockquote class=&#39;book-hint &#39;&gt;&#xA;&lt;p&gt;勿以恶小而为之，勿以善小而不为&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote class=&#39;book-hint &#39;&gt;&#xA;&lt;p&gt;地势坤，君子以厚德载物&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&#34;两种可行的方法&#34;&gt;两种可行的方法&lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%a4%e7%a7%8d%e5%8f%af%e8%a1%8c%e7%9a%84%e6%96%b9%e6%b3%95&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;h2 id=&#34;方法一利用mailx命令&#34;&gt;方法一，利用mailx命令&lt;a class=&#34;anchor&#34; href=&#34;#%e6%96%b9%e6%b3%95%e4%b8%80%e5%88%a9%e7%94%a8mailx%e5%91%bd%e4%bb%a4&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;这个方法相对简单，但只支持smtp协议，以CentOS7.2为例，如果有防火墙，请将25端口加入白名单，sendmail服务可以关闭 先安装mailx&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo yum install mailx -y&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;修改配置文件&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo echo &amp;#34;set from=${user}@163.com smtp=smtp.163.com smtp-auth-user=$user \&#xA;smtp-auth-password=$passwd smtp-auth=login&amp;#34; &amp;gt;&amp;gt; /etc/mail.rc &lt;/code&gt;&lt;/pre&gt;&lt;p&gt;发送邮件测试&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;echo -e &amp;#39;任务序号：0001&amp;#39; | mail -s &amp;#39;任务成功：0001&amp;#39; my_mail@163.com&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果发送成功的话，不需要等太久，一般一分种足够了，然后去检查一下自己的邮箱吧，， 如果你的25端口没开，或者因为其它原因导致连不到服务器，它会有提示告诉你连接超时，像下面这样：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;could not connect: 连接超时&#xA;&amp;#34;/home/user/dead.letter&amp;#34; 13/344&#xA;. . . message not sent.&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果两分种以上还没收到邮件，且没有任何提示，那可能是被服务器拒收了，而且笔者也没有找到mail的日志在哪。&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/network/tcp-theory.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/network/tcp-theory.html</guid>
      <description>&lt;h1 id=&#34;tcp原理&#34;&gt;TCP原理&lt;a class=&#34;anchor&#34; href=&#34;#tcp%e5%8e%9f%e7%90%86&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;字段说明&#34;&gt;字段说明&lt;a class=&#34;anchor&#34; href=&#34;#%e5%ad%97%e6%ae%b5%e8%af%b4%e6%98%8e&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;&lt;img src=&#34;img/tcp-theory/tcp-header.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;&#xA;&lt;h4 id=&#34;序号seq&#34;&gt;序号（SEQ）&lt;a class=&#34;anchor&#34; href=&#34;#%e5%ba%8f%e5%8f%b7seq&#34;&gt;#&lt;/a&gt;&lt;/h4&gt;&#xA;&lt;p&gt;序号类似于自增ID，用于标识当前数据包在所有数据包中的位置，它的自增规则如下：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;发送一个序号字段不为空的数据包时，该数据包本身占一个序号，故响应包的确认号&lt;code&gt; = 发送方序号+data_length+1&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;发送一个序号字段为空的数据包时（如纯ACK响应），该数据包本身不占序号，故响应包的确认号&lt;code&gt; = 发送方序号+data_length&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;确认号ack&#34;&gt;确认号（ACK）&lt;a class=&#34;anchor&#34; href=&#34;#%e7%a1%ae%e8%ae%a4%e5%8f%b7ack&#34;&gt;#&lt;/a&gt;&lt;/h4&gt;&#xA;&lt;p&gt;用于接收方通知发送方，前面的包已经收到无误，且下次希望收到序号为几的包。&lt;/p&gt;&#xA;&lt;h4 id=&#34;首部长度字段&#34;&gt;首部长度字段&lt;a class=&#34;anchor&#34; href=&#34;#%e9%a6%96%e9%83%a8%e9%95%bf%e5%ba%a6%e5%ad%97%e6%ae%b5&#34;&gt;#&lt;/a&gt;&lt;/h4&gt;&#xA;&lt;p&gt;表示TCP头部一共占几个32bit，也就是说，TCP头部的最大长度为 = (2^4-1) * (32/8) = 15 * 4 = 60字节。&lt;/p&gt;&#xA;&lt;h4 id=&#34;窗口&#34;&gt;窗口&lt;a class=&#34;anchor&#34; href=&#34;#%e7%aa%97%e5%8f%a3&#34;&gt;#&lt;/a&gt;&lt;/h4&gt;&#xA;&lt;p&gt;用于接收方通知发送方，自己的接受缓存区剩余字节数，最大为2^16-1=65535，当需要更大值时，通常加入窗口缩放因子字段（window scale），例如窗口字段为2048，缩放因子为8，则实际窗口大小为：2048 &amp;laquo; 8。&lt;/p&gt;&#xA;&lt;h4 id=&#34;标志位&#34;&gt;标志位&lt;a class=&#34;anchor&#34; href=&#34;#%e6%a0%87%e5%bf%97%e4%bd%8d&#34;&gt;#&lt;/a&gt;&lt;/h4&gt;&#xA;&lt;p&gt;URG 紧急指针（u rgent pointer）有效 。&#xA;ACK 确认序号有效。&#xA;PSH 接收方应该尽快将这个报文段交给应用层。&#xA;RST 重建连接。&#xA;SYN 同步序号用来发起一个连接。&#xA;FIN 发端完成发送任务。&lt;/p&gt;&#xA;&lt;h2 id=&#34;连接过程&#34;&gt;连接过程&lt;a class=&#34;anchor&#34; href=&#34;#%e8%bf%9e%e6%8e%a5%e8%bf%87%e7%a8%8b&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;&lt;code&gt;A&amp;gt;B&lt;/code&gt;&#xA;随机一个序号A_SEQ：100，（意义：告诉B，A的初始序号）&#xA;确认号：空&#xA;在控制区设置SYN：1&#xA;在选项区添加MSS:1460，（意义：告诉B，A能接受的最大数据区大小，通常为1460：MAC包1514-MAC头14-IP头20-TCP头20）&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;A&amp;lt;B&lt;/code&gt;&#xA;随机一个序号B_SEQ：200，（意义：告诉A，B的初始序号）&#xA;确认号：101（A_SEQ+data_length+1），（意义：告诉A，B想要序号为几的包，上一条SYN本身占一个序号）&#xA;在控制区设置SYN：1&#xA;在控制区设置ACK：1&#xA;在选项区添加MSS:1460，（意义：告诉A，B能接受的最大数据区大小，通常为1460：MAC包1514-MAC头14-IP头20-TCP头20）&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;A&amp;gt;B&lt;/code&gt;（纯ACK响应）&#xA;序号A_SEQ：空&#xA;确认号：201（B_SEQ+data_length+1），（意义：告诉B，A想要序号为几的包，上一条SYN本身占一个序号）&#xA;在控制区设置ACK：1&#xA;在选项区添加最大序列大小字段，通常为1460（MAC包1514-IP头20-TCP头20）MSS：1460&lt;/p&gt;&#xA;&lt;h2 id=&#34;发送数据过程&#34;&gt;发送数据过程&lt;a class=&#34;anchor&#34; href=&#34;#%e5%8f%91%e9%80%81%e6%95%b0%e6%8d%ae%e8%bf%87%e7%a8%8b&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;&lt;code&gt;A&amp;gt;B&lt;/code&gt;（发送三个字节abc）&#xA;序号A_SEQ：101，（意义：告诉B，这是序号为几的包）&#xA;确认号：201（B_SEQ+data_length+1），（意义：告诉B，A想要序号为几的包）&#xA;在控制区设置PUS：1&#xA;在控制区设置ACK：1&#xA;选项区：空&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
