<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>橡果笔记</title>
    <link>http://localhost:1313/golang/index.html</link>
    <description>Recent content on 橡果笔记</description>
    <generator>Hugo</generator>
    <language>en</language>
    <atom:link href="http://localhost:1313/golang/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title></title>
      <link>http://localhost:1313/golang/find-index-in-cycle-array.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/golang/find-index-in-cycle-array.html</guid>
      <description>&lt;h1 id=&#34;在循环数组中找出索引&#34;&gt;在循环数组中找出索引&lt;a class=&#34;anchor&#34; href=&#34;#%e5%9c%a8%e5%be%aa%e7%8e%af%e6%95%b0%e7%bb%84%e4%b8%ad%e6%89%be%e5%87%ba%e7%b4%a2%e5%bc%95&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;需求&#34;&gt;需求&lt;a class=&#34;anchor&#34; href=&#34;#%e9%9c%80%e6%b1%82&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;给定一个循环有序的int数组和一个int值，返回该值在数组中的位置，如果数组中没有该值则返回-1。&lt;/p&gt;&#xA;&lt;h2 id=&#34;解法概述&#34;&gt;解法概述&lt;a class=&#34;anchor&#34; href=&#34;#%e8%a7%a3%e6%b3%95%e6%a6%82%e8%bf%b0&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;先将数组分成两个小数组，这两个小数组中必定有一个是有序的，而另一个是循环有序的。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;对于有序的小数组，我们可以通过首尾值判断要找的值是否在该数组中，如果是，则用二分法处理该有序数组；如果否，我们则对另一个环循有序小数组进行第一步的处理。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;实例&#34;&gt;实例&lt;a class=&#34;anchor&#34; href=&#34;#%e5%ae%9e%e4%be%8b&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func binaryFind(arr []int, start int, end int, v int) int {&#xA;&#x9;center := (start+end)/2&#xA;&#x9;if v &amp;lt; arr[center] {&#xA;&#x9;&#x9;return binaryFind(arr, start, center-1, v)&#xA;&#x9;}else if arr[center] &amp;lt; v {&#xA;&#x9;&#x9;return binaryFind(arr, center+1, end, v)&#xA;&#x9;}else{&#xA;&#x9;&#x9;if arr[center] == v {&#xA;&#x9;&#x9;&#x9;return center&#xA;&#x9;&#x9;}else{&#xA;&#x9;&#x9;&#x9;return -1&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;}&#xA;&#xA;func getIndex(arr []int, start int, end int, v int) int {&#xA;&#x9;center := (start+end)/2&#xA;&#x9;if arr[start] &amp;lt; arr[center] {&#xA;&#x9;&#x9;if arr[start] &amp;lt;= v &amp;amp;&amp;amp; v &amp;lt;= arr[center] {&#xA;&#x9;&#x9;&#x9;return binaryFind(arr, start, center, v)&#xA;&#x9;&#x9;}else{&#xA;&#x9;&#x9;&#x9;return getIndex(arr, center+1, end, v)&#xA;&#x9;&#x9;}&#xA;&#x9;}else{&#xA;&#x9;&#x9;if arr[center] &amp;lt;= v &amp;amp;&amp;amp; v &amp;lt;= arr[end] {&#xA;&#x9;&#x9;&#x9;return binaryFind(arr, center, end, v)&#xA;&#x9;&#x9;}else{&#xA;&#x9;&#x9;&#x9;return getIndex(arr, start, center-1, v)&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;}&#xA;&#xA;func main() {&#xA;&#x9;arr := []int{5,6,7,8,9,1,2,3,4}&#xA;&#x9;index := getIndex(arr, 0, len(arr)-1, 3)&#xA;&#x9;println(index)&#xA;}&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/golang/golang-get-package-to-dir.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/golang/golang-get-package-to-dir.html</guid>
      <description>&lt;h1 id=&#34;下载包到指定目录&#34;&gt;下载包到指定目录&lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%8b%e8%bd%bd%e5%8c%85%e5%88%b0%e6%8c%87%e5%ae%9a%e7%9b%ae%e5%bd%95&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;p&gt;在一个go项目中，通常会引很多第三方包，如果想要你的源码在任何地方都能被编译，那么需要将这些包放在项目的vendor目录下，可惜的是&lt;code&gt;go get&lt;/code&gt;命令不能将包下载到指定的目录中去，这就需要先下载到&lt;code&gt;$GOPATH/src/&lt;/code&gt;目录下，再手动铐到vendor下，这能忍吗？&lt;/p&gt;&#xA;&lt;p&gt;这时有两种选，一种是使用govendor命令，但我不喜欢，它的运行本身会依赖一个配置文件，还需要我去记一些乱七八糟的命令，另一种思路是先创建一个空的临时的GOPATH目录，将需要的包用&lt;code&gt;go get&lt;/code&gt;下载进入，然后将所有的包铐出来，可以写个简单的脚本来做。&lt;/p&gt;&#xA;&lt;p&gt;假设我现在要下载一个golang包&lt;code&gt;github.com/coreos/etcd/client&lt;/code&gt;到当前项目的vendor目录下，执行以下命令：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;mkdir /tmp/go/{bin,pkg,src}&#xA;GOPATH=/tmp/go go get -v github.com/coreos/etcd/client&#xA;/bin/mv -rf /tmp/go/src/* vendor/&#xA;/bin/rm -rf /tmp/go&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/golang/golang-grpc-demo.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/golang/golang-grpc-demo.html</guid>
      <description>&lt;h1 id=&#34;grpc使用指南&#34;&gt;gRPC使用指南&lt;a class=&#34;anchor&#34; href=&#34;#grpc%e4%bd%bf%e7%94%a8%e6%8c%87%e5%8d%97&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;p&gt;gRPC是一个由google开源的RPC框架，它支持多种语言之间的相互调用，依赖开源项目&lt;code&gt;google/protobuf&lt;/code&gt;作为序列化工具。&lt;/p&gt;&#xA;&lt;p&gt;相比于几年前的gRPC，新版gRPC的使用方式发生了一些改变，编译&lt;code&gt;.proto&lt;/code&gt;文件时所用的命令已经与之前不同，而且产生的&lt;code&gt;.go&lt;/code&gt;文件按照数据结构序列化和使用接口分为两个文件。&lt;/p&gt;&#xA;&lt;h2 id=&#34;准备环境&#34;&gt;准备环境&lt;a class=&#34;anchor&#34; href=&#34;#%e5%87%86%e5%a4%87%e7%8e%af%e5%a2%83&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;安装golang&#34;&gt;安装Golang&lt;a class=&#34;anchor&#34; href=&#34;#%e5%ae%89%e8%a3%85golang&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;p&gt;安装&lt;a href=&#34;https://golang.org/dl/&#34;&gt;最新版Golang&lt;/a&gt;。&lt;/p&gt;&#xA;&lt;h3 id=&#34;安装protocol-buffers编译器&#34;&gt;安装Protocol Buffers编译器&lt;a class=&#34;anchor&#34; href=&#34;#%e5%ae%89%e8%a3%85protocol-buffers%e7%bc%96%e8%af%91%e5%99%a8&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;p&gt;&lt;code&gt;protoc&lt;/code&gt;是一个二进制文件，用来编译&lt;code&gt;.proto&lt;/code&gt;文件，输出指定语言的源码。进入&lt;a href=&#34;https://github.com/google/protobuf/releases&#34;&gt;&lt;code&gt;protoc&lt;/code&gt;发布页面&lt;/a&gt;，按照自己的平台下载相应压缩包，比如64位linux就下载&lt;a href=&#34;https://github.com/protocolbuffers/protobuf/releases/download/v3.13.0/protoc-3.13.0-linux-x86_64.zip&#34;&gt;&lt;code&gt;protoc-3.13.0-linux-x86_64.zip&lt;/code&gt;&lt;/a&gt;，解压后把二进制文件放到&lt;code&gt;$GOPATH/bin&lt;/code&gt;下。&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ protoc --version&#xA;libprotoc 3.13.0&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;安装protocol-buffers-go插件&#34;&gt;安装Protocol Buffers GO插件&lt;a class=&#34;anchor&#34; href=&#34;#%e5%ae%89%e8%a3%85protocol-buffers-go%e6%8f%92%e4%bb%b6&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;p&gt;&lt;code&gt;protoc-gen-go&lt;/code&gt;和&lt;code&gt;protoc-gen-go-grpc&lt;/code&gt;两个二进制文件会被&lt;code&gt;protoc&lt;/code&gt;调用，前者用于从&lt;code&gt;.proto&lt;/code&gt;文件中编译出Go语言数据结构，这些数据结构带有序列化函数，后者用于产生Go语言编程接口。&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go get google.golang.org/protobuf/cmd/protoc-gen-go \&#xA;    google.golang.org/grpc/cmd/protoc-gen-go-grpc&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;添加golang依赖&#34;&gt;添加Golang依赖&lt;a class=&#34;anchor&#34; href=&#34;#%e6%b7%bb%e5%8a%a0golang%e4%be%9d%e8%b5%96&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;p&gt;执行前确保项目中包含了&lt;code&gt;go.mod&lt;/code&gt;文件。&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go get google.golang.org/grpc&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;编写一个demo&#34;&gt;编写一个Demo&lt;a class=&#34;anchor&#34; href=&#34;#%e7%bc%96%e5%86%99%e4%b8%80%e4%b8%aademo&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;新建一个名为grpc的Golang项目，结构如下：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;grpc&#xA;├── client&#xA;│   └── main.go&#xA;├── proto&#xA;│   ├── grpc_grpc.pb.go&#xA;│   ├── grpc.pb.go&#xA;│   └── grpc.proto&#xA;└── server&#xA;    └── main.go&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;编写proto文件&#34;&gt;编写.proto文件&lt;a class=&#34;anchor&#34; href=&#34;#%e7%bc%96%e5%86%99proto%e6%96%87%e4%bb%b6&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;p&gt;&lt;code&gt;grpc/proto/grpc.proto&lt;/code&gt;&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ssyntax = &amp;#34;proto3&amp;#34;;&#xA;&#xA;package proto;&#xA;&#xA;option go_package = &amp;#34;github.com/sycki/examples/grpc&amp;#34;;&#xA;&#xA;// 定义一个RPC Server&#xA;// 包含两个函数可供Client调用&#xA;service Greeter {&#xA;  rpc AddUser (UserRequest) returns (UserResponse);&#xA;  rpc GetUser (UserRequest) returns (UserResponse);&#xA;}&#xA;// 调用时的数据格式&#xA;message UserRequest {&#xA;&#x9;string Name = 1;&#xA;&#x9;int32 age = 2;&#xA;&#x9;string address = 3;&#xA;}&#xA;// 返回值的数据格式&#xA;message UserResponse {&#xA;&#x9;string Name = 1;&#xA;&#x9;int32 age = 2;&#xA;&#x9;string address = 3;&#xA;}&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;生成golang代码&#34;&gt;生成Golang代码&lt;a class=&#34;anchor&#34; href=&#34;#%e7%94%9f%e6%88%90golang%e4%bb%a3%e7%a0%81&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;protoc --go_out=. --go_opt=paths=source_relative \&#xA;--go-grpc_out=. --go-grpc_opt=paths=source_relative \&#xA;proto/grpc.proto&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;执行成功会在proto目录下生成两个&lt;code&gt;.go&lt;/code&gt;源文件，一个包含了数据结构，一个包含调用接口。&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/golang/golang-profiler.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/golang/golang-profiler.html</guid>
      <description>&lt;h1 id=&#34;应用性能分析&#34;&gt;应用性能分析&lt;a class=&#34;anchor&#34; href=&#34;#%e5%ba%94%e7%94%a8%e6%80%a7%e8%83%bd%e5%88%86%e6%9e%90&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;p&gt;本文介绍使用pprof工具分析go程序的方法，让你快速找到程序中的性能瓶颈。&lt;/p&gt;&#xA;&lt;h2 id=&#34;基本原理&#34;&gt;基本原理&lt;a class=&#34;anchor&#34; href=&#34;#%e5%9f%ba%e6%9c%ac%e5%8e%9f%e7%90%86&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;在go的安装包中提供了pprof性能分析工具，使用方法为&lt;code&gt;go tool pprof &amp;lt;运行时数据&amp;gt;&lt;/code&gt;，然后它可以根据我们提供的数据分析出程序中各函数据CPU使用情况、内存使用情况、各协程运行情况，其中&amp;lt;运行时数据&amp;gt;的获取有两种方式，一种是让程序在执行时直接保存运行时数据，一种是通过程序的HTTP端口动态获取，这两种方式都需要入侵代码，也就是在目标程序中插入&lt;code&gt;runtime/pprof&lt;/code&gt;或&lt;code&gt;net/http/pprof&lt;/code&gt;两个包的代码来生成pprof工具需要的数据。下面以HTTP方式为例介绍pprof用法。&lt;/p&gt;&#xA;&lt;h2 id=&#34;准备数据&#34;&gt;准备数据&lt;a class=&#34;anchor&#34; href=&#34;#%e5%87%86%e5%a4%87%e6%95%b0%e6%8d%ae&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;只需在目标程序中以匿名方式引入&lt;code&gt;net/http/pprof&lt;/code&gt;包，然后启动一个http服务即可，如下：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;import _ &amp;#34;net/http/pprof&amp;#34;&#xA;func main(){&#xA;&#x9;go func() {&#xA;&#x9;&#x9;logger.Error(http.ListenAndServe(&amp;#34;:8081&amp;#34;, nil))&#xA;&#x9;}()&#xA;&#x9;...&#xA;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后pprof就可以从8081端口上分析程序了。&lt;/p&gt;&#xA;&lt;h2 id=&#34;开始分析&#34;&gt;开始分析&lt;a class=&#34;anchor&#34; href=&#34;#%e5%bc%80%e5%a7%8b%e5%88%86%e6%9e%90&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;这时先在本地安装一个命令行工具，pprof在生成图片时会用到：&lt;code&gt;brew install graphviz&lt;/code&gt;（mac命令）&lt;/p&gt;&#xA;&lt;p&gt;分析CPU性能：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go tool pprof http://localhost:8081/debug/pprof/profile&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;命令执行后会阻塞30秒来收集数据，然后进入一个shell界面，等待输入命令：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Fetching profile over HTTP from http://localhost:8081/debug/pprof/profile&#xA;Saved profile in /Users/sycki/pprof/pprof.samples.cpu.001.pb.gz&#xA;Type: cpu&#xA;Time: Oct 16, 2018 at 6:31pm (CST)&#xA;Duration: 30.01s, Total samples = 240ms (  0.8%)&#xA;Entering interactive mode (type &amp;#34;help&amp;#34; for commands, &amp;#34;o&amp;#34; for options)&#xA;(pprof) png&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这时我们输入&lt;code&gt;png&lt;/code&gt;它就会生成一张png的图片，很清楚的画出占用CPU时间较多函数以及它们关系：&#xA;&lt;img src=&#34;img/golang-profiler/profile001.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;&#xA;&lt;p&gt;分析内存的方法一样：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go tool pprof http://localhost:3999/debug/pprof/heap&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;协程执行情况：&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/golang/golang-regexp-performance.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/golang/golang-regexp-performance.html</guid>
      <description>&lt;h1 id=&#34;正则性能优化&#34;&gt;正则性能优化&lt;a class=&#34;anchor&#34; href=&#34;#%e6%ad%a3%e5%88%99%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;p&gt;最近在编码时用到了golang（版本为&lt;code&gt;1.11.0&lt;/code&gt;）正则库中的&lt;code&gt;ReplaceAllLiteral(data, nil)&lt;/code&gt;函数，发现golang的正则替换比java和php的正则替换慢很多，后来找到了方法，可以大幅度提升golang正则的性能，文章后面部分有具体的对比数据。&lt;/p&gt;&#xA;&lt;h2 id=&#34;golang正则为什么比php慢&#34;&gt;golang正则为什么比php慢&lt;a class=&#34;anchor&#34; href=&#34;#golang%e6%ad%a3%e5%88%99%e4%b8%ba%e4%bb%80%e4%b9%88%e6%af%94php%e6%85%a2&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;我并不是第一个发现golang的正则库比php慢的，因为在golang的开源社区中有人已经提出了类似的问题，见&lt;a href=&#34;https://github.com/golang/go/issues/19629&#34;&gt;issues&lt;/a&gt;，有人回复说：像php、python这样的语言的正则引擎，是用高度优化的C代码实现的，所以比较快。好吧，但java也比golang快至少可以说明golang的正则引擎还是有优化的空间。&lt;/p&gt;&#xA;&lt;h2 id=&#34;提升golang正则性能&#34;&gt;提升golang正则性能&lt;a class=&#34;anchor&#34; href=&#34;#%e6%8f%90%e5%8d%87golang%e6%ad%a3%e5%88%99%e6%80%a7%e8%83%bd&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;后来我现了一个叫&lt;code&gt;rure-go&lt;/code&gt;的项目，详见 &lt;a href=&#34;github.com/BurntSushi/rure-go&#34;&gt;github.com&lt;/a&gt;，这个项目是一个用Rust语言实现的golang正则引擎，原理是先将Rust语言的正则库编译为一个.so动态库，然后用golang语言封装出来一套正则处理函数去调用.so动态库中的函数。&lt;/p&gt;&#xA;&lt;p&gt;具体步骤：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;先安装Rust：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;curl https://sh.rustup.rs -sSf | sh&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;将Rust的正则库编译为动态库（Rust支持交叉编译）：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;git clone git://github.com/rust-lang-nursery/regex&#xA;cargo build --release --manifest-path ./regex/regex-capi/Cargo.toml&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这时在&lt;code&gt;./regex/target/release/&lt;/code&gt;目录下会出现一个.so文件，把它放到你喜欢地方，比如在你的golang项目下新建一个&lt;code&gt;./lib&lt;/code&gt;目录，然后就可以删掉Rust相关的东西了。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;在你的golang项目中引入&lt;code&gt;rure-go&lt;/code&gt;项目，然后编写你的业务逻辑，注意这个包中没有&lt;code&gt;ReplaceAll()&lt;/code&gt;这样的函数，所以要达到&lt;code&gt;ReplaceAll(data, nil)&lt;/code&gt;的效果，需要先用&lt;code&gt;FindAll()&lt;/code&gt;在data中找到所有匹配的位置，然后把所有不匹配的内容提取出来拼到一起。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;编译和运行时需要指定动态库的位置，因为&lt;code&gt;github.com/BurntSushi/rure-go&lt;/code&gt;会依赖它，注意，当指定了动态库后就不能使用go的交叉编译了：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;如果你的电脑是MAC&#xA;编译&#xA;CGO_LDFLAGS=&amp;#34;-L$(pwd)/lib&amp;#34; go build ./your/project/main&#xA;启动&#xA;DYLD_LIBRARY_PATH=./lib ./main&#xA;&#xA;如果你的电脑是Linux&#xA;编译&#xA;CGO_LDFLAGS=&amp;#34;-L$(pwd)/lib&amp;#34; go build ./your/project/main&#xA;启动&#xA;LD_LIBRARY_PATH=./lib ./main&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;性能对比&#34;&gt;性能对比&lt;a class=&#34;anchor&#34; href=&#34;#%e6%80%a7%e8%83%bd%e5%af%b9%e6%af%94&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;对比php&#34;&gt;对比php&lt;a class=&#34;anchor&#34; href=&#34;#%e5%af%b9%e6%af%94php&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;调用次数&lt;/th&gt;&#xA;          &lt;th&gt;php用时(秒)&lt;/th&gt;&#xA;          &lt;th&gt;go优化前(秒)&lt;/th&gt;&#xA;          &lt;th&gt;go优化后(秒)&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;100&lt;/td&gt;&#xA;          &lt;td&gt;3.119&lt;/td&gt;&#xA;          &lt;td&gt;未记录&lt;/td&gt;&#xA;          &lt;td&gt;1.864&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;1000&lt;/td&gt;&#xA;          &lt;td&gt;27.115&lt;/td&gt;&#xA;          &lt;td&gt;45.285&lt;/td&gt;&#xA;          &lt;td&gt;16.475&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;5000&lt;/td&gt;&#xA;          &lt;td&gt;135.88&lt;/td&gt;&#xA;          &lt;td&gt;未记录&lt;/td&gt;&#xA;          &lt;td&gt;82.42&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h3 id=&#34;对比java&#34;&gt;对比java&lt;a class=&#34;anchor&#34; href=&#34;#%e5%af%b9%e6%af%94java&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;调用次数&lt;/th&gt;&#xA;          &lt;th&gt;java用时(秒)&lt;/th&gt;&#xA;          &lt;th&gt;go优化前(秒)&lt;/th&gt;&#xA;          &lt;th&gt;go优化后(秒)&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;1000&lt;/td&gt;&#xA;          &lt;td&gt;5.210&lt;/td&gt;&#xA;          &lt;td&gt;9.399&lt;/td&gt;&#xA;          &lt;td&gt;1.155&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;2000&lt;/td&gt;&#xA;          &lt;td&gt;10.652&lt;/td&gt;&#xA;          &lt;td&gt;18.844&lt;/td&gt;&#xA;          &lt;td&gt;2.286&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;10000&lt;/td&gt;&#xA;          &lt;td&gt;50.156&lt;/td&gt;&#xA;          &lt;td&gt;93.974&lt;/td&gt;&#xA;          &lt;td&gt;11.163&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h2 id=&#34;总结&#34;&gt;总结&lt;a class=&#34;anchor&#34; href=&#34;#%e6%80%bb%e7%bb%93&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;golang标准库中的正则处理引擎性能比较差，如果遇到对性能要求较高的需求，可以用&lt;code&gt;github.com/BurntSushi/rure-go&lt;/code&gt;包代替，它可以大幅提升正则处理性能。&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/golang/golang-tls-web.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/golang/golang-tls-web.html</guid>
      <description>&lt;h1 id=&#34;web应用开发&#34;&gt;web应用开发&lt;a class=&#34;anchor&#34; href=&#34;#web%e5%ba%94%e7%94%a8%e5%bc%80%e5%8f%91&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;p&gt;编写一个基于安全协议的WEB服务器，并将80端口重定向到443端口。&lt;/p&gt;&#xA;&lt;h2 id=&#34;创建一个服务端&#34;&gt;创建一个服务端&lt;a class=&#34;anchor&#34; href=&#34;#%e5%88%9b%e5%bb%ba%e4%b8%80%e4%b8%aa%e6%9c%8d%e5%8a%a1%e7%ab%af&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main&#xA;&#xA;func main() {&#xA;&#x9;// 指定证书文件并启动服务&#xA;&#x9;s := &amp;amp;http.Server{Addr: &amp;#34;:443&amp;#34;, Handler: buildMux()}&#xA;&#x9;go s.ListenAndServeTLS(&amp;#34;/opt/ssl/cert.pem&amp;#34;, &amp;#34;/opt/ssl/privkey.pem&amp;#34;)&#xA;&#xA;&#x9;// 再创建一个监听在80端口的Server，它负责把80上的所有请求重定向到443端口&#xA;&#x9;s80 := &amp;amp;http.Server{Addr: &amp;#34;:80&amp;#34;, Handler: http.HandlerFunc(redirect80), ErrorLog: ctx.GetLogger()}&#xA;&#x9;go s80.ListenAndServe()&#xA;&#xA;&#x9;// 创建一个channel，用来监听kill信号&#xA;&#x9;stop := make(chan string, 1)&#xA;&#x9;defer close(stop)&#xA;&#x9;signal.Notify(sig, os.Interrupt, syscall.SIGTERM)&#xA;&#x9;&amp;lt;-stop&#xA;&#x9;&#xA;&#x9;s.Shutdown(context.Background())&#xA;&#x9;s80.Shutdown(context.Background())&#xA;}&#xA;&#xA;func redirect80(w http.ResponseWriter, r *http.Request) {&#xA;        target := &amp;#34;https://&amp;#34; + r.Host + r.URL.Path&#xA;        if len(r.URL.RawQuery) &amp;gt; 0 {&#xA;                target += &amp;#34;?&amp;#34; + r.URL.RawQuery&#xA;        }&#xA;&#xA;        http.Redirect(w, r, target, http.StatusTemporaryRedirect)&#xA;}&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;uri匹配规则&#34;&gt;URI匹配规则&lt;a class=&#34;anchor&#34; href=&#34;#uri%e5%8c%b9%e9%85%8d%e8%a7%84%e5%88%99&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;下面代码是向ServerMux注册一个Handler：&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/golang/golang-web-and-curl.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/golang/golang-web-and-curl.html</guid>
      <description>&lt;h1 id=&#34;解析客户端参数&#34;&gt;解析客户端参数&lt;a class=&#34;anchor&#34; href=&#34;#%e8%a7%a3%e6%9e%90%e5%ae%a2%e6%88%b7%e7%ab%af%e5%8f%82%e6%95%b0&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;h3 id=&#34;1发送简单键值对&#34;&gt;1.发送简单键值对&lt;a class=&#34;anchor&#34; href=&#34;#1%e5%8f%91%e9%80%81%e7%ae%80%e5%8d%95%e9%94%ae%e5%80%bc%e5%af%b9&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;curl -H &amp;#34;Content-Type: application/x-www-form-urlencoded&amp;#34; \&#xA;-d id=100 \&#xA;-d name=golang \&#xA;localhost/books&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这时curl会把数据拼接为&lt;code&gt;id=100&amp;amp;name=golang&lt;/code&gt;形式放入请求体中，不对数据进行编码，意味着如果数据中含有&lt;code&gt;&amp;amp; ? = @&lt;/code&gt;等符号时，服务端将无法解析出键值对。&lt;/p&gt;&#xA;&lt;h3 id=&#34;服务端解析&#34;&gt;服务端解析&lt;a class=&#34;anchor&#34; href=&#34;#%e6%9c%8d%e5%8a%a1%e7%ab%af%e8%a7%a3%e6%9e%90&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;p&gt;服务端收到请求后发现内容类型为&lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt;，所以当&lt;code&gt;r.ParseForm()&lt;/code&gt;函数被执行时，它会将&lt;code&gt;r.Body&lt;/code&gt;中的数据解析为键值对形式，并保存在map结构中，以便使用&lt;code&gt;r.FormValue()&lt;/code&gt;函数获取。&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func books(w http.ResponseWriter, r *http.Request) {&#xA;    id := r.FormValue(&amp;#34;id&amp;#34;)&#xA;    name := r.FormValue(&amp;#34;name&amp;#34;)&#xA;}&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;2发送编码的键值对&#34;&gt;2.发送编码的键值对&lt;a class=&#34;anchor&#34; href=&#34;#2%e5%8f%91%e9%80%81%e7%bc%96%e7%a0%81%e7%9a%84%e9%94%ae%e5%80%bc%e5%af%b9&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;curl -H &amp;#34;Content-Type: application/x-www-form-urlencoded&amp;#34; \&#xA;localhost/books&#xA;--data-urlencode &amp;#39;id=100&amp;#39; \&#xA;--data-urlencode &amp;#34;bookContent=`&amp;lt;/tmp/book.txt`&amp;#34;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这时curl同样会将所有键值对用&lt;code&gt;&amp;amp;&lt;/code&gt;符号拼接起来，不同的是它会将所有值部分编码为&lt;code&gt;%39%AC+%0B&lt;/code&gt;形式，也就是用三个字节代表一个字节，这样服务端就不会出现解析不了的问题，如果有多个键值对，必须用多个&lt;code&gt;--data-urlencode&lt;/code&gt;标识。&lt;/p&gt;&#xA;&lt;h3 id=&#34;服务端解析-1&#34;&gt;服务端解析&lt;a class=&#34;anchor&#34; href=&#34;#%e6%9c%8d%e5%8a%a1%e7%ab%af%e8%a7%a3%e6%9e%90-1&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;p&gt;服务端收到请求后发现内容类型为&lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt;，所以当&lt;code&gt;r.ParseForm()&lt;/code&gt;函数被执行时，它会将&lt;code&gt;r.Body&lt;/code&gt;中的数据解析为键值对形式，同时所有数据会被解码为原始数据（其实在上一种情况中，数据同样会被解码一次，但解码后的数据与解码前是一样的），然后保存在map结构中，以便使用&lt;code&gt;r.FormValue()&lt;/code&gt;函数获取。&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func books(w http.ResponseWriter, r *http.Request) {&#xA;    id := r.FormValue(&amp;#34;id&amp;#34;)&#xA;    bookContent := r.FormValue(&amp;#34;bookContent&amp;#34;)&#xA;}&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;3发送文件中的数据&#34;&gt;3.发送文件中的数据&lt;a class=&#34;anchor&#34; href=&#34;#3%e5%8f%91%e9%80%81%e6%96%87%e4%bb%b6%e4%b8%ad%e7%9a%84%e6%95%b0%e6%8d%ae&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;curl -H &amp;#34;Content-Type: text/plain&amp;#34; \&#xA;--data-binary @file.txt \&#xA;&amp;#39;localhost/books?id=100&amp;amp;name=book1&amp;#39;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这时我们并不希望我们的数据被服务端当做键对来解析，所以应该用其它字段值来替换&lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt;，比如我们设置为&lt;code&gt;text/plain&lt;/code&gt;或&lt;code&gt;application/json&lt;/code&gt;都是可以的，这里没有用&lt;code&gt;-d&lt;/code&gt;是因为&lt;code&gt;-d&lt;/code&gt;会默认去掉文件内容中所有的&lt;code&gt;\n&lt;/code&gt;和&lt;code&gt;\r&lt;/code&gt;，然后放入请求体中，显然我们并不希望数据被偷偷改掉，所以应该用&lt;code&gt;--data-binary&lt;/code&gt;选项来代替&lt;code&gt;-d&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;h3 id=&#34;服务端解析-2&#34;&gt;服务端解析&lt;a class=&#34;anchor&#34; href=&#34;#%e6%9c%8d%e5%8a%a1%e7%ab%af%e8%a7%a3%e6%9e%90-2&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;p&gt;服务端收到请求后发现内容类型为&lt;code&gt;text/plain&lt;/code&gt;，这时你仍可以执行&lt;code&gt;r.ParseForm()&lt;/code&gt;函数，但它只会解析&lt;code&gt;query&lt;/code&gt;中的参数而不会解析&lt;code&gt;r.Body&lt;/code&gt;中的数据。&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func books(w http.ResponseWriter, r *http.Request) {&#xA;    id := r.FormValue(&amp;#34;id&amp;#34;)&#xA;    name := r.FormValue(&amp;#34;name&amp;#34;)&#xA;    data, _ := ioutil.ReadAll(r.Body)&#xA;}&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;4发送字符串&#34;&gt;4.发送字符串&lt;a class=&#34;anchor&#34; href=&#34;#4%e5%8f%91%e9%80%81%e5%ad%97%e7%ac%a6%e4%b8%b2&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;curl -H &amp;#34;Content-Type: application/json&amp;#34; \&#xA;-d &amp;#39;{&amp;#34;k1&amp;#34;: &amp;#34;v1&amp;#34;}&amp;#39; \&#xA;localhost/books&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这时数据被直接放入请求体，它与&lt;code&gt;text/plain&lt;/code&gt;的行为是一样的。&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/golang/unicode-to-zh.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/golang/unicode-to-zh.html</guid>
      <description>&lt;h1 id=&#34;unicode转中文&#34;&gt;unicode转中文&lt;a class=&#34;anchor&#34; href=&#34;#unicode%e8%bd%ac%e4%b8%ad%e6%96%87&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// unicode2zh 将unicode转为中文，并去掉空格&#xA;func unicode2zh(uText string) (content string) {&#xA;&#x9;for i, char := range strings.Split(uText, `\\u`) {&#xA;&#x9;&#x9;if i &amp;lt; 1 {&#xA;&#x9;&#x9;&#x9;content = char&#xA;&#x9;&#x9;&#x9;continue&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;length := len(char)&#xA;&#x9;&#x9;if length &amp;gt; 3 {&#xA;&#x9;&#x9;&#x9;pre := char[:4]&#xA;&#x9;&#x9;&#x9;zh, err := strconv.ParseInt(pre, 16, 32)&#xA;&#x9;&#x9;&#x9;if err != nil {&#xA;&#x9;&#x9;&#x9;&#x9;content += char&#xA;&#x9;&#x9;&#x9;&#x9;continue&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;content += fmt.Sprintf(&amp;#34;%c&amp;#34;, zh)&#xA;&#xA;&#x9;&#x9;&#x9;if length &amp;gt; 4 {&#xA;&#x9;&#x9;&#x9;&#x9;content += char[4:]&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;}&#xA;&#xA;&#x9;content = strings.TrimSpace(content)&#xA;&#xA;&#x9;return content&#xA;}&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
  </channel>
</rss>
