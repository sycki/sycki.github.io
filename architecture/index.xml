<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>架构设计 on 橡果笔记</title>
    <link>http://localhost:1313/architecture/index.html</link>
    <description>Recent content in 架构设计 on 橡果笔记</description>
    <generator>Hugo</generator>
    <language>en</language>
    <atom:link href="http://localhost:1313/architecture/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title></title>
      <link>http://localhost:1313/architecture/cloud-plateform-loadbalancer.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/architecture/cloud-plateform-loadbalancer.html</guid>
      <description>&lt;h1 id=&#34;云平台---负载均衡器&#34;&gt;云平台 - 负载均衡器&lt;a class=&#34;anchor&#34; href=&#34;#%e4%ba%91%e5%b9%b3%e5%8f%b0---%e8%b4%9f%e8%bd%bd%e5%9d%87%e8%a1%a1%e5%99%a8&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;p&gt;负载均衡是云平台的重要组成部分，本文介绍开源项目&lt;a href=&#34;https://github.com/goodrain/rainbond&#34;&gt;好雨云帮平台&lt;/a&gt;(以下简称云帮)中负载均衡模块的具体实现，以及它出于什么样的考虑，希望能给有需要的同学带来一些参考和思路。&lt;/p&gt;&#xA;&lt;h2 id=&#34;为什么需要负载均衡&#34;&gt;为什么需要负载均衡&lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%ba%e4%bb%80%e4%b9%88%e9%9c%80%e8%a6%81%e8%b4%9f%e8%bd%bd%e5%9d%87%e8%a1%a1&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;首先，云帮平台的内部网络划分是支持多租户的，每个租户有一个私有的IP段，不同租户的网络是相互不可见的，当我们把一个容器化的应用部署到云帮后，云帮平台会为这个容器分配一个内部IP，用于同一租户中的不同应用在集群内部通信，而从集群外部是不能直接访问的。所以我们需要有一个集群入口控制器让用户能方便地访问这些应用。&lt;/p&gt;&#xA;&lt;p&gt;其次，云帮中部署的每个应用都可以有多个实例，假设我们为一个WEB应用部署了三个实例，然后每个实例分担一部分流量，这时我每就需要在它们前面加一个负载均衡器来分发流量给三个实例。&lt;/p&gt;&#xA;&lt;p&gt;除了上述的基本功能以外，我们的负载均衡器还必须支持更多的功能，比如：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;入口控制器能够根据数据包信息（如协议、端口号、主机名等）将请求转发给指定的应用。&lt;/li&gt;&#xA;&lt;li&gt;实时地发现集群中应用的变化（如添加自定义域名、添加证书、添加端口等）并动态更自身的转发规则。&lt;/li&gt;&#xA;&lt;li&gt;要同时支持HTTP、TLS、TCP和UDP协议，因为有时不只WEB应用需要向外提供服条，像RPC、MySQL等也需要对外开放。&lt;/li&gt;&#xA;&lt;li&gt;最后一点也很重要，那就是支持高可用。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;综上所述，我们需要一个同时支持L4、L7的负载均衡器集群，还必须能够自动发现集群中的应用变化以更新自己的转发规则。&lt;/p&gt;&#xA;&lt;h2 id=&#34;云帮中的负载均衡&#34;&gt;云帮中的负载均衡&lt;a class=&#34;anchor&#34; href=&#34;#%e4%ba%91%e5%b8%ae%e4%b8%ad%e7%9a%84%e8%b4%9f%e8%bd%bd%e5%9d%87%e8%a1%a1&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;h3 id=&#34;整体架构&#34;&gt;整体架构&lt;a class=&#34;anchor&#34; href=&#34;#%e6%95%b4%e4%bd%93%e6%9e%b6%e6%9e%84&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;p&gt;以下是云帮负载均衡模块的架构示意图：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;cloud-plateform-loadbalancer/loadbalancer-architecture.png&#34; alt=&#34;loadbalancer-architecture&#34; /&gt;&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;code&gt;web&lt;/code&gt;：表示云帮中的一个应用，并且有三个实例。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;api-server&lt;/code&gt;：表示kubeneters的kube-apiserver组件。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;entrance&lt;/code&gt;：表示云帮的负载均衡器通用接口，支持多种负载均衡器插件。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;entrance实现&#34;&gt;Entrance实现&lt;a class=&#34;anchor&#34; href=&#34;#entrance%e5%ae%9e%e7%8e%b0&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;p&gt;云帮中的负载均衡是面向应用的，不同的应用可以使用不同的负载均衡，所以我们设计了Entrance组件，它可以集成多种负载均衡插件，OpenResty就是其中之一，这意味着云帮不仅支持OpenResty，还可以方支持其它负载均衡插件。&lt;/p&gt;&#xA;&lt;p&gt;它的主要工作是从kube-apiserver中通过Restful API监听应用容器的IP、端口，service和endpoint等的资源变化，然后把这些资源抽象为通用的负载均衡资源并缓存在ETCD中，这些通用资源有：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;Pool&lt;/code&gt;：表示一个负载均衡池，其中包括多个节点，对应上图中的三个WEB实例。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;Node&lt;/code&gt;：表示Pool中的一个节点，对应上图中的其中一个WEB实例。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;Domain&lt;/code&gt;：表示一个域名，负载均衡器可以识别一个数据包中的域名信息然后将数据转发给对应的Pool。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;VirtualService&lt;/code&gt;：表示监听了某个端口的虚拟主机，还指明了端口的协议名称，主要用来处理L4入口控制和负载均衡。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;Rule&lt;/code&gt;：表示一条转发规则，用来描述域名跟Pool的对应关系，还指明了端口的协议名称与证书信息，主要用来处理L7入口控制和负载均衡。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;当有资源发生变化时，Entrance会将通用资源转化为相应插件的资源并调用该插件的Restful API。&lt;/p&gt;&#xA;&lt;p&gt;从上图中可以看到，有两个Entrance和两个OpenResty实例，它们的关系是：每个Entrance中持有所有OpenResty的地址，当有信息需要更新时，Entrance会将信息更新到所有的OpenResty。那两个Entrance之间怎么协调呢？这里我们利用ETCD本身的特性做了分布式锁，保证只有一个Entrance有权限向OpenResty更新信息，这样就实现了高可用。&lt;/p&gt;&#xA;&lt;h3 id=&#34;openresty件插&#34;&gt;OpenResty件插&lt;a class=&#34;anchor&#34; href=&#34;#openresty%e4%bb%b6%e6%8f%92&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;p&gt;OpenResty是一个可以用Lua脚本来处理请求和业条逻辑的WEB应用，并且内置了众多Lua相关的指定和函数供开发者使用，很合适开发Restful API服务器，我们将OpenResty作为Entrance的插件之一原因如下：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;它是基于Nginx开发，所以稳定性和性能方面不用太担心。&lt;/li&gt;&#xA;&lt;li&gt;比较接近我们的目标，OpenResty已经帮我们把Lua模块编译进去，我们可以很方便地用Lua脚本丰富负载均衡器的功能，可以让我们省去一些工作量。&lt;/li&gt;&#xA;&lt;li&gt;同时支持L7和L4的负载均衡。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;我们在OpenResty端嵌入了一个Rest API服务器，这些API是用Lua写的，前面说过OpenResty集成了Lua脚本功能，我们可以直接用Lua来处理请求，下面是Nginx配置文件的其中一部分：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# custom api of upstream and server&#xA;server {&#xA;    listen 10002;&#xA;&#xA;    location ~ /v1/upstreams/([-_0-9a-zA-Z.@]+) {&#xA;        set $src_name $1;&#xA;        content_by_lua_file lua/upstream.lua;&#xA;    }&#xA;&#xA;    location ~ /v1/servers/([-_0-9a-zA-Z.@]+) {&#xA;        set $src_name $1;&#xA;        content_by_lua_file lua/server.lua;&#xA;    }&#xA;&#xA;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当我们调用下面的API时：&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
