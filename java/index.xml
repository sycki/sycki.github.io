<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>橡果笔记</title>
    <link>http://localhost:1313/java/index.html</link>
    <description>Recent content on 橡果笔记</description>
    <generator>Hugo</generator>
    <language>en</language>
    <atom:link href="http://localhost:1313/java/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title></title>
      <link>http://localhost:1313/java/java-from-class-to-machine-code.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/java/java-from-class-to-machine-code.html</guid>
      <description>&lt;h1 id=&#34;java---从class到机器码&#34;&gt;Java - 从CLASS到机器码&lt;a class=&#34;anchor&#34; href=&#34;#java---%e4%bb%8eclass%e5%88%b0%e6%9c%ba%e5%99%a8%e7%a0%81&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;p&gt;你真的了解Java代码的执行过程吗？我们都知道，Java代码是被编译成字节码后被JVM所执行，那JVM又是怎么执行的？不是说CPU只能认识机器码吗？那么从CLASS到机器码之间发生了什么？&lt;/p&gt;&#xA;&lt;p&gt;记得刚开始学Java的时候，老师告诉我们说：“Java是一种解释型语言，我们写的Java代码会被编译成字节码，然后由JVM解释执行”。这样说当然没错啊，只是还不够全面而已。当时在学习Java，同时我也在自学C语言（这么经典的编程语言怎么可以不学），想看看它们之们到底有什么不同之处，后来了解到C语言在被编译时，中间发生了很多事情，最后变成了二进制码，才能被CPU直接执行。可Java呢？老师明明说Java的源码是被编译成了字节码，CPU怎么可能直接认识字节码呢？上网搜了很多资料，都在说Class被JVM加载的过程，千篇一律，这个问题真的困惑我很久，后来有幸看到一篇文章（链接在本文尾部），才渐渐明白了困惑我很久问题。&lt;/p&gt;&#xA;&lt;h2 id=&#34;了解编译过程&#34;&gt;了解编译过程&lt;a class=&#34;anchor&#34; href=&#34;#%e4%ba%86%e8%a7%a3%e7%bc%96%e8%af%91%e8%bf%87%e7%a8%8b&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;我们先简单回顾一下C语言的执行过程： 假设在Linux系统上用GCC编译一个C文件，下面结论只为帮助理解。&lt;/p&gt;&#xA;&lt;p&gt;编写源文件[a.c] -&amp;gt; 预编译 -&amp;gt; [a.i] -&amp;gt; 编译 -&amp;gt; [a.s] -&amp;gt; 汇编（可选） -&amp;gt; [a.o] -&amp;gt; 链接 -&amp;gt; 机器码 -&amp;gt; CPU&lt;/p&gt;&#xA;&lt;p&gt;再回顾一下Java的执行过程： 编写源文件[a.java] -&amp;gt; 编译 -&amp;gt; [a.class/a.jar] -&amp;gt; JVM -&amp;gt; ? -&amp;gt; CPU&lt;/p&gt;&#xA;&lt;p&gt;其中，在编译过程中，也有类似C语言中的链接的过程，比如自定a.java中引用了第三方jar包中的类，那么需要在编译时将这个第三方jar包与a.java打包在一起（类似C中的静态链接），否则需要在运行a.class时，通过指定运行时参数引用到这个第三方jar包（类似C中的动态链接） 关键在class被JVM加载到内存以后，JVM会把字节码翻译成机器码，然后被CPU执行，只不过这一步发生在内存当中，翻译过的机器码也不会被保存在磁盘上（取决于JVM的实现），所以很少有人注意，为会什么JVM的默认实现不把翻译过的机器码保存在磁盘上呢？很简单，虽然是同一个class文件，但放在windowns下翻译出来的机器码跟Linux下翻译出来的机器码并不相同，这样就失去了Java程序的一大特性：可移植性。&lt;/p&gt;&#xA;&lt;h2 id=&#34;jit优化&#34;&gt;JIT优化&lt;a class=&#34;anchor&#34; href=&#34;#jit%e4%bc%98%e5%8c%96&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;说到这里，就得提一提JIT这个东西了，JIT是just in time的缩写, 也就是即时编译编译器，是JVM的一部分，它是的作用是什么呢？上面说过，class字节码是在被CPU执行前翻译成机器码的，那如果我们写了一段循环执行的代码，就这样一句一句翻译再执行必然会很慢，JIT的作用就是把那些需要频繁执行的代码一次性编译成机器码保存在内存当中，这样就避免了大量重复的翻译工作，也就加快了运行速度，而JIT编译代码本身也需要时间，所以那些只需要运行一次的代码则不经过JIT，由解释器解释执行。&lt;/p&gt;&#xA;&lt;p&gt;那什么样的代码才算是“频繁执行的代码”？这里JIT有自己的判断标准，主要由两个计数器决定，一个是方法被调用的次数，另一个是方法中循环被回弹执行的次数，当次数到达一定界限时，该段代码才会被编译，这个阈值可以通过 &lt;code&gt;-XX:CompileThreshold=N&lt;/code&gt; 这个选项指定，默认值为10000 最后再总结一下Java代码被执行的过程： 编写Java源码（示例）：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;int a = 1&#xA;int b = 2&#xA;int c = a + b&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后经过javac命令编译后变成了class文件，如果此时将其反汇编，将看到如下：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;0 iload_1&#xA;1 iload_2&#xA;2 iadd&#xA;3 istore_3&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当这个class被执行时，它在内存中会被一句一句翻成机器码，可能像下面这样：&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/java/java-nio-frame.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/java/java-nio-frame.html</guid>
      <description>&lt;h1 id=&#34;java---nio框架&#34;&gt;Java - NIO框架&lt;a class=&#34;anchor&#34; href=&#34;#java---nio%e6%a1%86%e6%9e%b6&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;什么是-nio&#34;&gt;什么是 NIO&lt;a class=&#34;anchor&#34; href=&#34;#%e4%bb%80%e4%b9%88%e6%98%af-nio&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;为了弥补 Java IO 的不足，Java 从 1.4 版本开始引入了 NIO 框架，也就是说 NIO 是一套新的 IO 框架，一般解释为 Non-blocking IO，有时也解释为 New IO。它可以在实现高并发服务器的同时占用很少的资源。&lt;/p&gt;&#xA;&lt;h2 id=&#34;传统-io-框架&#34;&gt;传统 IO 框架&lt;a class=&#34;anchor&#34; href=&#34;#%e4%bc%a0%e7%bb%9f-io-%e6%a1%86%e6%9e%b6&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;对于传统的 IO 框架，NIO 的优势主要体现在对请求的处理上，下面我们先来看看用传统 IO 怎样建立一个 TCP 连接。 首先创建服务端，并等待新的连接，下面是伪代码：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ServerSocket ser = new ServerSocket(8081);&#xA; &#xA;while (true) {&#xA;     &#xA;    Socket sk = ser.accept();&#xA; &#xA;    startNewThread(sk);&#xA; &#xA;}&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;&#xA;&lt;li&gt;第一行是创建一个服务端对象，并准备监听本机的 8081 端口。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;Socket sk = ser.accept();&lt;/code&gt; 表示开始监听新的连接请求，这行代码是阻塞式的，直到有新的客户端连接过来，会返回一个新 Socket 连接对象。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;startNewThread()&lt;/code&gt; 方法是处理 Socket 连接的主要逻辑，它会创建一个新的线程并立即返回，该线程的工作是一直监听客户端发来的数据，然后作出回应。&lt;/li&gt;&#xA;&lt;li&gt;这时又会回到循环的项部，继续等待新的连接，这就是一个服务端了。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;缺点：乍一看没什么问题，一切都很美好不是吗，但是当连接的请求多了呢，比如几万或者几百万？这样的话就会有几百万个线程同时运行，因为每一个Socket都需要一个线程来监听数据，即使大部分 Socket 都是空闲状态，只有一小部分正在繁忙的交换数据，这一百万个线程如果每个只占用 1M 的内存，那也需要 1T 的内存！这显然不太明智。&lt;/p&gt;&#xA;&lt;h2 id=&#34;nio-框架&#34;&gt;NIO 框架&lt;a class=&#34;anchor&#34; href=&#34;#nio-%e6%a1%86%e6%9e%b6&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;在上例中共有两种监听事件，一种是主线程不断地监听新的连接，另一种是其它子线程监听它所负责的Socket上的数据，那能不能把这些需要监听对象放在一起呢？然后用一个线程或少量几个线程专门负责监听所有对象上的请求？？这样就能节省大量资源啊！实际上这也是完全合理的，并且在新的 IO 框架中就是这么做的！那么我们来看看NIO的实现方式吧。&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/java/netty-guide.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/java/netty-guide.html</guid>
      <description>&lt;h1 id=&#34;java---netty入门&#34;&gt;Java - Netty入门&lt;a class=&#34;anchor&#34; href=&#34;#java---netty%e5%85%a5%e9%97%a8&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;什么是netty&#34;&gt;什么是Netty&lt;a class=&#34;anchor&#34; href=&#34;#%e4%bb%80%e4%b9%88%e6%98%afnetty&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;Netty 是一个高性能高可用的 NIO 框架，并且使用简单，用它可以轻松地开发诸如协议服务器和客户端之类的网络应用程序。它大大简化了网络编程，如 TCP 和 UDP 套接字服务器开发。已经被其它很多项目使用，比如 Spark。&lt;/p&gt;&#xA;&lt;h2 id=&#34;为什么不用-java-标准库中的-nio-框架&#34;&gt;为什么不用 Java 标准库中的 NIO 框架&lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%ba%e4%bb%80%e4%b9%88%e4%b8%8d%e7%94%a8-java-%e6%a0%87%e5%87%86%e5%ba%93%e4%b8%ad%e7%9a%84-nio-%e6%a1%86%e6%9e%b6&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;它实际上是 Java 标准库中的 NIO 框架的一个实现，并将它做成了一个通用框架，最重要的是它经过了很多项目的验证与打磨，现在已经非常稳定，如果项目组要从头开始实现一个这样好用的 NIO 框架成本是很高的，而且还需要长时间的打磨。由于 Netty 是开源项目，社区又很活跃，因此很多项目从一开始就选择 Netty 作为自己的 NIO 框架，以降低开发成本。&lt;/p&gt;&#xA;&lt;h2 id=&#34;开始动手&#34;&gt;开始动手&lt;a class=&#34;anchor&#34; href=&#34;#%e5%bc%80%e5%a7%8b%e5%8a%a8%e6%89%8b&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;我们 Netty 框架来编写一个简易应用程序，并说明它的执行流程，这个程序分为服务端和客户端两个部分，每个部分有两个类。&lt;/p&gt;&#xA;&lt;h2 id=&#34;编写服务端&#34;&gt;编写服务端&lt;a class=&#34;anchor&#34; href=&#34;#%e7%bc%96%e5%86%99%e6%9c%8d%e5%8a%a1%e7%ab%af&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;先来写服务端的主程序 &lt;code&gt;TestServer&lt;/code&gt; 类，其实不是一个类，因为它只包含一个 &lt;code&gt;main&lt;/code&gt; 方法而已：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package com.kxdmmr.demo.netty;&#xA; &#xA;import io.netty.bootstrap.ServerBootstrap;&#xA;...&#xA; &#xA;public class TestServer {&#xA; &#xA;    static final int PORT = Integer.parseInt(System.getProperty(&amp;#34;port&amp;#34;, &amp;#34;8081&amp;#34;));&#xA;    static final int SIZE = Integer.parseInt(System.getProperty(&amp;#34;size&amp;#34;, &amp;#34;128&amp;#34;));&#xA;     &#xA;    public static void main(String[] args) throws Exception {&#xA;        NioEventLoopGroup bossGroup = new NioEventLoopGroup();&#xA;        NioEventLoopGroup workerGroup = new NioEventLoopGroup();&#xA;        try{&#xA;            // 1.创建服务端&#xA;            ServerBootstrap b = new ServerBootstrap();&#xA;            // 2.配置服务端&#xA;            b.group(bossGroup, workerGroup)&#xA;            .channel(NioServerSocketChannel.class)&#xA;            .childHandler(new ChannelInitializer&amp;lt;SocketChannel&amp;gt;() {&#xA;                @Override&#xA;                public void initChannel(SocketChannel ch) throws Exception {&#xA;                    // 注入自定义的处理程序&#xA;                    ch.pipeline().addLast(new TestServerHandler());&#xA;                }&#xA;            })&#xA;            .option(ChannelOption.SO_BACKLOG, SIZE)&#xA;            .childOption(ChannelOption.SO_KEEPALIVE, true);&#xA;             &#xA;            // 3.启动服务端&#xA;            ChannelFuture f = b.bind(PORT).sync();&#xA;             &#xA;            f.channel().closeFuture().sync();&#xA;        } finally {&#xA;            // 停止所有线程池中的线程&#xA;            workerGroup.shutdownGracefully();&#xA;            bossGroup.shutdownGracefully();&#xA;        }&#xA;         &#xA;    }&#xA;}&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;创建服务端的整个过程可以分为三个步骤：1.创建服务端，2.配置服务端，3.启动服务端。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
