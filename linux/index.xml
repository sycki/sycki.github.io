<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>橡果笔记</title>
    <link>http://localhost:1313/linux/index.html</link>
    <description>Recent content on 橡果笔记</description>
    <generator>Hugo</generator>
    <language>en</language>
    <atom:link href="http://localhost:1313/linux/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title></title>
      <link>http://localhost:1313/linux/linux-centos7-multi-ip.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/linux/linux-centos7-multi-ip.html</guid>
      <description>&lt;h1 id=&#34;centos7增加子ip&#34;&gt;Centos7增加子IP&lt;a class=&#34;anchor&#34; href=&#34;#centos7%e5%a2%9e%e5%8a%a0%e5%ad%90ip&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;p&gt;假设你的 Linux 主机上运行了多了 Docker 容器，而这些容器都需要映射同样的端口号到物理机，以便向外提供服务。这时你可能想到把这些容器的端口映给物理机的不同端口上，如下：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;docker run \&#xA;-p 8080:8080 \&#xA;-p 8081:8081 \&#xA;-p 8082:8080 \&#xA;...&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但这样很容易记不清每个端口对应的服务，本文将介绍一种更优雅的方式解决这个问题。&lt;/p&gt;&#xA;&lt;h2 id=&#34;基本原理&#34;&gt;基本原理&lt;a class=&#34;anchor&#34; href=&#34;#%e5%9f%ba%e6%9c%ac%e5%8e%9f%e7%90%86&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;通过修改 Linux 配置文件，为 Linux 主机创建多个子 IP ，为每个容器中的端口映射到不同的 IP 上即可。&lt;/p&gt;&#xA;&lt;h2 id=&#34;实现步骤&#34;&gt;实现步骤&lt;a class=&#34;anchor&#34; href=&#34;#%e5%ae%9e%e7%8e%b0%e6%ad%a5%e9%aa%a4&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;查看当前网卡状态&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[suer@ser0 ~]$ ip a&#xA;1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue state UNKNOWN &#xA;    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00&#xA;    inet 127.0.0.1/8 scope host lo&#xA;       valid_lft forever preferred_lft forever&#xA;    inet6 ::1/128 scope host &#xA;       valid_lft forever preferred_lft forever&#xA;2: enp8s0f0: &amp;lt;NO-CARRIER,BROADCAST,MULTICAST,UP&amp;gt; mtu 1500 qdisc mq state DOWN qlen 1000&#xA;    link/ether 70:e2:84:0e:5a:87 brd ff:ff:ff:ff:ff:ff&#xA;3: enp10s0: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000&#xA;    link/ether 70:e2:84:0e:5a:86 brd ff:ff:ff:ff:ff:ff&#xA;    inet 10.100.124.231/24 brd 10.100.124.255 scope global enp10s0&#xA;       valid_lft forever preferred_lft forever&#xA;4: enp8s0f1: &amp;lt;NO-CARRIER,BROADCAST,MULTICAST,UP&amp;gt; mtu 1500 qdisc mq state DOWN qlen 1000&#xA;    link/ether 70:e2:84:0e:5a:88 brd ff:ff:ff:ff:ff:ff&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们看到第三个网卡 IP 地址为：10.100.124.231，也就是目前系统的主 IP 地址，它的名字为：enp10s0&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/linux/linux-parallel-progress.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/linux/linux-parallel-progress.html</guid>
      <description>&lt;h1 id=&#34;炫酷的并行进度条&#34;&gt;炫酷的并行进度条&lt;a class=&#34;anchor&#34; href=&#34;#%e7%82%ab%e9%85%b7%e7%9a%84%e5%b9%b6%e8%a1%8c%e8%bf%9b%e5%ba%a6%e6%9d%a1&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;p&gt;你知道怎样写一个并行的进度条吗，如果是在WEB页上或是GUI编程中这很简单，如果是用Shell写呢？或者Python？也许哪天你需要写一个这样的程序，也许这时的你正一筹莫展，那么恭喜你看到本文。 我们先来看一个例子：&#xA;&lt;img src=&#34;img/linux-parallel-progress/linux-parallel-progress_progress.png&#34; alt=&#34;&#34; /&gt;&#xA;这是一个普通的软件安装程序，图中的两个箭头指向两个不同的进度条，其中上方是总进度条，右下角那个是一个不停转圈圈的进度条，表示该步骤正在进行中。没错，这是用Python脚本实现的，用Shell也是一样，而且可能比Python还要简单。&lt;/p&gt;&#xA;&lt;h2 id=&#34;python实现&#34;&gt;Python实现&lt;a class=&#34;anchor&#34; href=&#34;#python%e5%ae%9e%e7%8e%b0&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;在Python中，线程是假线程，它与C或者Java中的线程不同，为了完美，博主在实现的时候用了多进程，也就是multiprocessing模块。&lt;/li&gt;&#xA;&lt;li&gt;在主进程中启动两个子进试，分别负责两个进度条（当然也可以是任意多个），总进度条需要一个全局变量，以在不同的步骤中为其赋不同的值，小进度条在每步完成的时候向下移动一行。&lt;/li&gt;&#xA;&lt;li&gt;关于光标控制，这是一个关键点，因为在任何情况下，屏幕上只有一个光标，且所有输出都会落在光标处，那上例中的总进度条怎么会出现在光标的上方呢？这就需要移动光标了，在Python中，它没有这个能力，只能借助第三方库来实现，这样就为程序的跨平台带来麻烦，而Shell本身提供了这个功能，而且简单到不行，假设我要在屏幕的第三十行第五十列打印一个“hello”，只需这样：&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;echo -e &amp;#34;\033[30;50Hhello&amp;#34;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;或者：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;printf &amp;#34;\033[%d;%dH%s&amp;#34; 30 50 hello&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;4&#34;&gt;&#xA;&lt;li&gt;接下来就是对光标进一步控制，因为在上一步中将光标移到了总进度条的位置，当打印完指定的字符后还需要移动到小进度条的位置，博主在网上搜索良久后终于找到了完美的方法，也是简单到不行：tput sc 与 tput rc 两条命令，前者用于暂时保存光标位置，然后不管将光标称动到哪，后者都能将位置还原，现在我们将上步骤中的打印命令改良一下：&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;tput sc ;printf &amp;#34;\033[%d;%dH%s\n&amp;#34; 30 50 hello ;tput rc&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;5&#34;&gt;&#xA;&lt;li&gt;最后就是同步问题，因为两个进度条是并行执行的，这意味着两个进程可能会在同一时刻执行打印命令，导致打印在屏幕上的字符可能错乱，所以我们要保证在同一时刻只有一个进程在调用print命令，这就用到了多进程锁，而multiprocessing模块已经提供了这样的锁&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;综上所述，这里给出一个简单的示例：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#!/usr/bin/python&#xA;# -*- coding: utf-8 -*-&#xA; &#xA;import os,time&#xA;from multiprocessing import Process, Manager, Lock&#xA; &#xA;# 打印info在终端的指定位置&#xA;def writer(info, y = 0, x = 0):&#xA;    with lock:&#xA;        print_cmd = &amp;#34;tput sc &amp;gt;&amp;amp;2 &amp;amp;&amp;amp; echo -e &amp;#39;\033[%s;%sH%s&amp;#39; &amp;gt;&amp;amp;2 &amp;amp;&amp;amp; tput rc &amp;gt;&amp;amp;2&amp;#34; % (y, x, info)&#xA;        os.system(print_cmd)&#xA; &#xA;# 根据pbar_data内的数据打印进度条，bar_length为进度条总长度&#xA;def progress_bar(pbar_data, y = 0, x = 0, bar_length = 80):&#xA;    percent = float(bar_length) / 100&#xA;    while pbar_data[0] &amp;lt; bar_length:&#xA;        time.sleep(0.05)&#xA;        current = int(float(pbar_data[1]) * percent)&#xA;        if pbar_data[0] != current:&#xA;            for i in range(pbar_data[0], current + 1):&#xA;                time.sleep(pbar_data[2])&#xA;                info = &amp;#34;\033[1;32;40m Progress: [&amp;#34; + (&amp;#34;=&amp;#34; * (i - 1) + &amp;#34;&amp;gt;&amp;#34;).ljust(bar_length,&amp;#34; &amp;#34;) + &amp;#34;] &amp;#34; + str(int(i / percent)) + &amp;#34;% \033[0m&amp;#34;&#xA;                writer(info, y)&#xA;            pbar_data[0] = current&#xA; &#xA;&amp;#39;&amp;#39;&amp;#39;&#xA;创建全局变量，用于将主进程信息传递给子进程&#xA;data_a[0]: 已完成进度的百分比&#xA;data_a[1]: 目前最新进度的百分比&#xA;data_a[2]: 进度条变化速度&#xA;&amp;#39;&amp;#39;&amp;#39;&#xA; &#xA;# pbar_a的数据&#xA;data_a = Manager().list()&#xA;data_a.append(0)&#xA;data_a.append(2)&#xA;data_a.append(0.5)&#xA; &#xA;# pbar_b的数据&#xA;data_b = Manager().list()&#xA;data_b.append(0)&#xA;data_b.append(2)&#xA;data_b.append(0.5)&#xA; &#xA;# 创建进程锁&#xA;lock = Lock()&#xA; &#xA;# 创建总进度条进程&#xA;pbar_a = Process(target = progress_bar, args=(data_a, 10, 0))&#xA;pbar_a.daemon = True&#xA; &#xA;# 创建其它进度条进程&#xA;pbar_b = Process(target = progress_bar, args=(data_b, 12, 0))&#xA;pbar_b.daemon = True&#xA; &#xA;# 隐藏光标&#xA;os.system(&amp;#34;printf &amp;#39;\33[2J\33[?25l\r&amp;#39;&amp;#34;)&#xA; &#xA;# 开始其它步骤并打印进度条&#xA;pbar_a.start()&#xA;pbar_b.start()&#xA; &#xA;# Step 1&#xA;data_a[1] = 10&#xA;data_b[1] = 30&#xA;time.sleep(5)&#xA; &#xA;# Step 2&#xA;data_a[1] = 70&#xA;data_a[2] = 0.1&#xA;time.sleep(5)&#xA; &#xA;# Step 3&#xA;data_a[1] = 100&#xA;data_b[1] = 100&#xA;data_b[2] = 0.05&#xA; &#xA;# 等待进度条执行完毕&#xA;pbar_a.join()&#xA;pbar_b.join()&#xA; &#xA;# 显示光标&#xA;os.system(&amp;#34;printf &amp;#39;\33[?25h\n&amp;#39;&amp;#34;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;-End-&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/linux/linux-pipe-redirect.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/linux/linux-pipe-redirect.html</guid>
      <description>&lt;h1 id=&#34;管道与重定向详解&#34;&gt;管道与重定向详解&lt;a class=&#34;anchor&#34; href=&#34;#%e7%ae%a1%e9%81%93%e4%b8%8e%e9%87%8d%e5%ae%9a%e5%90%91%e8%af%a6%e8%a7%a3&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;h2 id=&#34;unix-哲学&#34;&gt;Unix 哲学&lt;a class=&#34;anchor&#34; href=&#34;#unix-%e5%93%b2%e5%ad%a6&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;在 Unix 系统中，任何程序都可以实现三个接口，即：标准输入（stdin）、标准输出（stdout）、标准错误输出（stderr），你应该注意到，这三个东西前面都有标准两个字，是的，正是这种标准，使得 Unix 系统中的所有独立的程序可以相互传递数据而没有任何限制，这种机制给用户带来了极大的方便，这正是 Unix 哲学！&lt;/p&gt;&#xA;&lt;h2 id=&#34;什么是管道&#34;&gt;什么是管道&lt;a class=&#34;anchor&#34; href=&#34;#%e4%bb%80%e4%b9%88%e6%98%af%e7%ae%a1%e9%81%93&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;在 Unix/Linux 中，有一个常用的符号，叫做管道符，写做：&amp;quot;|&amp;quot;，举个例子：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ls / | grep usr&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;ls&lt;/code&gt; 和 &lt;code&gt;grep&lt;/code&gt; 是两个独立的程序，但是 &lt;code&gt;ls&lt;/code&gt; 的输出数据可以传给 &lt;code&gt;grep&lt;/code&gt; 继续处理，而管道符&amp;quot;|&amp;ldquo;在中间起到了数据传输的作用，正如其名，它就像一根橡胶水管，这根水管的两端可以连接任意程序，因为这些程序都向外提供了一组一模一样的接口，这样我们就可以将任意数量的不同功能的程序随意组合起来使用。&lt;/p&gt;&#xA;&lt;h2 id=&#34;什么是重定向&#34;&gt;什么是重定向&lt;a class=&#34;anchor&#34; href=&#34;#%e4%bb%80%e4%b9%88%e6%98%af%e9%87%8d%e5%ae%9a%e5%90%91&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;在上例中，管道符的一端连接到 &lt;code&gt;ls&lt;/code&gt; 的标准输出，另一端连接到 &lt;code&gt;grep&lt;/code&gt; 的标准输入，那我们能不能将其中一端连接到一个文件呢？这样我们就可以将结果数据保存下来，或者将一个文件输入到某个程序中去。当然可以，这时就用到重定向了，下面以 Bash Shell 为例，解释常用重定向符号的意义及其用法。&lt;/p&gt;&#xA;&lt;h2 id=&#34;重定向符号&#34;&gt;重定向符号&lt;a class=&#34;anchor&#34; href=&#34;#%e9%87%8d%e5%ae%9a%e5%90%91%e7%ac%a6%e5%8f%b7&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;code&gt;0&amp;lt;&lt;/code&gt; 标准输入重定向，0可省略&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;1&amp;gt;&lt;/code&gt; 标准输出重定向，1可省略&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;2&amp;gt;&lt;/code&gt; 标准错误输出重定向&lt;/li&gt;&#xA;&lt;li&gt;它们的用法都是左边给定一个程序，右边给定一个文件，&lt;code&gt;&amp;gt;&lt;/code&gt; 表示覆盖，&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 表示追加。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;输出重定向&#34;&gt;输出重定向&lt;a class=&#34;anchor&#34; href=&#34;#%e8%be%93%e5%87%ba%e9%87%8d%e5%ae%9a%e5%90%91&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;如果我想把一个程序的标准输出追加到 &lt;code&gt;o.txt&lt;/code&gt; 文件中，而错误输出覆盖到 &lt;code&gt;e.txt&lt;/code&gt; 文件中，可以这样写：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ls &amp;gt;&amp;gt; o.txt 2&amp;gt; e.txt&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;把标准输出与错误输出都写入到 &lt;code&gt;o.txt&lt;/code&gt;：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ls &amp;amp;&amp;gt; o.txt&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;或者像下面这样写&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ls &amp;gt; o.txt 2&amp;gt;&amp;amp;1&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这两种写法是等价的，但明显第一种更为简洁。&lt;/p&gt;&#xA;&lt;p&gt;但不能写成下面这样：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ls 2&amp;gt;&amp;amp;1 &amp;gt; o.txt&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;它不会像你期望的那样执行，这行命令中有两个重定向操作，所有操作符会被从左到右依次解释，首先错误输出中的数据被重定向到标准输出流中，这时标准输出指向的是终端，然后第二个重定向操作将标准输出重定向到了 &lt;code&gt;o.txt&lt;/code&gt;，但这次操作只影响了标准输出，并没有影响错误输出的指向。&lt;/p&gt;&#xA;&lt;p&gt;上面的解释有些牵强，因为博主实在不知道该怎样翻译，官方解释如下：&lt;/p&gt;&#xA;&lt;blockquote class=&#39;book-hint &#39;&gt;&#xA;&lt;p&gt;directs only the standard output to file dirlist, because the standard error was duplicated from the standard output before the standard output was redirected to dirlist.&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/linux/linux-read-file-by-line.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/linux/linux-read-file-by-line.html</guid>
      <description>&lt;h1 id=&#34;逐行读取文件的几种方法&#34;&gt;逐行读取文件的几种方法&lt;a class=&#34;anchor&#34; href=&#34;#%e9%80%90%e8%a1%8c%e8%af%bb%e5%8f%96%e6%96%87%e4%bb%b6%e7%9a%84%e5%87%a0%e7%a7%8d%e6%96%b9%e6%b3%95&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;p&gt;shell编程也是一门学问，虽然功能有限，但要完全掌握它并不容易，甚至比JAVA这样的编程语言更难掌握，因为它考虑了太多的特殊情况，在编写的时候有更多的不确定性。&lt;/p&gt;&#xA;&lt;p&gt;有一次同事问我，shell里怎样逐行读取一个文件，以处理它，没想到他会被这样的问题给难住。原来他写了一个while语句（从网上搜的）来逐行处理文件，发现这个语句没有像预期的那样执行，写法如下：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[user@node1 ~]$ vim test.sh&#xA;#!/bin/bash&#xA; &#xA;index=1&#xA;while read line&#xA;do&#xA;&#x9;echo &amp;#34;$((index++)): $line&amp;#34;&#xA;&#x9;ssh localhost &amp;#34;echo $line &amp;gt;&amp;gt; b.txt&amp;#34;&#xA;done &amp;lt; a.txt&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;执行后，只打印出了a.txt中的第一行，当时以为写错了，结果在这个小问题上折腾了很久，再次上网搜索发现原来已很多人也遇到了同样的问题，而且有人已经给出来解释与解决方法。&lt;/p&gt;&#xA;&lt;h3 id=&#34;分析原因&#34;&gt;分析原因&lt;a class=&#34;anchor&#34; href=&#34;#%e5%88%86%e6%9e%90%e5%8e%9f%e5%9b%a0&#34;&gt;#&lt;/a&gt;&lt;/h3&gt;&#xA;&lt;p&gt;首先是跟ssh这个命令有关系，因为把ssh那一个行去掉以后就一切正常了。&lt;/p&gt;&#xA;&lt;p&gt;后来看到有网友说为ssh加上-n选项就可以了，所以特地看了下ssh命令的文档，找到了如下描述：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[user@node1 ~]$ man ssh&#xA;...&#xA;-n      Redirects stdin from /dev/null (actually, prevents reading from stdin).  This must be used when ssh is run in the background.  A com-&#xA;             mon trick is to use this to run X11 programs on a remote machine.  For example, ssh -n shadows.cs.hut.fi emacs &amp;amp; will start an emacs&#xA;             on shadows.cs.hut.fi, and the X11 connection will be automatically forwarded over an encrypted channel.  The ssh program will be put&#xA;             in the background.  (This does not work if ssh needs to ask for a password or passphrase; see also the -f option.)&#xA;...&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;看到这里应该明白了，主要是因为ssh会主动从输入流中读取数据。&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/linux/linux-resolve-iptables.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/linux/linux-resolve-iptables.html</guid>
      <description>&lt;h1 id=&#34;理解iptables&#34;&gt;理解iptables&lt;a class=&#34;anchor&#34; href=&#34;#%e7%90%86%e8%a7%a3iptables&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;p&gt;iptables是Linux系统中的一个命令，也是Linux系统上最常用的防火墙，我们常见的Linux发行版如：CentOS、Ubuntu等都是用iptables作为默认的防火墙，它的强大之处在于它可以控制所有进出系统的数据包。然而，对于初次接触它的人来说，这是个比较难用的命令，不止一个人问过我怎样写一条阻止某IP的命令，因为用它增加一条防火墙规则可能需要写一条很长的命令，如果你没有了解它的工作原理，是写不出一条完整的iptables命令的。本文将剖析它的工作原理并结合例子让你更容易使用它。&lt;/p&gt;&#xA;&lt;h2 id=&#34;前提工作&#34;&gt;前提工作&lt;a class=&#34;anchor&#34; href=&#34;#%e5%89%8d%e6%8f%90%e5%b7%a5%e4%bd%9c&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;要了解iptables就先要了解数据包，这里说的数据包指的是在网络中传输的数据包，又名：报文，如果你了解过TCP协议并写过相关的代码，那么这个词应该不会陌生，如果你不了也没关系，我们这就来谈一谈这个数据包的概念。&lt;/p&gt;&#xA;&lt;blockquote class=&#39;book-hint &#39;&gt;&#xA;&lt;p&gt;其实这个数据包的结构又要用到七层协议的概念，真是一环扣一环，这里我就且当你了解七层协议的概念，如果真的不懂可以先去看看《鸟哥的Linux私房菜》，不过我会尽量讲的通俗一些，希望这不会影响到你阅读下文。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&#34;网络传输&#34;&gt;网络传输&lt;a class=&#34;anchor&#34; href=&#34;#%e7%bd%91%e7%bb%9c%e4%bc%a0%e8%be%93&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;设有两台电脑A与B，A通过网络发送一个文件给B，这个文件会被切分成一个一个的小数据包，每个数据包大小约 1KB 左右，然后转成二进制码按顺序发出去，在网络中以电讯号的形式传输给B，B接收到以后再将这些二进制码转成数据包，最后组合成一个文件。&lt;/p&gt;&#xA;&lt;h2 id=&#34;封包表头&#34;&gt;封包表头&lt;a class=&#34;anchor&#34; href=&#34;#%e5%b0%81%e5%8c%85%e8%a1%a8%e5%a4%b4&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;数据包也称为封包，一个完整的封包，除了我们需要发送的内容以外还包含了很多额外信息，也就是封包表头，主要用来标记这个数据包“从哪里来到哪里去”，在上例中，如果AB相距较远的话，中间一般会经过多个路由器和交换机，当然还有网卡网线等。。。当一个封包经过途中每个设备时，这些设备都需要读出这些封包的表头，才能知道这个封包要去哪里，然后再发给对应的设备，下一个设备收到这个封包也是一样，最终到达了B，可以说封包表头与数据本身同等重要。&lt;/p&gt;&#xA;&lt;h2 id=&#34;封包格式&#34;&gt;封包格式&lt;a class=&#34;anchor&#34; href=&#34;#%e5%b0%81%e5%8c%85%e6%a0%bc%e5%bc%8f&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;实际上，每个数据包外面套了三层封包，每层都是不同的格式，用来给不同的设备读取。如果以TCP作为传输协议，这三层封包分别为：MAC封包、IP封包、TPC封包，用下图来说明它们的关系：&#xA;&lt;img src=&#34;img/linux-resolve-iptables/linux-resolve-iptables_data-package.png&#34; alt=&#34;&#34; /&gt;&#xA;图中只是简单的列出每个封包表头中较关键的信息，其实还有很多其它信息，比如TCP封包表头中的序列号、状态码，每种封包的详细格式，这里就不展开说明了，不然的话就有点跑题了。如果想深入了解的话网上有很多相关资料。&lt;/p&gt;&#xA;&lt;h2 id=&#34;iptables中的表table&#34;&gt;iptables中的表（table）&lt;a class=&#34;anchor&#34; href=&#34;#iptables%e4%b8%ad%e7%9a%84%e8%a1%a8table&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;终于说到正点了，，iptables的原理正是分析每个封包的表头，然后根据我们设定的防火墙规则作出相应的动作。 在iptables中有表的概念，使用的时候一般用默认的表，需要的话也可以自己建表，在CentOS6.5中默认有四张表：filter、nat、mangle、raw，每张表有不同的作用:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;filter&lt;/code&gt; 表的作用就是防火墙&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;nat&lt;/code&gt; 表是用来作数据转发&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;mangle&lt;/code&gt; 表专门对特定数据包进处理&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;raw&lt;/code&gt; 表也是在特殊情况下用的，可以减少iptabls对性能的影响&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;前两个表是常用的表，后两个用的很少，而且博主一直没有用过，本文只对前两个表进行介绍。&lt;/p&gt;&#xA;&lt;h2 id=&#34;表中的链chains&#34;&gt;表中的链（chains）&lt;a class=&#34;anchor&#34; href=&#34;#%e8%a1%a8%e4%b8%ad%e7%9a%84%e9%93%bechains&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;上面的每张表中都有多个链，链可以理解为小表，每个小表用来处理不同的情况，在filter表中，默认有三个小表：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;INPUT&lt;/code&gt; 进入本机的封包要经过此链&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;OUTPUT&lt;/code&gt; 从本机发出的封包要经过此链&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;FORWARD&lt;/code&gt; 经过nat表后目标不是本机的封包会经过此链&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;在nat表中，默认也有三个小表：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;PREROUTING&lt;/code&gt; 封包进入本机时要先经过此链&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;POSTROUTING&lt;/code&gt; 封包从本机发送出去之前要经过此链&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;OUTPUT&lt;/code&gt; 经filter表过滤后的封包会经过此链&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;由此可以看出，数据包在经过这些链时，是有先后顺序的，而且每张表也是有关联的，如果我们只考虑filter表和nat表，那么封包在通过iptables时的顺序大致如下： &lt;img src=&#34;img/linux-resolve-iptables/linux-resolve-iptables_data-flow.png&#34; alt=&#34;&#34; /&gt; 上图中需要注意的是，nat表中的PREROUTING链，nat是用来做数据转发的，它可以修改封包表头中的内容，假设我在PREROUTING链中写入一条规则：将目标为本机的封包转发到 &lt;code&gt;137.137.0.200&lt;/code&gt; 这个IP上，这样当封包从PREROUTING链出来后，就不走图中的第二步，而是会经上图中的两条黄线，直接被送出本机。&lt;/p&gt;&#xA;&lt;h2 id=&#34;链中的规则rule&#34;&gt;链中的规则（rule）&lt;a class=&#34;anchor&#34; href=&#34;#%e9%93%be%e4%b8%ad%e7%9a%84%e8%a7%84%e5%88%99rule&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;每个小表中可以有多条规则，经过此小表的封包要符合此小表上的每条规则，最后才能通过，以filter表为例：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[root@blog ~]# iptables -t filter -n -L&#xA;Chain INPUT (policy DROP)&#xA;target     prot opt source               destination         &#xA;REJECT     all  --  191.96.249.0/24      0.0.0.0/0            reject-with icmp-port-unreachable&#xA;ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0            tcp dpt:22&#xA;ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0            tcp dpt:80&#xA; &#xA;Chain FORWARD (policy ACCEPT)&#xA;target     prot opt source               destination         &#xA; &#xA;Chain OUTPUT (policy ACCEPT)&#xA;target     prot opt source               destination &lt;/code&gt;&lt;/pre&gt;&lt;p&gt;命令说明：&lt;/p&gt;</description>
    </item>
    <item>
      <title></title>
      <link>http://localhost:1313/linux/linux-send-mail.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/linux/linux-send-mail.html</guid>
      <description>&lt;h1 id=&#34;发送邮件的两种方式&#34;&gt;发送邮件的两种方式&lt;a class=&#34;anchor&#34; href=&#34;#%e5%8f%91%e9%80%81%e9%82%ae%e4%bb%b6%e7%9a%84%e4%b8%a4%e7%a7%8d%e6%96%b9%e5%bc%8f&#34;&gt;#&lt;/a&gt;&lt;/h1&gt;&#xA;&lt;p&gt;很多情况下，我们需要在服务器上向外发送邮件，用来获得任务报告、安全监控等等，到这里有人会说了：这还不简单！我一条命令分分种就可以搞定。 而实际上，还是有点难度的，难在哪？我想一定有人在Linux下发邮件的时候碰到过下面这样的情况 我们先来发一份邮件，Linux下发送邮件很简单：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;echo &amp;#34;hello&amp;#34; | mail -s &amp;#34;title&amp;#34; mybox@163.com -a nginx.log&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样发出去有两种结果，要么提示你发送失败，要么石沉大海，然后你各种尝试，，各种搜资料，，各种失败，， 说到底，主要是因为国内垃圾邮件太多导致的，在国内很多人利用邮箱向他们所谓的“客户”（那些并没有订阅的人）或其它使用邮箱的人群发送大量的广告，以此牟利，甚至还发往国外，使得各大邮箱服务商不得不想办法来过滤这些垃圾邮件，像上面那封邮件也会被当成是垃圾邮件，然后让我们这些用邮箱干正事的人也跟着受罪，无知的人们哪。。那我们该怎么办？本文将介绍两种可行的方法。&lt;/p&gt;&#xA;&lt;h2 id=&#34;在linux下发送邮件按照发送原理大概分为两类&#34;&gt;在Linux下发送邮件，按照发送原理大概分为两类&lt;a class=&#34;anchor&#34; href=&#34;#%e5%9c%a8linux%e4%b8%8b%e5%8f%91%e9%80%81%e9%82%ae%e4%bb%b6%e6%8c%89%e7%85%a7%e5%8f%91%e9%80%81%e5%8e%9f%e7%90%86%e5%a4%a7%e6%a6%82%e5%88%86%e4%b8%ba%e4%b8%a4%e7%b1%bb&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;一种是把 Linux 本身当做邮件服务器，由它来直接发送给其它发件人，但这种方式有个弊端，假设我要给 &lt;a href=&#34;mailto:abc@163.com&#34;&gt;abc@163.com&lt;/a&gt; 发一份邮件，那么邮件到达 163 服务时，它可能把我们的邮件当成垃圾邮件，导致邮件被拒收，本文不介绍此种方式。&lt;/li&gt;&#xA;&lt;li&gt;还有一种方式是通过第三方服务器发送，假设我要给 &lt;a href=&#34;mailto:abc@163.com&#34;&gt;abc@163.com&lt;/a&gt; 发一份邮件，我可以先把邮件交给 qq 邮件服务器，qq 服务器再转发给 163 服务器，这样就会降低被拒收的概率，但这种方式需要先通过 qq 邮件服务器的登录认证才行，这也是本文重点介绍的方式。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;先引用两句名言&#34;&gt;先引用两句名言&lt;a class=&#34;anchor&#34; href=&#34;#%e5%85%88%e5%bc%95%e7%94%a8%e4%b8%a4%e5%8f%a5%e5%90%8d%e8%a8%80&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;blockquote class=&#39;book-hint &#39;&gt;&#xA;&lt;p&gt;勿以恶小而为之，勿以善小而不为&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote class=&#39;book-hint &#39;&gt;&#xA;&lt;p&gt;地势坤，君子以厚德载物&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&#34;两种可行的方法&#34;&gt;两种可行的方法&lt;a class=&#34;anchor&#34; href=&#34;#%e4%b8%a4%e7%a7%8d%e5%8f%af%e8%a1%8c%e7%9a%84%e6%96%b9%e6%b3%95&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;h2 id=&#34;方法一利用mailx命令&#34;&gt;方法一，利用mailx命令&lt;a class=&#34;anchor&#34; href=&#34;#%e6%96%b9%e6%b3%95%e4%b8%80%e5%88%a9%e7%94%a8mailx%e5%91%bd%e4%bb%a4&#34;&gt;#&lt;/a&gt;&lt;/h2&gt;&#xA;&lt;p&gt;这个方法相对简单，但只支持smtp协议，以CentOS7.2为例，如果有防火墙，请将25端口加入白名单，sendmail服务可以关闭 先安装mailx&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo yum install mailx -y&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;修改配置文件&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo echo &amp;#34;set from=${user}@163.com smtp=smtp.163.com smtp-auth-user=$user \&#xA;smtp-auth-password=$passwd smtp-auth=login&amp;#34; &amp;gt;&amp;gt; /etc/mail.rc &lt;/code&gt;&lt;/pre&gt;&lt;p&gt;发送邮件测试&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;echo -e &amp;#39;任务序号：0001&amp;#39; | mail -s &amp;#39;任务成功：0001&amp;#39; my_mail@163.com&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果发送成功的话，不需要等太久，一般一分种足够了，然后去检查一下自己的邮箱吧，， 如果你的25端口没开，或者因为其它原因导致连不到服务器，它会有提示告诉你连接超时，像下面这样：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;could not connect: 连接超时&#xA;&amp;#34;/home/user/dead.letter&amp;#34; 13/344&#xA;. . . message not sent.&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果两分种以上还没收到邮件，且没有任何提示，那可能是被服务器拒收了，而且笔者也没有找到mail的日志在哪。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
